{
    "file_paths": [
        "src/_pytest/terminal.py",
        "src/_pytest/config/__init__.py"
    ],
    "symbols": [
        "_pytest.terminal.TerminalReporter._locationline",
        "_pytest.config.Config.cwd_relative_nodeid"
    ],
    "code_spans": {
        "_pytest.terminal.TerminalReporter": {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]\n\n    @property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw\n\n    @writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)\n\n    def flush(self) -> None:\n        self._tw.flush()\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()\n\n    @property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected\n\n    def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})\n\n    def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line\n\n    def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]\n\n    def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)\n\n    def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)\n\n    def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)\n\n    def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types\n\n    def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color\n\n    def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))\n\n    def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 261,
            "start_column": 7463,
            "end_line": 0,
            "end_column": 40474,
            "start_byte": 7463,
            "end_byte": 0
        },
        "_pytest.terminal.TerminalReporter.__init__": {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]",
            "start_line": 262,
            "start_column": 7491,
            "end_line": 4,
            "end_column": 8496,
            "start_byte": 7491,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.writer": {
            "name": "_pytest.terminal.TerminalReporter.writer",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value",
            "start_line": 291,
            "start_column": 8640,
            "end_line": 4,
            "end_column": 8783,
            "start_byte": 8640,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._determine_show_progress_info": {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 296,
            "start_column": 8789,
            "end_line": 4,
            "end_column": 9372,
            "start_byte": 8789,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.verbosity": {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 309,
            "start_column": 9378,
            "end_line": 4,
            "end_column": 9454,
            "start_byte": 9378,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.showheader": {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 313,
            "start_column": 9460,
            "end_line": 4,
            "end_column": 9530,
            "start_byte": 9460,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.showfspath": {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 323,
            "start_column": 9685,
            "end_line": 4,
            "end_column": 9769,
            "start_byte": 9685,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.showlongtestinfo": {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 327,
            "start_column": 9775,
            "end_line": 4,
            "end_column": 9850,
            "start_byte": 9775,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.hasopt": {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 331,
            "start_column": 9856,
            "end_line": 4,
            "end_column": 9983,
            "start_byte": 9856,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_fspath_result": {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)",
            "start_line": 335,
            "start_column": 9989,
            "end_line": 4,
            "end_column": 10686,
            "start_byte": 9989,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_ensure_prefix": {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 348,
            "start_column": 10692,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10692,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.ensure_newline": {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 357,
            "start_column": 10998,
            "end_line": 4,
            "end_column": 11120,
            "start_byte": 10998,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write": {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)",
            "start_line": 362,
            "start_column": 11126,
            "end_line": 4,
            "end_column": 11259,
            "start_byte": 11126,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.flush": {
            "name": "_pytest.terminal.TerminalReporter.flush",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def flush(self) -> None:\n        self._tw.flush()",
            "start_line": 365,
            "start_column": 11265,
            "end_line": 4,
            "end_column": 11314,
            "start_byte": 11265,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_line": {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 368,
            "start_column": 11320,
            "end_line": 4,
            "end_column": 11510,
            "start_byte": 11320,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.rewrite": {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 374,
            "start_column": 11516,
            "end_line": 4,
            "end_column": 12134,
            "start_byte": 11516,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_sep": {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 392,
            "start_column": 12140,
            "end_line": 4,
            "end_column": 12260,
            "start_byte": 12140,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.section": {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 396,
            "start_column": 12266,
            "end_line": 4,
            "end_column": 12345,
            "start_byte": 12266,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.line": {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 399,
            "start_column": 12351,
            "end_line": 4,
            "end_column": 12410,
            "start_byte": 12351,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._add_stats": {
            "name": "_pytest.terminal.TerminalReporter._add_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()",
            "start_line": 402,
            "start_column": 12416,
            "end_line": 4,
            "end_column": 12648,
            "start_byte": 12416,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_internalerror": {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 408,
            "start_column": 12654,
            "end_line": 4,
            "end_column": 12811,
            "start_byte": 12654,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_warning_captured": {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])",
            "start_line": 413,
            "start_column": 12817,
            "end_line": 4,
            "end_column": 13350,
            "start_byte": 12817,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_plugin_registered": {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 426,
            "start_column": 13356,
            "end_line": 4,
            "end_column": 13731,
            "start_byte": 13356,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_deselected": {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)",
            "start_line": 434,
            "start_column": 13737,
            "end_line": 4,
            "end_column": 13817,
            "start_byte": 13737,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_runtest_logstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()",
            "start_line": 437,
            "start_column": 13823,
            "end_line": 4,
            "end_column": 14241,
            "start_byte": 13823,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_runtest_logreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()",
            "start_line": 448,
            "start_column": 14247,
            "end_line": 4,
            "end_column": 16159,
            "start_byte": 14247,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._is_last_item": {
            "name": "_pytest.terminal.TerminalReporter._is_last_item",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected",
            "start_line": 497,
            "start_column": 16165,
            "end_line": 4,
            "end_column": 16287,
            "start_byte": 16165,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})",
            "start_line": 501,
            "start_column": 16293,
            "end_line": 4,
            "end_column": 17210,
            "start_byte": 16293,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._get_progress_information_message": {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"",
            "start_line": 522,
            "start_column": 17216,
            "end_line": 4,
            "end_column": 17957,
            "start_byte": 17216,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._write_progress_information_filling_space": {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})",
            "start_line": 539,
            "start_column": 17963,
            "end_line": 4,
            "end_column": 18259,
            "start_byte": 17963,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._width_of_current_line": {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line",
            "start_line": 546,
            "start_column": 18265,
            "end_line": 4,
            "end_column": 18465,
            "start_byte": 18265,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_collection": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)",
            "start_line": 551,
            "start_column": 18471,
            "end_line": 4,
            "end_column": 18821,
            "start_byte": 18471,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_collectreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 559,
            "start_column": 18827,
            "end_line": 4,
            "end_column": 19212,
            "start_byte": 18827,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.report_collect": {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 569,
            "start_column": 19218,
            "end_line": 4,
            "end_column": 20633,
            "start_byte": 19218,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_sessionstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 609,
            "start_column": 20639,
            "end_line": 4,
            "end_column": 21805,
            "start_byte": 20639,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks": {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 637,
            "start_column": 21811,
            "end_line": 4,
            "end_column": 21954,
            "start_byte": 21811,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_report_header": {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 642,
            "start_column": 21960,
            "end_line": 4,
            "end_column": 22615,
            "start_byte": 21960,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_collection_finish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)",
            "start_line": 659,
            "start_column": 22621,
            "end_line": 4,
            "end_column": 23336,
            "start_byte": 22621,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._printcollecteditems": {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))",
            "start_line": 679,
            "start_column": 23342,
            "end_line": 4,
            "end_column": 25064,
            "start_byte": 23342,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_sessionfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()",
            "start_line": 719,
            "start_column": 25070,
            "end_line": 4,
            "end_column": 26017,
            "start_byte": 25070,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_terminal_summary": {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 744,
            "start_column": 26023,
            "end_line": 4,
            "end_column": 26366,
            "start_byte": 26023,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt": {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 755,
            "start_column": 26372,
            "end_line": 4,
            "end_column": 26487,
            "start_byte": 26372,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_unconfigure": {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 758,
            "start_column": 26493,
            "end_line": 4,
            "end_column": 26620,
            "start_byte": 26493,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._report_keyboardinterrupt": {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 762,
            "start_column": 26626,
            "end_line": 4,
            "end_column": 27154,
            "start_byte": 26626,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._getfailureheadline": {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 798,
            "start_column": 27988,
            "end_line": 4,
            "end_column": 28146,
            "start_byte": 27988,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._getcrashline": {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 804,
            "start_column": 28152,
            "end_line": 4,
            "end_column": 28396,
            "start_byte": 28152,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.getreports": {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 816,
            "start_column": 28448,
            "end_line": 4,
            "end_column": 28637,
            "start_byte": 28448,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_warnings": {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 823,
            "start_column": 28643,
            "end_line": 4,
            "end_column": 31098,
            "start_byte": 28643,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_passes": {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 880,
            "start_column": 31104,
            "end_line": 4,
            "end_column": 31684,
            "start_byte": 31104,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._get_teardown_reports": {
            "name": "_pytest.terminal.TerminalReporter._get_teardown_reports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]",
            "start_line": 894,
            "start_column": 31690,
            "end_line": 4,
            "end_column": 31916,
            "start_byte": 31690,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._handle_teardown_sections": {
            "name": "_pytest.terminal.TerminalReporter._handle_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)",
            "start_line": 901,
            "start_column": 31922,
            "end_line": 4,
            "end_column": 32086,
            "start_byte": 31922,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.print_teardown_sections": {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 905,
            "start_column": 32092,
            "end_line": 4,
            "end_column": 32598,
            "start_byte": 32092,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_failures": {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 918,
            "start_column": 32604,
            "end_line": 4,
            "end_column": 33288,
            "start_byte": 32604,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_errors": {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 935,
            "start_column": 33294,
            "end_line": 4,
            "end_column": 33890,
            "start_byte": 33294,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._outrep_summary": {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 950,
            "start_column": 33896,
            "end_line": 4,
            "end_column": 34353,
            "start_byte": 33896,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_stats": {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)",
            "start_line": 963,
            "start_column": 34359,
            "end_line": 4,
            "end_column": 35728,
            "start_byte": 34359,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.short_test_summary": {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 1000,
            "start_column": 35734,
            "end_line": 4,
            "end_column": 38473,
            "start_byte": 35734,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._get_main_color": {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types",
            "start_line": 1069,
            "start_column": 38479,
            "end_line": 4,
            "end_column": 38777,
            "start_byte": 38479,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._determine_main_color": {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color",
            "start_line": 1076,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 39231,
            "start_byte": 38783,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._set_main_color": {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))",
            "start_line": 1088,
            "start_column": 39237,
            "end_line": 4,
            "end_column": 39722,
            "start_byte": 39237,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.build_summary_stats_line": {
            "name": "_pytest.terminal.TerminalReporter.build_summary_stats_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 1097,
            "start_column": 39728,
            "end_line": 4,
            "end_column": 40474,
            "start_byte": 39728,
            "end_byte": 4
        },
        "_pytest.config.Config": {
            "name": "_pytest.config.Config",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :param PytestPluginManager pluginmanager:\n\n    :param InvocationParams invocation_params:\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        \"\"\"tuple of command-line arguments as passed to ``pytest.main()``.\"\"\"\n        plugins = attr.ib()\n        \"\"\"list of extra plugins, might be `None`.\"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"directory where ``pytest.main()`` was invoked from.\"\"\"\n\n    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"access to command line option as attributes.\n\n          :type: argparse.Namespace\"\"\"\n\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"the plugin manager handles plugin registration and hook invocation.\n\n          :type: PytestPluginManager\"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n\n            self.cache = None  # type: Optional[Cache]\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n\n        return self\n\n    def notify_exception(self, excinfo, option=None):\n        if option and getattr(option, \"fulltrace\", False):\n            style = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n                sys.stderr.flush()\n\n    def cwd_relative_nodeid(self, nodeid):\n        # nodeid's are relative to the rootpath, compute relative to cwd\n        if self.invocation_dir != self.rootdir:\n            fullpath = self.rootdir.join(nodeid)\n            nodeid = self.invocation_dir.bestrelpath(fullpath)\n        return nodeid\n\n    @classmethod\n    def fromdictargs(cls, option_dict, args):\n        \"\"\" constructor usable for subprocesses. \"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)\n        return config\n\n    def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):\n                setattr(self.option, opt.dest, opt.default)\n\n    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config):\n        self.pluginmanager._set_initial_conftests(early_config.known_args_namespace)\n\n    def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        r = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self.rootdir, self.inifile, self.inicfg = r\n        self._parser.extra_info[\"rootdir\"] = self.rootdir\n        self._parser.extra_info[\"inifile\"] = self.inifile\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._override_ini = ns.override_ini or ()\n\n    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)\n        _warn_about_missing_assertion(mode)\n\n    def _mark_plugins_for_rewrite(self, hook):\n        \"\"\"\n        Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\n        \"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):\n            hook.mark_rewrite(name)\n\n    def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n\n        return args\n\n    def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n        self.known_args_namespace = ns = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        if self.known_args_namespace.confcutdir is None and self.inifile:\n            confcutdir = py.path.local(self.inifile).dirname\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if ns.help or ns.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                from _pytest.warnings import _issue_warning_captured\n\n                _issue_warning_captured(\n                    PytestConfigWarning(\n                        \"could not load initial conftests: {}\".format(e.path)\n                    ),\n                    self.hook,\n                    stacklevel=2,\n                )\n            else:\n                raise\n\n    def _checkversion(self):\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            # Imported lazily to improve start-up time.\n            from packaging.version import Version\n\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s:%d: requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inicfg.config.path,\n                        self.inicfg.lineof(\"minversion\"),\n                        minver,\n                        pytest.__version__,\n                    )\n                )\n\n    def parse(self, args: List[str], addopts: bool = True) -> None:\n        # parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_dir == self.rootdir:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_dir)]\n            self.args = args\n        except PrintHelp:\n            pass\n\n    def addinivalue_line(self, name, line):\n        \"\"\" add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes the\n        the first line in its value. \"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)\n        x.append(line)  # modifies the cached list inline\n\n    def getini(self, name: str):\n        \"\"\" return configuration value from an :ref:`ini file <inifiles>`. If the\n        specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised. \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)\n            return val\n\n    def _getini(self, name: str) -> Any:\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError:\n            raise ValueError(\"unknown configuration value: {!r}\".format(name))\n        value = self._get_override_ini_value(name)\n        if value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        if type == \"pathlist\":\n            dp = py.path.local(self.inicfg.config.path).dirpath()\n            values = []\n            for relpath in shlex.split(value):\n                values.append(dp.join(relpath, abs=True))\n            return values\n        elif type == \"args\":\n            return shlex.split(value)\n        elif type == \"linelist\":\n            return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n        elif type == \"bool\":\n            return bool(_strtobool(value.strip()))\n        else:\n            assert type is None\n            return value\n\n    def _getconftest_pathlist(self, name, path):\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(name, path)\n        except KeyError:\n            return None\n        modpath = py.path.local(mod.__file__).dirpath()\n        values = []\n        for relroot in relroots:\n            if not isinstance(relroot, py.path.local):\n                relroot = relroot.replace(\"/\", py.path.local.sep)\n                relroot = modpath.join(relroot, abs=True)\n            values.append(relroot)\n        return values\n\n    def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options\n        # always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                )\n            else:\n                if key == name:\n                    value = user_ini_value\n        return value\n\n    def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\" return command line option value.\n\n        :arg name: name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :arg default: default value if no option of that name exists.\n        :arg skip: if True raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(\"no {!r} option found\".format(name))\n            raise ValueError(\"no option named {!r}\".format(name))\n\n    def getvalue(self, name, path=None):\n        \"\"\" (deprecated, use getoption()) \"\"\"\n        return self.getoption(name)\n\n    def getvalueorskip(self, name, path=None):\n        \"\"\" (deprecated, use getoption(skip=True)) \"\"\"\n        return self.getoption(name, skip=True)",
            "start_line": 756,
            "start_column": 25530,
            "end_line": 0,
            "end_column": 42793,
            "start_byte": 25530,
            "end_byte": 0
        },
        "_pytest.config.Config.InvocationParams": {
            "name": "_pytest.config.Config.InvocationParams",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        \"\"\"tuple of command-line arguments as passed to ``pytest.main()``.\"\"\"\n        plugins = attr.ib()\n        \"\"\"list of extra plugins, might be `None`.\"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"directory where ``pytest.main()`` was invoked from.\"\"\"",
            "start_line": 767,
            "start_column": 25819,
            "end_line": 4,
            "end_column": 26589,
            "start_byte": 25819,
            "end_byte": 4
        },
        "_pytest.config.Config.InvocationParams.args": {
            "name": "_pytest.config.Config.InvocationParams.args",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "args = attr.ib(converter=tuple)",
            "start_line": 783,
            "start_column": 26299,
            "end_line": 8,
            "end_column": 26330,
            "start_byte": 26299,
            "end_byte": 8
        },
        "_pytest.config.Config.InvocationParams.plugins": {
            "name": "_pytest.config.Config.InvocationParams.plugins",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "plugins = attr.ib()",
            "start_line": 785,
            "start_column": 26417,
            "end_line": 8,
            "end_column": 26436,
            "start_byte": 26417,
            "end_byte": 8
        },
        "_pytest.config.Config.InvocationParams.dir": {
            "name": "_pytest.config.Config.InvocationParams.dir",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dir = attr.ib(type=Path)",
            "start_line": 787,
            "start_column": 26499,
            "end_line": 8,
            "end_column": 26523,
            "start_byte": 26499,
            "end_byte": 8
        },
        "_pytest.config.Config.__init__": {
            "name": "_pytest.config.Config.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"access to command line option as attributes.\n\n          :type: argparse.Namespace\"\"\"\n\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"the plugin manager handles plugin registration and hook invocation.\n\n          :type: PytestPluginManager\"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n\n            self.cache = None  # type: Optional[Cache]",
            "start_line": 790,
            "start_column": 26595,
            "end_line": 4,
            "end_column": 28375,
            "start_byte": 26595,
            "end_byte": 4
        },
        "_pytest.config.Config.invocation_dir": {
            "name": "_pytest.config.Config.invocation_dir",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))",
            "start_line": 840,
            "start_column": 28381,
            "end_line": 4,
            "end_column": 28519,
            "start_byte": 28381,
            "end_byte": 4
        },
        "_pytest.config.Config.add_cleanup": {
            "name": "_pytest.config.Config.add_cleanup",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)",
            "start_line": 845,
            "start_column": 28525,
            "end_line": 4,
            "end_column": 28725,
            "start_byte": 28525,
            "end_byte": 4
        },
        "_pytest.config.Config._do_configure": {
            "name": "_pytest.config.Config._do_configure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))",
            "start_line": 850,
            "start_column": 28731,
            "end_line": 4,
            "end_column": 28987,
            "start_byte": 28731,
            "end_byte": 4
        },
        "_pytest.config.Config._ensure_unconfigure": {
            "name": "_pytest.config.Config._ensure_unconfigure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()",
            "start_line": 857,
            "start_column": 28993,
            "end_line": 4,
            "end_column": 29286,
            "start_byte": 28993,
            "end_byte": 4
        },
        "_pytest.config.Config.get_terminal_writer": {
            "name": "_pytest.config.Config.get_terminal_writer",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw",
            "start_line": 866,
            "start_column": 29292,
            "end_line": 4,
            "end_column": 29391,
            "start_byte": 29292,
            "end_byte": 4
        },
        "_pytest.config.Config.pytest_cmdline_parse": {
            "name": "_pytest.config.Config.pytest_cmdline_parse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n\n        return self",
            "start_line": 869,
            "start_column": 29397,
            "end_line": 4,
            "end_column": 30240,
            "start_byte": 29397,
            "end_byte": 4
        },
        "_pytest.config.Config.notify_exception": {
            "name": "_pytest.config.Config.notify_exception",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def notify_exception(self, excinfo, option=None):\n        if option and getattr(option, \"fulltrace\", False):\n            style = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n                sys.stderr.flush()",
            "start_line": 893,
            "start_column": 30246,
            "end_line": 4,
            "end_column": 30809,
            "start_byte": 30246,
            "end_byte": 4
        },
        "_pytest.config.Config.cwd_relative_nodeid": {
            "name": "_pytest.config.Config.cwd_relative_nodeid",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def cwd_relative_nodeid(self, nodeid):\n        # nodeid's are relative to the rootpath, compute relative to cwd\n        if self.invocation_dir != self.rootdir:\n            fullpath = self.rootdir.join(nodeid)\n            nodeid = self.invocation_dir.bestrelpath(fullpath)\n        return nodeid",
            "start_line": 907,
            "start_column": 30815,
            "end_line": 4,
            "end_column": 31108,
            "start_byte": 30815,
            "end_byte": 4
        },
        "_pytest.config.Config.fromdictargs": {
            "name": "_pytest.config.Config.fromdictargs",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@classmethod\n    def fromdictargs(cls, option_dict, args):\n        \"\"\" constructor usable for subprocesses. \"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)\n        return config",
            "start_line": 914,
            "start_column": 31114,
            "end_line": 4,
            "end_column": 31469,
            "start_byte": 31114,
            "end_byte": 4
        },
        "_pytest.config.Config._processopt": {
            "name": "_pytest.config.Config._processopt",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):\n                setattr(self.option, opt.dest, opt.default)",
            "start_line": 924,
            "start_column": 31475,
            "end_line": 4,
            "end_column": 31768,
            "start_byte": 31475,
            "end_byte": 4
        },
        "_pytest.config.Config.pytest_load_initial_conftests": {
            "name": "_pytest.config.Config.pytest_load_initial_conftests",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config):\n        self.pluginmanager._set_initial_conftests(early_config.known_args_namespace)",
            "start_line": 932,
            "start_column": 31774,
            "end_line": 4,
            "end_column": 31941,
            "start_byte": 31774,
            "end_byte": 4
        },
        "_pytest.config.Config._initini": {
            "name": "_pytest.config.Config._initini",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        r = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self.rootdir, self.inifile, self.inicfg = r\n        self._parser.extra_info[\"rootdir\"] = self.rootdir\n        self._parser.extra_info[\"inifile\"] = self.inifile\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._override_ini = ns.override_ini or ()",
            "start_line": 936,
            "start_column": 31947,
            "end_line": 4,
            "end_column": 32684,
            "start_byte": 31947,
            "end_byte": 4
        },
        "_pytest.config.Config._consider_importhook": {
            "name": "_pytest.config.Config._consider_importhook",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)\n        _warn_about_missing_assertion(mode)",
            "start_line": 953,
            "start_column": 32690,
            "end_line": 4,
            "end_column": 33458,
            "start_byte": 32690,
            "end_byte": 4
        },
        "_pytest.config.Config._mark_plugins_for_rewrite": {
            "name": "_pytest.config.Config._mark_plugins_for_rewrite",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _mark_plugins_for_rewrite(self, hook):\n        \"\"\"\n        Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\n        \"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):\n            hook.mark_rewrite(name)",
            "start_line": 973,
            "start_column": 33464,
            "end_line": 4,
            "end_column": 34217,
            "start_byte": 33464,
            "end_byte": 4
        },
        "_pytest.config.Config._validate_args": {
            "name": "_pytest.config.Config._validate_args",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n\n        return args",
            "start_line": 995,
            "start_column": 34223,
            "end_line": 4,
            "end_column": 34626,
            "start_byte": 34223,
            "end_byte": 4
        },
        "_pytest.config.Config._preparse": {
            "name": "_pytest.config.Config._preparse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n        self.known_args_namespace = ns = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        if self.known_args_namespace.confcutdir is None and self.inifile:\n            confcutdir = py.path.local(self.inifile).dirname\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if ns.help or ns.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                from _pytest.warnings import _issue_warning_captured\n\n                _issue_warning_captured(\n                    PytestConfigWarning(\n                        \"could not load initial conftests: {}\".format(e.path)\n                    ),\n                    self.hook,\n                    stacklevel=2,\n                )\n            else:\n                raise",
            "start_line": 1007,
            "start_column": 34632,
            "end_line": 4,
            "end_column": 36670,
            "start_byte": 34632,
            "end_byte": 4
        },
        "_pytest.config.Config._checkversion": {
            "name": "_pytest.config.Config._checkversion",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _checkversion(self):\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            # Imported lazily to improve start-up time.\n            from packaging.version import Version\n\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s:%d: requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inicfg.config.path,\n                        self.inicfg.lineof(\"minversion\"),\n                        minver,\n                        pytest.__version__,\n                    )\n                )",
            "start_line": 1055,
            "start_column": 36676,
            "end_line": 4,
            "end_column": 37319,
            "start_byte": 36676,
            "end_byte": 4
        },
        "_pytest.config.Config.parse": {
            "name": "_pytest.config.Config.parse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def parse(self, args: List[str], addopts: bool = True) -> None:\n        # parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_dir == self.rootdir:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_dir)]\n            self.args = args\n        except PrintHelp:\n            pass",
            "start_line": 1074,
            "start_column": 37325,
            "end_line": 4,
            "end_column": 38318,
            "start_byte": 37325,
            "end_byte": 4
        },
        "_pytest.config.Config.addinivalue_line": {
            "name": "_pytest.config.Config.addinivalue_line",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def addinivalue_line(self, name, line):\n        \"\"\" add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes the\n        the first line in its value. \"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)\n        x.append(line)  # modifies the cached list inline",
            "start_line": 1099,
            "start_column": 38324,
            "end_line": 4,
            "end_column": 38676,
            "start_byte": 38324,
            "end_byte": 4
        },
        "_pytest.config.Config.getini": {
            "name": "_pytest.config.Config.getini",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def getini(self, name: str):\n        \"\"\" return configuration value from an :ref:`ini file <inifiles>`. If the\n        specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised. \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)\n            return val",
            "start_line": 1107,
            "start_column": 38682,
            "end_line": 4,
            "end_column": 39156,
            "start_byte": 38682,
            "end_byte": 4
        },
        "_pytest.config.Config._getini": {
            "name": "_pytest.config.Config._getini",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _getini(self, name: str) -> Any:\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError:\n            raise ValueError(\"unknown configuration value: {!r}\".format(name))\n        value = self._get_override_ini_value(name)\n        if value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        if type == \"pathlist\":\n            dp = py.path.local(self.inicfg.config.path).dirpath()\n            values = []\n            for relpath in shlex.split(value):\n                values.append(dp.join(relpath, abs=True))\n            return values\n        elif type == \"args\":\n            return shlex.split(value)\n        elif type == \"linelist\":\n            return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n        elif type == \"bool\":\n            return bool(_strtobool(value.strip()))\n        else:\n            assert type is None\n            return value",
            "start_line": 1118,
            "start_column": 39162,
            "end_line": 4,
            "end_column": 40297,
            "start_byte": 39162,
            "end_byte": 4
        },
        "_pytest.config.Config._getconftest_pathlist": {
            "name": "_pytest.config.Config._getconftest_pathlist",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _getconftest_pathlist(self, name, path):\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(name, path)\n        except KeyError:\n            return None\n        modpath = py.path.local(mod.__file__).dirpath()\n        values = []\n        for relroot in relroots:\n            if not isinstance(relroot, py.path.local):\n                relroot = relroot.replace(\"/\", py.path.local.sep)\n                relroot = modpath.join(relroot, abs=True)\n            values.append(relroot)\n        return values",
            "start_line": 1149,
            "start_column": 40303,
            "end_line": 4,
            "end_column": 40832,
            "start_byte": 40303,
            "end_byte": 4
        },
        "_pytest.config.Config._get_override_ini_value": {
            "name": "_pytest.config.Config._get_override_ini_value",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options\n        # always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                )\n            else:\n                if key == name:\n                    value = user_ini_value\n        return value",
            "start_line": 1163,
            "start_column": 40838,
            "end_line": 4,
            "end_column": 41586,
            "start_byte": 40838,
            "end_byte": 4
        },
        "_pytest.config.Config.getoption": {
            "name": "_pytest.config.Config.getoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\" return command line option value.\n\n        :arg name: name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :arg default: default value if no option of that name exists.\n        :arg skip: if True raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(\"no {!r} option found\".format(name))\n            raise ValueError(\"no option named {!r}\".format(name))",
            "start_line": 1182,
            "start_column": 41592,
            "end_line": 4,
            "end_column": 42519,
            "start_byte": 41592,
            "end_byte": 4
        },
        "_pytest.config.Config.getvalue": {
            "name": "_pytest.config.Config.getvalue",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def getvalue(self, name, path=None):\n        \"\"\" (deprecated, use getoption()) \"\"\"\n        return self.getoption(name)",
            "start_line": 1206,
            "start_column": 42525,
            "end_line": 4,
            "end_column": 42643,
            "start_byte": 42525,
            "end_byte": 4
        },
        "_pytest.config.Config.getvalueorskip": {
            "name": "_pytest.config.Config.getvalueorskip",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def getvalueorskip(self, name, path=None):\n        \"\"\" (deprecated, use getoption(skip=True)) \"\"\"\n        return self.getoption(name, skip=True)",
            "start_line": 1210,
            "start_column": 42649,
            "end_line": 4,
            "end_column": 42793,
            "start_byte": 42649,
            "end_byte": 4
        },
        "_pytest.warning_types.PytestConfigWarning": {
            "name": "_pytest.warning_types.PytestConfigWarning",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "r\n\nimport _pytest._code\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .excep",
            "start_line": 30,
            "start_column": 617,
            "end_line": 0,
            "end_column": 737,
            "start_byte": 617,
            "end_byte": 0
        },
        "_pytest.warning_types.PytestConfigWarning.__module__": {
            "name": "_pytest.warning_types.PytestConfigWarning.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "finitions\nfrom .excep",
            "start_line": 33,
            "start_column": 716,
            "end_line": 4,
            "end_column": 737,
            "start_byte": 716,
            "end_byte": 4
        },
        "_pytest.monkeypatch.MonkeyPatch.chdir": {
            "name": "_pytest.monkeypatch.MonkeyPatch.chdir",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)",
            "start_line": 274,
            "start_column": 9526,
            "end_line": 4,
            "end_column": 9989,
            "start_byte": 9526,
            "end_byte": 4
        },
        "_pytest.monkeypatch.MonkeyPatch.undo": {
            "name": "_pytest.monkeypatch.MonkeyPatch.undo",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 288,
            "start_column": 9995,
            "end_line": 4,
            "end_column": 11401,
            "start_byte": 9995,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._locationline": {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 776,
            "start_column": 27160,
            "end_line": 4,
            "end_column": 27982,
            "start_byte": 27160,
            "end_byte": 4
        },
        "_pytest.nodes.Node._repr_failure_py": {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(\n        self, excinfo: ExceptionInfo[BaseException], style=None,\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 332,
            "start_column": 10806,
            "end_line": 4,
            "end_column": 12496,
            "start_byte": 10806,
            "end_byte": 4
        },
        "_pytest.nodes.Node.repr_failure": {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(\n        self, excinfo, style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 378,
            "start_column": 12502,
            "end_line": 4,
            "end_column": 12843,
            "start_byte": 12502,
            "end_byte": 4
        },
        "_pytest.nodes.get_fslocation_from_item": {
            "name": "_pytest.nodes.get_fslocation_from_item",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_fslocation_from_item(\n    item: \"Item\",\n) -> Tuple[Union[str, py.path.local], Optional[int]]:\n    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n\n    * \"fslocation\": a pair (path, lineno)\n    * \"obj\": a Python object that the item wraps.\n    * \"fspath\": just a path\n\n    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n    \"\"\"\n    try:\n        return item.location[:2]\n    except AttributeError:\n        pass\n    obj = getattr(item, \"obj\", None)\n    if obj is not None:\n        return getfslineno(obj)\n    return getattr(item, \"fspath\", \"unknown location\"), -1",
            "start_line": 389,
            "start_column": 12846,
            "end_line": 0,
            "end_column": 13479,
            "start_byte": 12846,
            "end_byte": 0
        }
    }
}