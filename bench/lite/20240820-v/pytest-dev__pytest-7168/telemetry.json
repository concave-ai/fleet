{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7168",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:34:22.554507",
        "usage": "2316.599130630493 ms"
      },
      "request": {
        "repo_tokens": [
          "summary_passes",
          "Cache",
          "summary_failures",
          "visit_Name",
          "fixturenames",
          "push_format_context",
          "extract_suffixes",
          "extraline",
          "processoption",
          "fnmatch_lines",
          "reprfileloc",
          "_fixturemanager",
          "LogCaptureHandler",
          "append_collect_error",
          "_read_pyc",
          "getpluginversioninfo",
          "typename",
          "cacheprovider",
          "summary_errors",
          "_plugin_nameversions",
          "ids",
          "append_collect_skipped",
          "exit",
          "traceback",
          "_consider_importhook",
          "_validate_args",
          "delattr",
          "CallInfo",
          "write_fspath_result",
          "CLOSE_STDIN",
          "cwd_relative_nodeid",
          "mkdir",
          "getpathnode",
          "obj",
          "pytest_warning_captured",
          "_import_plugin_specs",
          "plugins",
          "_given_basetemp",
          "addSkip",
          "add_global_property",
          "store_mark",
          "resultlog",
          "OutcomeException",
          "parseconfig",
          "_format_args",
          "_ensure_basetemp",
          "_surrounding_parens_on_own_lines",
          "runpytest",
          "builtin_plugins",
          "writer",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "_getnextfixturedef",
          "_get_allow_unicode_flag",
          "check_interactive_exception",
          "id",
          "reprtraceback",
          "getitems",
          "pastebin",
          "capsys",
          "NFPlugin",
          "approx",
          "store",
          "deselect_by_keyword",
          "_early_rewrite_bailout",
          "_get_increasing_order",
          "_collect",
          "safeformat",
          "_determine_show_progress_info",
          "pytest_sessionstart",
          "writeorg",
          "_translate_non_printable",
          "cleanup_numbered_dir",
          "is_rewrite_disabled",
          "_no_match_line",
          "_get_plugin_specs_as_list",
          "_rewrite_test",
          "_assertion_supported",
          "consider_module",
          "Failed",
          "_ensure_supporting_files",
          "pathlib",
          "terminal",
          "PytestPluginManager",
          "buffer",
          "pytest_runtest_call",
          "TEST_OUTCOME",
          "_compilecounter",
          "suspend_global_capture",
          "SysCaptureBinary",
          "get_lines_after",
          "pytest_internalerror",
          "pytestPDB",
          "runtest",
          "getrawcode",
          "__str__",
          "Exit",
          "getlocation",
          "UsageError",
          "SetupState",
          "RE_IMPORT_ERROR_NAME",
          "match",
          "write_ensure_prefix",
          "from_parent",
          "_check_scope",
          "pytester",
          "_inject_setup_method_fixture",
          "_is_capturing",
          "Session",
          "_write_pyc_fp",
          "activate_fixture",
          "setenv",
          "_F",
          "IGNORE_PAM",
          "getexplanation",
          "pytest_report_collectionfinish",
          "classnamefilter",
          "args",
          "assign",
          "get_plugin_manager",
          "MultipleDoctestFailures",
          "showlongtestinfo",
          "ReprLocals",
          "_matchnodes",
          "get_location",
          "_bestrelpath_cache",
          "NOTSET",
          "_ET",
          "excinfo",
          "_ensure_relative_to_basetemp",
          "UnitTestCase",
          "fnmatch_lines_random",
          "LsofFdLeakChecker",
          "CallSpec2",
          "_iter_rewritable_modules",
          "raises",
          "_write_progress_information_filling_space",
          "addFailure",
          "cut",
          "readlines",
          "records",
          "pytest_assertrepr_compare",
          "getcrashentry",
          "is_async_function",
          "_runtest_for_main",
          "pytest_enter_pdb",
          "collect_one_node",
          "Module",
          "consider_conftest",
          "compile",
          "_try_repr_or_str",
          "reprcrash",
          "_config_for_test",
          "notset",
          "runpython_c",
          "_CACHE_PREFIX_VALUES",
          "pytest_pycollect_makeitem",
          "from_item",
          "frame",
          "getargs",
          "pytest_collectstart",
          "_checkversion",
          "set_when",
          "FDCapture",
          "_force_symlink",
          "countoutcomes",
          "scope",
          "CaptureIO",
          "__test__",
          "compile_",
          "_LiveLoggingStreamHandler",
          "_init_runner_class",
          "LFPluginCollWrapper",
          "ApproxBase",
          "_reprcompare",
          "_validate_usepdb_cls",
          "pytest_collection_modifyitems",
          "_is_last_item",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "getfixturevalue",
          "_make_xunit_fixture",
          "isdatacls",
          "_get_main_color",
          "pytest_collect_directory",
          "ExceptionRepr",
          "_getconftestmodules",
          "nofuncargs",
          "re_match_lines_random",
          "_matches_prefix_or_glob_option",
          "get_common_ancestor",
          "pop_format_context",
          "_color_for_type",
          "scope2index",
          "pytest_report_teststatus",
          "ReprFailDoctest",
          "PytestCollectionWarning",
          "_write_entry_lines",
          "NodeMeta",
          "_collectfile",
          "_dump_lines",
          "fix_cache_order",
          "CollectErrorRepr",
          "_for_parametrize",
          "_try_load_conftest",
          "SysModulesSnapshot",
          "fault_handler_stderr_key",
          "SubRequest",
          "_report_to_json",
          "HelpAction",
          "type",
          "pytest_fixture_post_finalizer",
          "python",
          "stop_global_capturing",
          "build_summary_stats_line",
          "visit_Starred",
          "reports",
          "extract_from",
          "mktemp",
          "getreports",
          "initialnames",
          "matchnodes",
          "fileno",
          "families",
          "_format_assertmsg",
          "DEFAULT_RELATIVE_TOLERANCE",
          "isdict",
          "LogCaptureFixture",
          "fail",
          "_warn_already_imported",
          "context",
          "explanation_param",
          "mkpydir",
          "AssertionRewritingHook",
          "getoption",
          "from_call",
          "MoreQuietAction",
          "find_prefixed",
          "out",
          "_PytestWrapper",
          "listextrakeywords",
          "getstatement",
          "template",
          "_AnyPurePath",
          "get_records",
          "maybe_delete_a_numbered_dir",
          "_call_assertion_pass",
          "_getscopeitem",
          "popen",
          "pytest_collect_file",
          "conftest_options",
          "getfixtureclosure",
          "readline",
          "Interrupted",
          "_has_param_ids",
          "_color_for_type_default",
          "TracebackEntry",
          "lines",
          "pytest_runtest_protocol",
          "record_tuples",
          "istrue",
          "_teardown_towards",
          "summary_warnings",
          "_seen",
          "write_captured_output",
          "location",
          "_cachedir",
          "_resolve_arg_value_types",
          "done",
          "MarkMapping",
          "post_mortem",
          "pytest_deselected",
          "__version__",
          "_approx_scalar",
          "NodeKeywords",
          "__setitem__",
          "skip",
          "_add_simple",
          "cached_eval",
          "_is_marked_for_rewrite",
          "for_later",
          "_update_current_test_var",
          "record_xml_attribute",
          "SysCapture",
          "resolve_from_str",
          "PytestAssertRewriteWarning",
          "print_teardown_sections",
          "append_error",
          "_truncate_explanation",
          "funcargnames",
          "_folded_skips",
          "statement",
          "USAGE_ERROR",
          "start_capturing",
          "list",
          "_report_kwargs_from_json",
          "pytest_plugin_registered",
          "line",
          "helpconfig",
          "MarkEvaluator",
          "re_match_lines",
          "_write_content",
          "_ALLOW_MARKERS",
          "close",
          "PytestConfigWarning",
          "format",
          "_do_configure",
          "get_open_files",
          "call_runtest_hook",
          "node_reporter",
          "_get_stderr_fileno",
          "COLLECT_DIRECTORY_HOOK",
          "pytest_generate_tests",
          "_py_ext_re",
          "compat",
          "_getentrysource",
          "doctest",
          "rex_outcome",
          "_tmppath_factory",
          "Function",
          "get_parametrized_fixture_keys",
          "tmpdir_factory",
          "exec_module",
          "PyobjMixin",
          "_getcrashline",
          "ReprExceptionInfo",
          "determine_setup",
          "caplog",
          "UNARY_MAP",
          "visit_Assert",
          "isparseable",
          "pytest_make_collect_report",
          "pytest_keyboard_interrupt",
          "patchsysdict",
          "syspathinsert",
          "scopes",
          "get_user",
          "parse_setoption",
          "BaseReport",
          "warning_record_to_str",
          "_getvaluepath",
          "_main",
          "simple",
          "File",
          "CwdSnapshot",
          "visit_BinOp",
          "Junit",
          "HookRecorder",
          "LineMatcher",
          "pytest_collection",
          "_setoption",
          "pytest_runtestloop",
          "_show_fixtures_per_test",
          "repr_instance",
          "show_test_item",
          "get_source",
          "getsource",
          "parse_known_and_unknown_args",
          "function",
          "_get_runner",
          "cleanup_candidates",
          "makefile",
          "setitem",
          "invocation_dir",
          "ApproxScalar",
          "start",
          "MODULE_NOT_FOUND_ERROR",
          "_handle_teardown_sections",
          "evalxfail_key",
          "capture",
          "add_funcarg_pseudo_fixture_def",
          "_expecting_failure",
          "_get_verbose_word",
          "_create_formatter",
          "set_session",
          "get_lock_path",
          "eval",
          "_version",
          "_start",
          "_typ_map",
          "_ensure_unconfigure",
          "__version_tuple__",
          "chdir",
          "_update_message",
          "_node_location_to_relpath",
          "runner",
          "readouterr",
          "_postmortem_traceback",
          "node",
          "_initini",
          "teardown_exact",
          "get_default_arg_names",
          "format_session_duration",
          "junitxml",
          "illegal_xml_re",
          "cls",
          "xml_key",
          "repr_args",
          "spawn",
          "ReprEntry",
          "_exec_lsof",
          "Instance",
          "__dir__",
          "ReprEntryNative",
          "keywords",
          "STRING_TYPES",
          "_report_unserialization_failure",
          "_outrep_summary",
          "dir",
          "_recursive_debug",
          "module",
          "ReprTraceback",
          "source",
          "_check_if_assertion_pass_impl",
          "resolve_fixture_function",
          "_get_teardown_reports",
          "reprlocals",
          "pytest_report_from_serializable",
          "pop_outerr_to_orig",
          "_log",
          "_showfixtures_main",
          "Class",
          "async_warn_and_skip",
          "wrap_function_to_error_out_if_called_directly",
          "FILLFUNCARGS",
          "DEFAULT_MAX_LINES",
          "LEVELNAME_FMT_REGEX",
          "consider_preparse",
          "to_xml",
          "_pytest",
          "PytestExperimentalApiWarning",
          "__call__",
          "handler",
          "_assertion_pass",
          "_truncate_recursive_traceback",
          "_repr_style",
          "_width_of_current_line",
          "ensure_deletable",
          "applymarker",
          "_find_spec",
          "_PLUGGY_DIR",
          "_pyfuncitem",
          "USAGE_MSG",
          "python_api",
          "_compare_eq_verbose",
          "prepare",
          "_import_pdb_cls",
          "TempdirFactory",
          "get_use_fixtures_for_node",
          "formatrepr",
          "assert_contains",
          "XFailed",
          "summary_stats",
          "_callfinalizers",
          "head_line",
          "idmaker",
          "_inject_setup_class_fixture",
          "set_repr_style",
          "_parsearg",
          "_ANSI_ESCAPE_SEQ",
          "_getindent",
          "iter_markers_with_node",
          "display",
          "Node",
          "_printcollecteditems",
          "pytest_runtest_logstart",
          "add_property",
          "MarkDecorator",
          "maybe_wrap_pytest_function_for_tracing",
          "showlocals",
          "_sys_snapshot",
          "register_assert_rewrite",
          "warning_types",
          "faulthandler",
          "_get_assertion_exprs",
          "directory_arg",
          "Package",
          "consider_env",
          "CHECKER_CLASS",
          "get_fslocation_from_item",
          "_strtobool",
          "rewrite",
          "showheader",
          "_get_override_ini_value",
          "__repr__",
          "getini",
          "_inject_setup_function_fixture",
          "helper",
          "istestfunction",
          "deactivate_fixture",
          "parse",
          "_running_on_ci",
          "_basetemp",
          "FastFilesCompleter",
          "showversion",
          "gethookproxy",
          "indent",
          "__getitem__",
          "get_empty_parameterset_mark",
          "log_outcome",
          "EncodedFile",
          "ihook",
          "prune_dependency_tree",
          "_importtestmodule",
          "_get_checker",
          "_match_lines_random",
          "get_optionflags",
          "LogXML",
          "Skipped",
          "_set_main_color",
          "_compare_eq_set",
          "_should_repr_global_name",
          "pytest_exception_interact",
          "TestReport",
          "_init_pdb",
          "MultiCapture",
          "yield_fixture",
          "_resolve_arg_ids",
          "kwargs",
          "nodeid",
          "TestCaseFunction",
          "get_exconly",
          "get_last_failed_paths",
          "_preparse",
          "_mark_plugins_for_rewrite",
          "UnformattedWarning",
          "visit_Compare",
          "getfslineno",
          "reorder_items",
          "message",
          "__init__",
          "_issue_warning_captured",
          "visit_UnaryOp",
          "_is_numpy_array",
          "normalize_mark_list",
          "CFG_PYTEST_SECTION",
          "when",
          "_yield_comparisons",
          "isatty",
          "catch_warnings_for_item",
          "OK",
          "params",
          "_check_type",
          "ApproxMapping",
          "Source",
          "pytest_addoption",
          "parse_args",
          "pytest",
          "listchain",
          "get",
          "NoCapture",
          "_prepare_content",
          "__all__",
          "listnames",
          "_finalize",
          "duration",
          "PYC_TAIL",
          "append",
          "hasopt",
          "getstatementrange_ast",
          "assert_contains_lines",
          "fill_unfilled",
          "unexpectedsuccess_key",
          "_set_opt_strings",
          "pytest_pycollect_makemodule",
          "_genfunctions",
          "_format",
          "Config",
          "_readline_workaround",
          "pyobj_property",
          "from_current",
          "bin_xml_escape",
          "tmp_path_factory",
          "clear_cache",
          "_getpytestargs",
          "get_closest_marker",
          "NO_TESTS_COLLECTED",
          "longrepr",
          "REPORT_COLLECTING_RESOLUTION",
          "__delitem__",
          "get_real_func",
          "SysPathsSnapshot",
          "_is_mocked",
          "try_makedirs",
          "T",
          "funcargs",
          "get_log_level_for_setting",
          "RaisesContext",
          "_setupstate",
          "matchreport",
          "set_location",
          "essential_plugins",
          "parsefactories",
          "_should_rewrite",
          "prog",
          "update_testcase_duration",
          "DEFAULT_LOG_DATE_FORMAT",
          "linecomp",
          "pytest_collectreport",
          "mark_rewrite",
          "unittest",
          "FILE_OR_DIR",
          "_pformat_dispatch",
          "_getparser",
          "_call_with_optional_argument",
          "generic_visit",
          "_get_auto_indent",
          "_getfailureheadline",
          "skipped",
          "reprentries",
          "CaptureResult",
          "capfdbinary",
          "abspath",
          "register_cleanup_lock_removal",
          "find_spec",
          "EMPTY_BUFFER",
          "rm_rf",
          "NODE_USE_FROM_PARENT",
          "_validate_explicit_parameters",
          "DOCTEST_REPORT_CHOICES",
          "addSuccess",
          "old_mark_config_key",
          "istext",
          "safe_getattr",
          "get_scope_node",
          "addError",
          "AssertionState",
          "_parse_fixture_args",
          "raiseerror",
          "assertoutcome",
          "pytest_pyfunc_call",
          "ishidden",
          "_show_fixture_action",
          "NoMatch",
          "getmodulecol",
          "_getglobals",
          "_perform_collect",
          "getreportopt",
          "DummyRewriteHook",
          "_check_all_skipped",
          "cacheshow",
          "Exception",
          "pytest_configure",
          "copy_example",
          "_check_initialpaths_for_relpath",
          "_recurse",
          "WarningsRecorder",
          "xfail",
          "_getini",
          "_runtest_for",
          "FakeCollectModule",
          "logging",
          "_highlight",
          "warn",
          "_pop_and_teardown",
          "run",
          "hookspec",
          "Item",
          "report_collect",
          "spawn_pytest",
          "messages",
          "name2fixturedefs",
          "fslocation",
          "_state",
          "ExitCode",
          "astcache",
          "addoption",
          "reportinfo",
          "finish_recording",
          "repr",
          "ReprTracebackNative",
          "inline_runsource",
          "fromdictargs",
          "_get_direct_parametrize_args",
          "check_strict_xfail",
          "cmdline",
          "annotated_getattr",
          "get_unpacked_marks",
          "runpytest_inprocess",
          "capstdout",
          "_resume",
          "getfixturedefs",
          "__array_ufunc__",
          "setupplan",
          "strip",
          "start_global_capturing",
          "pytest_leave_pdb",
          "_markers",
          "getparent",
          "_idval",
          "PYTESTER_COPY_EXAMPLE",
          "_with_exception",
          "Traceback",
          "issequence",
          "LFPluginCollSkipfiles",
          "safe_isclass",
          "deselect_by_mark",
          "get_scope_package",
          "scope2props",
          "ensure_reset_dir",
          "TerminalWriter",
          "MarkGenerator",
          "pastebinfile_key",
          "ApproxSequencelike",
          "ExceptionChainRepr",
          "exconly",
          "_assert_expr_to_lineno",
          "pytest_terminal_summary",
          "_fail_on_non_top_pytest_plugins",
          "wrap_session",
          "LOGLEVEL_COLOROPTS",
          "delenv",
          "finish",
          "_in_venv",
          "collect_by_name",
          "repr_traceback",
          "getplugin",
          "showfixtures",
          "config",
          "getinicfg",
          "_get_pdb_wrapper_class",
          "add_cleanup",
          "assert_outcomes",
          "_colorama_workaround",
          "cached_result",
          "builtin",
          "warns",
          "addExpectedFailure",
          "_truncate_by_char_count",
          "record_property",
          "TimeoutExpired",
          "__enter__",
          "_idvalset",
          "_format_repr_exception",
          "newinstance",
          "getparam",
          "_PluggyPlugin",
          "PrintHelp",
          "_makepath",
          "rewrite_asserts",
          "fillfixtures",
          "INTERRUPTED",
          "visit_Call",
          "DoctestTextfile",
          "no_re_match_line",
          "showfspath",
          "recursionindex",
          "_get_number_flag",
          "_CACHE_PREFIX_DIRS",
          "consider_pluginarg",
          "_parse_parametrize_parameters",
          "make_numbered_dir",
          "deprecated_call",
          "filter",
          "_saferepr",
          "_inject_setup_teardown_fixtures",
          "version_tuple",
          "toterminal",
          "global_and_fixture_disabled",
          "repr_excinfo",
          "execute",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "create_module",
          "getfirstlinesource",
          "DEFAULT_MAX_CHARS",
          "inline_genitems",
          "_WithException",
          "DontReadFromInput",
          "BINOP_MAP",
          "write",
          "addsection",
          "pytest_unconfigure",
          "FixtureRequest",
          "findsource",
          "runpytest_subprocess",
          "delitem",
          "param",
          "_getlines",
          "getnode",
          "_PY_DIR",
          "with_args",
          "truncate_locals",
          "make_hook_recorder",
          "_factorytraceback",
          "Store",
          "PdbInvoke",
          "_rget_with_confmod",
          "exprinfo",
          "RunResult",
          "FixtureLookupError",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "TeeCaptureIO",
          "visit_Attribute",
          "_bytes_to_ascii",
          "markname",
          "_getautousenames",
          "_legal_xml_re",
          "InvocationParams",
          "skipping",
          "is_globally_capturing",
          "_non_printable_ascii_translate_table",
          "get_timeout_config_value",
          "PYTEST_TAG",
          "isnosetest",
          "find_suffixes",
          "copy",
          "pytest_addhooks",
          "make_properties_node",
          "CaptureFixture",
          "_py36_windowsconsoleio_workaround",
          "_code",
          "create_cleanup_lock",
          "no_fnmatch_line",
          "map_fixname_class",
          "write_line",
          "pytest_cmdline_main",
          "teardown_all",
          "LOCK_TIMEOUT",
          "_result",
          "_compare_eq_cls",
          "KNOWN_TYPES",
          "sections",
          "assertstate_key",
          "repr_traceback_entry",
          "TERMINALWRITER_WRITER",
          "_write_report_lines_from_hooks",
          "isinitpath",
          "_addfinalizer",
          "fspath",
          "_fail",
          "set_level",
          "PytestArg",
          "_gethookproxy",
          "collect",
          "_validate_if_using_arg_names",
          "is_generator",
          "_names",
          "PyCollector",
          "ReprFileLocation",
          "filename_arg",
          "SEP",
          "getfuncargnames",
          "call_optional",
          "get_statement_startend2",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "get_option_ini",
          "is_capturing",
          "FaultHandlerHooks",
          "from_item_and_call",
          "_striptext",
          "addUnexpectedSuccess",
          "resolve",
          "pytest_report_to_serializable",
          "ResultLog",
          "wrap_pytest_function_for_tracing",
          "pytest_runtest_setup",
          "isset",
          "rex_session_duration",
          "getrepr",
          "FUNCARGNAMES",
          "PytestUnhandledCoroutineWarning",
          "version",
          "reprfuncargs",
          "_getobj",
          "FixtureManager",
          "on_rm_rf_error",
          "PytestCacheWarning",
          "_compare_eq_sequence",
          "scopename2class",
          "JUNIT_XML_DEFAULT_FAMILY",
          "_NodeReporter",
          "teardown_nose",
          "finalize",
          "runpython",
          "setuponly",
          "deprecated",
          "_init_checker_class",
          "resume_global_capture",
          "scopeproperty",
          "REGEX_TYPE",
          "ensure_newline",
          "__take_sys_modules_snapshot",
          "import_plugin",
          "getcalls",
          "is_true",
          "makeini",
          "setup",
          "_parse_lsof_output",
          "getfixturemarker",
          "_argcomplete",
          "pytest_runtest_logfinish",
          "tmp_path",
          "addinivalue_line",
          "addfinalizer",
          "_find_parametrized_scope",
          "_ellipsize",
          "MARK_GEN",
          "write_log_entry",
          "_disable_output_capturing_for_darwin",
          "encoding",
          "setmulti2",
          "__hash__",
          "StoreKey",
          "create_terminal_writer",
          "_iter_all_modules",
          "getvalueorskip",
          "RESULT_LOG",
          "TYPE_CHECKING",
          "filter_traceback",
          "getfailedcollections",
          "Frame",
          "get_cache_dir",
          "for_config",
          "__attrs_post_init__",
          "resume_fixture",
          "_wrapped_pdb_cls",
          "DEFAULT_LOG_FORMAT",
          "parametrize",
          "ReprFuncArgs",
          "_compare_eq_dict",
          "teardown",
          "__ne__",
          "listoutcomes",
          "_get_report_choice",
          "ParsedCall",
          "_locationline",
          "passed",
          "MonkeyPatch",
          "register",
          "exitstatus",
          "FuncFixtureInfo",
          "AssertionRewriter",
          "tbfilter",
          "install_importhook",
          "parseconfigure",
          "_addexcinfo",
          "__array_priority__",
          "saferepr",
          "getmodpath",
          "stopTest",
          "read",
          "__next__",
          "showhelp",
          "_E",
          "getcfg",
          "runitem",
          "pytest_ignore_collect",
          "gethookrecorder",
          "verbosity",
          "longreprtext",
          "mode",
          "append_pass",
          "is_potential_nosetest",
          "perform_collect",
          "FixtureFunctionMarker",
          "_notin_text",
          "__contains__",
          "_prepareconfig",
          "try_cleanup",
          "mangle_test_address",
          "_format_boolop",
          "PytestDeprecationWarning",
          "pytest_cmdline_parse",
          "_assert_start_repr",
          "monkeypatch",
          "_format_action_invocation",
          "set_trace",
          "argnames",
          "_log_text",
          "CollectReport",
          "WarningReport",
          "getimfunc",
          "add_stats",
          "NO_PRINT_LOGS",
          "FunctionDefinition",
          "_warn_about_missing_assertion",
          "genitems",
          "stop_capturing",
          "reorder_items_atscope",
          "section",
          "autouse",
          "_excinfo",
          "_param_ids_from",
          "from_exc_info",
          "parseoutcomes",
          "matchmark",
          "_get_first_non_fixture_func",
          "relline",
          "pytest_sessionfinish",
          "Mark",
          "ischildnode",
          "_diff_text",
          "parse_num",
          "exec_",
          "_should_truncate_item",
          "_eval_scope_callable",
          "main",
          "matchkeyword",
          "setdefault",
          "fail_marker",
          "read_global_capture",
          "FDCaptureBinary",
          "get_terminal_writer",
          "get_sections",
          "hasplugin",
          "_processopt",
          "pytest_doctest_prepare_content",
          "names_closure",
          "_parse_parametrize_args",
          "ApproxNumpy",
          "truncate_if_required",
          "__bool__",
          "_recursive_list_map",
          "style",
          "_get_pos",
          "write_sep",
          "TeeSysCapture",
          "repr_locals",
          "notify_exception",
          "DOCTEST_REPORT_CHOICE_NONE",
          "recwarn",
          "path",
          "_get_continue_on_failure",
          "__eq__",
          "scopemismatch",
          "_W",
          "resume_capturing",
          "nextitem",
          "_traceback",
          "parts",
          "INTERNAL_ERROR",
          "add_report_section",
          "getcall",
          "set_log_path",
          "README_CONTENT",
          "fail_fixturefunc",
          "pop",
          "_validate_ids",
          "lineno",
          "item_capture",
          "_teardown_yield_fixture",
          "_makeitem",
          "isiterable",
          "Testdir",
          "names",
          "_get_active_fixturedef",
          "__len__",
          "call_fixture_func",
          "_get_multicapture",
          "addini",
          "pytest_report_header",
          "_checkargnotcontained",
          "DoctestModule",
          "name",
          "getgroup",
          "_get_allow_bytes_flag",
          "make_numbered_dir_with_cleanup",
          "mark",
          "startTest",
          "CaptureManager",
          "suspend_fixture",
          "suspend_capturing",
          "get_data",
          "add_marker",
          "_capturing_for_request",
          "_format_lines",
          "_addoption",
          "_make_plural",
          "popcall",
          "_warn_incompatibility_with_xunit2",
          "wasvalid",
          "PYC_EXT",
          "tmpdir",
          "nose",
          "tb",
          "FixtureDef",
          "write_docstring",
          "istestclass",
          "session",
          "PdbTrace",
          "_makefile",
          "_io",
          "_compute_fixture_value",
          "_pluginmanager",
          "_importconftest",
          "debugging",
          "PYTEST_COLLECT_MODULE",
          "DropShorterLongHelpFormatter",
          "append_failure",
          "importorskip",
          "testdir",
          "_create",
          "getslaveinfoline",
          "deindent",
          "_setup_cli_logging",
          "pytest_collection_finish",
          "funcnamefilter",
          "pytest_load_initial_conftests",
          "undo",
          "SafeRepr",
          "pytest_cmdline_preparse",
          "_get_progress_information_message",
          "getstatementrange",
          "repr_failure",
          "default_plugins",
          "_istrue",
          "_remove_ansi_escape_sequences",
          "from_config",
          "_schedule_finalizers",
          "setattr",
          "hasinit",
          "_getconftest_pathlist",
          "hookimpl",
          "nodes",
          "_initrequest",
          "_legal_chars",
          "FixtureLookupErrorRepr",
          "check_xfail_no_run",
          "parse_hookimpl_opts",
          "_S",
          "flow_marker",
          "tracebackcutdir",
          "OptionGroup",
          "reset",
          "_testcase",
          "FSCollector",
          "LFPlugin",
          "pytest_assertion_pass",
          "_repr_failure_py",
          "hasnew",
          "format_explanation",
          "_determine_main_color",
          "visit_BoolOp",
          "getitem",
          "cache_dir_from_config",
          "capstderr",
          "get_dirs_from_args",
          "_set_initial_conftests",
          "_split_explanation",
          "_suspend",
          "iter_markers",
          "cache_key",
          "_get_fixturestack",
          "disabled",
          "chain",
          "_write_source",
          "skipped_by_mark_key",
          "capsysbinary",
          "syspath_prepend",
          "getfailures",
          "inline_run",
          "_report_keyboardinterrupt",
          "TerminalRepr",
          "path_matches_patterns",
          "snap",
          "_mk_tmp",
          "FormattedExcinfo",
          "record_testreport",
          "PseudoFixtureDef",
          "warnings",
          "matching_platform",
          "pytest_itemcollected",
          "stepwise",
          "record_testsuite_property",
          "TerminalReporter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "ArgumentError",
          "_legal_ranges",
          "call_and_report",
          "_addoption_instance",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "_REPORTCHARS_DEFAULT",
          "freeze_support",
          "resultlog_key",
          "KeywordMapping",
          "_config",
          "_get_line_with_reprcrash_message",
          "_inject_setup_module_fixture",
          "fnmatch_ex",
          "D",
          "variable",
          "get_real_method",
          "CollectError",
          "Code",
          "_to_json",
          "LoggingPlugin",
          "_done",
          "ColoredLevelFormatter",
          "Collector",
          "merge_family",
          "scopenum_function",
          "suspend",
          "PercentStyleMultiline",
          "restore",
          "_opentestcase",
          "doctest_namespace",
          "append_skipped",
          "WarningsChecker",
          "StepwisePlugin",
          "_setup_fixtures",
          "pytest_runtest_makereport",
          "get_public_names",
          "get_config",
          "LineMatcher_fixture",
          "ParameterSet",
          "DoctestItem",
          "locals",
          "instance",
          "_tryconvertpyarg",
          "_log_cli_enabled",
          "catching_logs",
          "CACHEDIR_TAG_CONTENT",
          "_get_flag_lookup",
          "resume",
          "tolerance",
          "_get_marks",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "__iter__",
          "__getattr__",
          "_enter_pdb",
          "__exit__",
          "co_equal",
          "Metafunc",
          "PytestUnknownMarkWarning",
          "BASE_TYPE",
          "set",
          "entrysep",
          "errisinstance",
          "_patch_unwrap_mock_aware",
          "invalidraise",
          "_getreprcrash",
          "_splitnode",
          "result",
          "pytest_runtest_logreport",
          "Parser",
          "istestfunc",
          "outcomes",
          "iscoroutinefunction",
          "combined_with",
          "fixtures",
          "fullsource",
          "_from_json",
          "LineComp",
          "at_level",
          "__slots__",
          "assertrepr_compare",
          "show_fixtures_per_test",
          "failed",
          "EMPTY_PARAMETERSET_OPTION",
          "_call_reprcompare",
          "MyOptionParser",
          "TempPathFactory",
          "getbasetemp",
          "clear",
          "__module__",
          "FIXTURE_ARGS_ORDER",
          "_add_stats",
          "_teardown_with_finalization",
          "value",
          "error",
          "pytest_make_parametrize_id",
          "ApproxDecimal",
          "putaround",
          "_ascii_escaped_by_config",
          "_prunetraceback",
          "ExceptionInfo",
          "emit",
          "RUNNER_CLASS",
          "pytest_fixture_setup",
          "_match_lines",
          "count_towards_summary",
          "isattrs",
          "Notset",
          "maketxtfile",
          "parse_known_args",
          "makeconftest",
          "derive_importpath",
          "str",
          "_PYTEST_DIR",
          "num_mock_patch_args",
          "stop",
          "exists",
          "runtestprotocol",
          "category",
          "pytestconfig",
          "_fillfixtures",
          "fixture",
          "check_testcase_implements_trial_reporter",
          "ascii_escaped",
          "add_attribute",
          "TESTS_FAILED",
          "_visit_filter",
          "_T",
          "getvalue",
          "_get_global_properties_node",
          "FSHookProxy",
          "_is_setup_py",
          "_matchfactories",
          "freeze_includes",
          "own_mark_names",
          "create_new_paste",
          "text",
          "pytest_runtest_teardown",
          "parse_hookspec_opts",
          "PytestWarning",
          "_trace",
          "__missing__",
          "short_test_summary",
          "_ensure_immutable_ids",
          "ConftestImportFailure",
          "get_direct_param_fixture_func",
          "_saved",
          "Argument",
          "evalcache_key",
          "capfd",
          "makedir",
          "_param_ids_generated",
          "_non_numeric_type_error",
          "cache",
          "_ensure_removed_sysmodule",
          "getfixtureinfo",
          "_check_record_param_type",
          "_in_suspended",
          "assertion",
          "AlwaysDispatchingPrettyPrinter",
          "attrs",
          "_is_doctest",
          "_compare_eq_iterable",
          "python_keywords_allowed_list",
          "makepyfile"
        ]
      },
      "response": {
        "keywords": [
          "SafeRepr",
          "repr_instance",
          "_format_repr_exception",
          "saferepr",
          "repr_args",
          "runtestprotocol",
          "repr_failure",
          "traceback",
          "excinfo",
          "repr",
          "session"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:34:24.871128",
        "usage": "538.79714012146 ms"
      },
      "request": {
        "tokens": [
          "SafeRepr",
          "repr_instance",
          "_format_repr_exception",
          "saferepr",
          "repr_args",
          "runtestprotocol",
          "repr_failure",
          "traceback",
          "excinfo",
          "repr",
          "session"
        ]
      },
      "response": {
        "results": {
          "session": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py",
            "src/_pytest/terminal.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/doctest.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/runner.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/stepwise.py"
          ],
          "traceback": [
            "src/_pytest/unittest.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "excinfo": [
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/capture.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/nodes.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/reports.py",
            "src/_pytest/skipping.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py"
          ],
          "runtestprotocol": [
            "src/_pytest/pytester.py",
            "src/_pytest/runner.py"
          ],
          "repr": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/util.py"
          ],
          "repr_failure": [
            "src/_pytest/reports.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/nodes.py",
            "src/_pytest/doctest.py"
          ],
          "saferepr": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py"
          ],
          "_format_repr_exception": [
            "src/_pytest/_io/saferepr.py"
          ],
          "SafeRepr": [
            "src/_pytest/_io/saferepr.py"
          ],
          "repr_instance": [
            "src/_pytest/_io/saferepr.py"
          ],
          "repr_args": [
            "src/_pytest/_code/code.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:34:25.409949",
        "usage": "5636.936187744141 ms"
      },
      "request": {
        "keyword_search_results": {
          "session": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py",
            "src/_pytest/terminal.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/doctest.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/runner.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/stepwise.py"
          ],
          "traceback": [
            "src/_pytest/unittest.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "excinfo": [
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/capture.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/nodes.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/reports.py",
            "src/_pytest/skipping.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py"
          ],
          "runtestprotocol": [
            "src/_pytest/pytester.py",
            "src/_pytest/runner.py"
          ],
          "repr": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/util.py"
          ],
          "repr_failure": [
            "src/_pytest/reports.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/nodes.py",
            "src/_pytest/doctest.py"
          ],
          "saferepr": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py"
          ],
          "_format_repr_exception": [
            "src/_pytest/_io/saferepr.py"
          ],
          "SafeRepr": [
            "src/_pytest/_io/saferepr.py"
          ],
          "repr_instance": [
            "src/_pytest/_io/saferepr.py"
          ],
          "repr_args": [
            "src/_pytest/_code/code.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is about an 'INTERNALERROR' triggered when an exception occurs in the `__repr__` method of certain classes. The traceback shows the problem arises in `_pytest/_io/saferepr.py` when it tries to handle representations of instances using the `repr` function.\n\nThe relevant keywords and corresponding files are:\n- `repr`: Many files mention `repr`, but `_pytest/_io/saferepr.py` seems highly relevant as it deals directly with safe representations.\n- `saferepr`: The keyword directly suggests `_pytest/_io/saferepr.py`, where the method `saferepr` is called as seen in the traceback.\n- `_format_repr_exception`: This function appears in the traceback and operates within `_pytest/_io/saferepr.py` to handle exceptions while rendering representations.\n- `repr_instance`: Also appears in the traceback and in `_pytest/_io/saferepr.py`, suggesting its role in the issue.\n\nThese suggest that `_pytest/_io/saferepr.py` is directly related to handling representations and likely contains the code causing the issue.\n- `repr_failure`, occurs in `_pytest/python.py` and `_pytest/reports.py`, and is also indicated in the traceback as part of the failure chain.\n\nThus, relevant files include `_pytest/_io/saferepr.py`, `_pytest/python.py`, and `_pytest/reports.py`, as these play a part in how exceptions in `__repr__` are propagated and handled.",
        "file_paths": [
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/python.py",
          "src/_pytest/reports.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:31.046903",
        "usage": "10367.466926574707 ms"
      },
      "request": {
        "file_path": "src/_pytest/_io/saferepr.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1. The issue is an INTERNALERROR when an exception is raised in the __repr__ method. This occurs when pytest tries to display the representation of an object and fails due to the exception.\n1.2. The user provides code that defines a class with __getattribute__ and __repr__ methods that raise exceptions. Accessing an attribute of this class triggers the issue due to the object's __repr__ method raising an exception.\n1.3. The issue is caused because pytest expects to be able to safely call an object's __repr__ method, but if __repr__ raises an exception, pytest doesn't handle it correctly, leading to an INTERNALERROR.\n1.4. The user expects repr() calls to be handled safely by pytest, even if they raise exceptions. The lack of proper exception handling in pytest's representation code leads to this error.\n1.5. _pytest/_io/saferepr.py aims to provide a safe representation of objects, using SafeRepr class which handles exceptions raised during repr calls.\n\n2. Make file evaluation:\n2.1. _pytest/_io/saferepr.py contains functions and classes that manage safe object representation, such as _try_repr_or_str, _format_repr_exception, and SafeRepr.\n2.2. This file contains SafeRepr, which aims to wrap repr calls safely and prevent exceptions from propagating.\n2.3. The function _format_repr_exception constructs a string to represent exceptions during repr safely.\n2.4. The SafeRepr.repr method should catch exceptions raised by repr(x) and return a safe fallback representation.\n2.5. Given the traceback and exception details, this saferepr logic is used when rendering the failure of a test to output readable information, highlighting its relevance to the issue.\n\nSummary:\nThe saferepr.py file is highly relevant as it contains logic to safely handle object representation failures. Its SafeRepr class and related functions are expected to manage exceptions raised in an object's __repr__ method, but something might not be aligning with this expectation based on the reported error. This file could be directly responsible for (or contribute to) the issue when exceptions in repr are not handled as anticipated.\n\nPossible Solutions:\n- Ensure SafeRepr or equivally __repr__ calls handle exceptions as strings that don't cause pytest to raise INTERNALERROR.\n- Add more robust exception-handling mechanisms for pytest's reporting infrastructure to avoid such errors and provide a more graceful fallback.\n\nGiven these points, this file is very likely the root cause or strongly related to the occurrence of the internal error.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "_format_repr_exception",
          "SafeRepr.repr",
          "safeformat",
          "saferepr"
        ],
        "root_cause_symbols": [
          "_format_repr_exception",
          "SafeRepr.repr",
          "safeformat",
          "saferepr"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:41.414385",
        "usage": "11298.509120941162 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/code.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n\n1.1 The user is describing an issue where running a test in pytest causes an INTERNALERROR due to an exception in the `__repr__` method. The `__repr__` method is a special method in Python used to compute the \"official\" string representation of an object. In the provided code, `__repr__` raises an exception (`raise` with no exception, causing a `RuntimeError: No active exception to reraise`).\n\n1.2 The user provides steps to reproduce the issue using a minimal code snippet which raises an exception in the `__getattribute__` and `__repr__` methods of a class `SomeClass`, causing pytest to crash with an INTERNALERROR.\n\n1.3 The issue is caused by the fact that `__repr__` is called when pytest is printing error or debugging information about the exception, but `__repr__` itself raises an unhandled exception leading to a recursion issue within pytest's internal handling functions, thus causing an `INTERNALERROR`.\n\n1.4 The user expects pytest to handle exceptions raised within `__repr__` more gracefully, preventing it from crashing with an `INTERNALERROR`. The problem is with how pytest manages tracebacks and representations of exceptions, especially in cases where they impact the object representation (`__repr__`).\n\n1.6 One potential solution to the issue could be having pytest's exception handling framework provide default behaviors (e.g., fallback representations) when exceptions occur in `__repr__` or related methods, preventing the INTERNALERROR from occurring.\n\n2. Make file evaluation:\n\n2.1 The code in the provided file, `src/_pytest/_code/code.py`, involves exception handling, representation, and manipulation at a low level with classes like `Traceback`, `TracebackEntry`, and `ExceptionInfo`.\n\n2.2 Functions like `getrepr` in `ExceptionInfo`, `repr_traceback` in `FormattedExcinfo`, and `repr_traceback_entry` interact with Python tracebacks and could be responsible for calling `__repr__` when formatting exceptions.\n\n2.3 The file appears relevant as it manages how exceptions and their information (potentially including `__repr__` outputs) are represented.\n\n2.4 Examining relevant symbols shows functions like `repr_excinfo()` in `FormattedExcinfo` and `repr()` in `ExceptionInfo` could be connected to the issue as these manage the representation of exceptions.\n\n2.5 There might be other references to objects from `_pytest/_io/saferepr.py`, indicating that a fall-back safe representation is expected but might fail when encountering exceptions in `__repr__`.\n\n2.6 Considering all of the above, the file likely serves as a root cause for the issue since it includes logic that calls `__repr__` indirectly via exception representation generation, which could lead to an `INTERNALERROR`.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "ExceptionInfo.getrepr",
          "ExceptionInfo.repr",
          "FormattedExcinfo.repr_traceback",
          "FormattedExcinfo.repr_traceback_entry",
          "FormattedExcinfo.repr_excinfo",
          "saferepr"
        ],
        "root_cause_symbols": [
          "ExceptionInfo.getrepr",
          "FormattedExcinfo.repr_excinfo",
          "saferepr"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:52.712911",
        "usage": "6707.613945007324 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "Analyzing the Issue:\n1. The reported issue describes that when an exception is raised within the `__repr__` method of a class, an INTERNALERROR occurs during the pytest session.\n2. The exception in `__repr__` results in an INTERNALERROR when pytest tries to report the failure, because part of reporting involves calling `repr` on certain objects. When `repr` raises, it complicates the error representation.\n3. This likely happens due to repr-related operations being performed during the error handling/reporting process, and no checks or safe handling for repr failures.\n\nEvaluation of `src/_pytest/python.py`:\n- This file includes several classes related to how pytest collects, manages, and runs test functions. \n- Relevant classes involved in the representation and collection of tests could be PyobjMixin, Function, and potentially others dealing with object representations or exception handling in reporting failures.\n- The method `repr_failure` in the `Function` class is of particular interest since it deals with how failures are represented (which might might attempt a `repr` on problematic objects, encountering further exceptions).\n\nConclusion:\n- The root of the issue seems like it could lie in how `repr_failure` in the `Function` class attempts to handle exceptions.\n- Safe handling mechanisms or checks could be added to ensure that even if `__repr__` raises an error, the error handling/reporting performs gracefully.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Function"
        ],
        "root_cause_symbols": [
          "Function.repr_failure"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:59.420546",
        "usage": "7544.442892074585 ms"
      },
      "request": {
        "file_path": "src/_pytest/reports.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the Issue:\n- The issue described involves an INTERNALERROR occurring in pytest when an exception is thrown within the __repr__ method of a class. The error traceback provided suggests an issue with safe representation and repr functions within pytest.\n- The problem arises because when the __repr__ method raises an exception, particularly without any active exception to re-raise (a RuntimeError), pytest isn't able to handle it properly within its reporting mechanisms.\n- The user expects pytest to gracefully handle exceptions occurring within __repr__ methods to prevent an internal error during test execution.\n\n2. Evaluating the File Content:\n- The file 'src/_pytest/reports.py' is responsible for handling reports and long representations (\"longrepr\") within pytest, specifically errors and their representations.\n- Two main classes dealing with report generation include 'BaseReport' and 'TestReport,' which involve handling exceptions and representing them as reports.\n- The method 'from_item_and_call' in 'TestReport' is responsible for producing a report from a test item and its execution call, including managing the outcome and exception info.\n- The '__repr__' method in 'TestReport' and 'CollectReport' classes provides string representation that could link to issues in custom __repr__ methods.\n- The serializing and deserializing of reports processes seem potentially problematic if the objects' __repr__ throws exceptions.\n\n3. Conclusion:\n- The file appears to relate to the issue because it deals with how exceptions and errors are represented for reports. The methods like 'from_item_and_call' and '__repr__' directly correlate with handling the representations possibly truncating or mismanaging exceptions raised within custom object repr methods.\n- The root cause likely relates to how pytest is unable to handle or recover from unexpected exceptions in __repr__, especially if they occur during report creation or string conversion.\n\n4. Relevant Symbols:\n- Particularly relevant methods include 'from_item_and_call', 'BaseReport.__repr__', and 'TestReport.from_item_and_call', which deal with report creation and exception handling within it.\n- Although they might not be the sole cause, they certainly are involved in the process where this issue manifests.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "BaseReport",
          "TestReport",
          "TestReport.from_item_and_call",
          "CollectReport",
          "BaseReport.toterminal",
          "BaseReport.longreprtext"
        ],
        "root_cause_symbols": [
          "BaseReport",
          "TestReport",
          "TestReport.from_item_and_call",
          "CollectReport",
          "BaseReport.toterminal",
          "BaseReport.longreprtext"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:35:06.965026",
        "usage": "189.50772285461426 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/_io/saferepr.py",
            "relevant_symbol_keys": [
              "_format_repr_exception",
              "SafeRepr.repr",
              "safeformat",
              "saferepr"
            ],
            "root_cause_symbol_keys": [
              "_format_repr_exception",
              "SafeRepr.repr",
              "safeformat",
              "saferepr"
            ]
          },
          {
            "file_path": "src/_pytest/_code/code.py",
            "relevant_symbol_keys": [
              "ExceptionInfo.getrepr",
              "ExceptionInfo.repr",
              "FormattedExcinfo.repr_traceback",
              "FormattedExcinfo.repr_traceback_entry",
              "FormattedExcinfo.repr_excinfo",
              "saferepr"
            ],
            "root_cause_symbol_keys": [
              "ExceptionInfo.getrepr",
              "FormattedExcinfo.repr_excinfo",
              "saferepr"
            ]
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "Function"
            ],
            "root_cause_symbol_keys": [
              "Function.repr_failure"
            ]
          },
          {
            "file_path": "src/_pytest/reports.py",
            "relevant_symbol_keys": [
              "BaseReport",
              "TestReport",
              "TestReport.from_item_and_call",
              "CollectReport",
              "BaseReport.toterminal",
              "BaseReport.longreprtext"
            ],
            "root_cause_symbol_keys": [
              "BaseReport",
              "TestReport",
              "TestReport.from_item_and_call",
              "CollectReport",
              "BaseReport.toterminal",
              "BaseReport.longreprtext"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(\n        self, entry: TracebackEntry, excinfo: Optional[ExceptionInfo] = None\n    ) -> \"ReprEntry\":\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []  # type: List[str]\n        style = entry._repr_style if entry._repr_style is not None else self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            reprfileloc = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 768,
            "start_column": 25949,
            "end_line": 4,
            "end_column": 27245,
            "start_byte": 25949,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo: ExceptionInfo) -> \"ReprTraceback\":\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 809,
            "start_column": 27527,
            "end_line": 4,
            "end_column": 28203,
            "start_byte": 27527,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.reprtraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "reprtraceback = attr.ib(type=\"ReprTraceback\")",
            "start_line": 971,
            "start_column": 33932,
            "end_line": 4,
            "end_column": 33977,
            "start_byte": 33932,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.reprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "reprcrash = attr.ib(type=\"ReprFileLocation\")",
            "start_line": 972,
            "start_column": 33982,
            "end_line": 4,
            "end_column": 34026,
            "start_byte": 33982,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
            "start_line": 1010,
            "start_column": 38707,
            "end_line": 0,
            "end_column": 39888,
            "start_byte": 38707,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": "ol)):\n           ",
            "start_line": 1012,
            "start_column": 38761,
            "end_line": 4,
            "end_column": 38778,
            "start_byte": 38761,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "new_ids.append(str(id_value))\n            else:\n           ",
            "start_line": 1013,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 38842,
            "start_byte": 38783,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "msg = \"In {}: ids must be list o",
            "start_line": 1014,
            "start_column": 38847,
            "end_line": 4,
            "end_column": 38879,
            "start_byte": 38847,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ail(\n                    msg.format(func_name, saferepr(id_v",
            "start_line": 1016,
            "start_column": 38957,
            "end_line": 4,
            "end_column": 39017,
            "start_byte": 38957,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": ", idx),\n                    ",
            "start_line": 1017,
            "start_column": 39038,
            "end_line": 4,
            "end_column": 39066,
            "start_byte": 39038,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": "e=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
            "start_line": 1019,
            "start_column": 39072,
            "end_line": 4,
            "end_column": 39888,
            "start_byte": 39072,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1409,
            "start_column": 52332,
            "end_line": 0,
            "end_column": 57213,
            "start_byte": 52332,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1415,
            "start_column": 52532,
            "end_line": 4,
            "end_column": 52554,
            "start_byte": 52532,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname",
            "start_line": 1417,
            "start_column": 52560,
            "end_line": 4,
            "end_column": 54540,
            "start_byte": 52560,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1475,
            "start_column": 54546,
            "end_line": 4,
            "end_column": 54752,
            "start_byte": 54546,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1482,
            "start_column": 54758,
            "end_line": 4,
            "end_column": 54862,
            "start_byte": 54758,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1486,
            "start_column": 54868,
            "end_line": 4,
            "end_column": 54982,
            "start_byte": 54868,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)",
            "start_line": 1491,
            "start_column": 54988,
            "end_line": 4,
            "end_column": 55171,
            "start_byte": 54988,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1498,
            "start_column": 55177,
            "end_line": 4,
            "end_column": 55308,
            "start_byte": 55177,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1503,
            "start_column": 55314,
            "end_line": 4,
            "end_column": 55512,
            "start_byte": 55314,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1509,
            "start_column": 55518,
            "end_line": 4,
            "end_column": 55653,
            "start_byte": 55518,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1513,
            "start_column": 55659,
            "end_line": 4,
            "end_column": 55843,
            "start_byte": 55659,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1519,
            "start_column": 55849,
            "end_line": 4,
            "end_column": 56927,
            "start_byte": 55849,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1548,
            "start_column": 57216,
            "end_line": 0,
            "end_column": 57494,
            "start_byte": 57216,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1554,
            "start_column": 57368,
            "end_line": 4,
            "end_column": 57473,
            "start_byte": 57368,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1557,
            "start_column": 57479,
            "end_line": 4,
            "end_column": 57494,
            "start_byte": 57479,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "ault=\"prepend\",\n        choices=[\"prepend\", \"append\"],\n        dest=\"importmode\",\n        help=\"prepend/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
            "start_line": 109,
            "start_column": 3686,
            "end_line": 0,
            "end_column": 8712,
            "start_byte": 3686,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "end\", \"append\"],\n",
            "start_line": 110,
            "start_column": 3724,
            "end_line": 4,
            "end_column": 3741,
            "start_byte": 3724,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "   dest=\"import",
            "start_line": 111,
            "start_column": 3746,
            "end_line": 4,
            "end_column": 3761,
            "start_byte": 3746,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": ",\n        help=\"",
            "start_line": 112,
            "start_column": 3766,
            "end_line": 4,
            "end_column": 3782,
            "start_byte": 3766,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "d/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_g",
            "start_line": 114,
            "start_column": 3788,
            "end_line": 4,
            "end_column": 4111,
            "start_byte": 3788,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "e_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*mar",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "gs, **marker.kwargs, _param_mark=marker)  #",
            "start_line": 129,
            "start_column": 4326,
            "end_line": 4,
            "end_column": 4369,
            "start_byte": 4326,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip",
            "start_line": 132,
            "start_column": 4375,
            "end_line": 4,
            "end_column": 5757,
            "start_byte": 4375,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn",
            "start_line": 165,
            "start_column": 5763,
            "end_line": 4,
            "end_column": 5995,
            "start_byte": 5763,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "kip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: f",
            "start_line": 173,
            "start_column": 6001,
            "end_line": 4,
            "end_column": 6081,
            "start_byte": 6001,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "s[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.node",
            "start_line": 176,
            "start_column": 6087,
            "end_line": 4,
            "end_column": 6289,
            "start_byte": 6087,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "  return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns",
            "start_line": 183,
            "start_column": 6295,
            "end_line": 4,
            "end_column": 6478,
            "start_byte": 6295,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "            path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                ",
            "start_line": 189,
            "start_column": 6484,
            "end_line": 4,
            "end_column": 6588,
            "start_byte": 6484,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        ihook = parent.session.gethookproxy",
            "start_line": 192,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6638,
            "start_byte": 6594,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        return ihook.pytest_pycollect_mak",
            "start_line": 195,
            "start_column": 6644,
            "end_line": 4,
            "end_column": 6686,
            "start_byte": 6644,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "e(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(h",
            "start_line": 198,
            "start_column": 6692,
            "end_line": 4,
            "end_column": 7140,
            "start_byte": 6692,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "pper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n        ",
            "start_line": 207,
            "start_column": 7146,
            "end_line": 4,
            "end_column": 8441,
            "start_byte": 7146,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "  reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
            "start_line": 234,
            "start_column": 8447,
            "end_line": 4,
            "end_column": 8712,
            "start_byte": 8447,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def safeformat(obj: Any) -> str:\n    \"\"\"return a pretty printed string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info.\n    \"\"\"\n    try:\n        return pprint.pformat(obj)\n    except Exception as exc:\n        return _format_repr_exception(exc, obj)",
            "start_line": 63,
            "start_column": 1751,
            "end_line": 0,
            "end_column": 2074,
            "start_byte": 1751,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 577,
            "start_column": 19023,
            "end_line": 4,
            "end_column": 20900,
            "start_byte": 19023,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 868,
            "start_column": 30141,
            "end_line": 4,
            "end_column": 32060,
            "start_byte": 30141,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1540,
            "start_column": 56933,
            "end_line": 4,
            "end_column": 57213,
            "start_byte": 56933,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class BaseReport:\n    when = None  # type: Optional[str]\n    location = None  # type: Optional[Tuple[str, Optional[int], str]]\n    longrepr = None\n    sections = []  # type: List[Tuple[str, str]]\n    nodeid = None  # type: str\n\n    def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)\n\n    if TYPE_CHECKING:\n        # Can have arbitrary fields given to __init__().\n        def __getattr__(self, key: str) -> Any:\n            raise NotImplementedError()\n\n    def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")\n\n    def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content\n\n    @property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()\n\n    @property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )\n\n    @property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )\n\n    @property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )\n\n    passed = property(lambda x: x.outcome == \"passed\")\n    failed = property(lambda x: x.outcome == \"failed\")\n    skipped = property(lambda x: x.outcome == \"skipped\")\n\n    @property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]\n\n    @property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True\n\n    @property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain\n\n    def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose\n\n    def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)\n\n    @classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
            "start_line": 40,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 5629,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.BaseReport.when",
            "file_path": "src/_pytest/reports.py",
            "file_content": "when = None",
            "start_line": 41,
            "start_column": 1190,
            "end_line": 4,
            "end_column": 1201,
            "start_byte": 1190,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.location",
            "file_path": "src/_pytest/reports.py",
            "file_content": "location = None",
            "start_line": 42,
            "start_column": 1229,
            "end_line": 4,
            "end_column": 1244,
            "start_byte": 1229,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.longrepr",
            "file_path": "src/_pytest/reports.py",
            "file_content": "longrepr = None",
            "start_line": 43,
            "start_column": 1299,
            "end_line": 4,
            "end_column": 1314,
            "start_byte": 1299,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.sections",
            "file_path": "src/_pytest/reports.py",
            "file_content": "sections = []",
            "start_line": 44,
            "start_column": 1319,
            "end_line": 4,
            "end_column": 1332,
            "start_byte": 1319,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.nodeid",
            "file_path": "src/_pytest/reports.py",
            "file_content": "nodeid = None",
            "start_line": 45,
            "start_column": 1368,
            "end_line": 4,
            "end_column": 1381,
            "start_byte": 1368,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)",
            "start_line": 47,
            "start_column": 1400,
            "end_line": 4,
            "end_column": 1471,
            "start_byte": 1400,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.toterminal",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")",
            "start_line": 55,
            "start_column": 1645,
            "end_line": 4,
            "end_column": 2083,
            "start_byte": 1645,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.get_sections",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content",
            "start_line": 71,
            "start_column": 2089,
            "end_line": 4,
            "end_column": 2242,
            "start_byte": 2089,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.longreprtext",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()",
            "start_line": 76,
            "start_column": 2248,
            "end_line": 4,
            "end_column": 2600,
            "start_byte": 2248,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.caplog",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )",
            "start_line": 90,
            "start_column": 2606,
            "end_line": 4,
            "end_column": 2861,
            "start_byte": 2606,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.capstdout",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )",
            "start_line": 100,
            "start_column": 2867,
            "end_line": 4,
            "end_column": 3129,
            "start_byte": 2867,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.capstderr",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )",
            "start_line": 110,
            "start_column": 3135,
            "end_line": 4,
            "end_column": 3397,
            "start_byte": 3135,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.passed",
            "file_path": "src/_pytest/reports.py",
            "file_content": "passed = property(lambda x: x.outcome == \"passed\")",
            "start_line": 120,
            "start_column": 3403,
            "end_line": 4,
            "end_column": 3453,
            "start_byte": 3403,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.failed",
            "file_path": "src/_pytest/reports.py",
            "file_content": "failed = property(lambda x: x.outcome == \"failed\")",
            "start_line": 121,
            "start_column": 3458,
            "end_line": 4,
            "end_column": 3508,
            "start_byte": 3458,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.skipped",
            "file_path": "src/_pytest/reports.py",
            "file_content": "skipped = property(lambda x: x.outcome == \"skipped\")",
            "start_line": 122,
            "start_column": 3513,
            "end_line": 4,
            "end_column": 3565,
            "start_byte": 3513,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.fspath",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]",
            "start_line": 124,
            "start_column": 3571,
            "end_line": 4,
            "end_column": 3651,
            "start_byte": 3571,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.count_towards_summary",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True",
            "start_line": 128,
            "start_column": 3657,
            "end_line": 4,
            "end_column": 4070,
            "start_byte": 3657,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.head_line",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain",
            "start_line": 143,
            "start_column": 4076,
            "end_line": 4,
            "end_column": 4676,
            "start_byte": 4076,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._get_verbose_word",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose",
            "start_line": 165,
            "start_column": 4682,
            "end_line": 4,
            "end_column": 4865,
            "start_byte": 4682,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)",
            "start_line": 171,
            "start_column": 4871,
            "end_line": 4,
            "end_column": 5174,
            "start_byte": 4871,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
            "start_line": 182,
            "start_column": 5180,
            "end_line": 4,
            "end_column": 5629,
            "start_byte": 5180,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 208,
            "start_column": 6154,
            "end_line": 0,
            "end_column": 9677,
            "start_byte": 6154,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 213,
            "start_column": 6289,
            "end_line": 4,
            "end_column": 6305,
            "start_byte": 6289,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 215,
            "start_column": 6311,
            "end_line": 4,
            "end_column": 7977,
            "start_byte": 6311,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 264,
            "start_column": 7983,
            "end_line": 4,
            "end_column": 8144,
            "start_byte": 7983,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 269,
            "start_column": 8150,
            "end_line": 4,
            "end_column": 9677,
            "start_byte": 8150,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n        return (self.fspath, None, self.fspath)\n\n    def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
            "start_line": 313,
            "start_column": 9680,
            "end_line": 0,
            "end_column": 10307,
            "start_byte": 9680,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.CollectReport.when",
            "file_path": "src/_pytest/reports.py",
            "file_content": "when = \"collect\"",
            "start_line": 314,
            "start_column": 9717,
            "end_line": 4,
            "end_column": 9733,
            "start_byte": 9717,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)",
            "start_line": 316,
            "start_column": 9739,
            "end_line": 4,
            "end_column": 10057,
            "start_byte": 9739,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport.location",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def location(self):\n        return (self.fspath, None, self.fspath)",
            "start_line": 326,
            "start_column": 10063,
            "end_line": 4,
            "end_column": 10144,
            "start_byte": 10063,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
            "start_line": 330,
            "start_column": 10150,
            "end_line": 4,
            "end_column": 10307,
            "start_byte": 10150,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:35:07.154541",
        "usage": "18164.016008377075 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(\n        self, entry: TracebackEntry, excinfo: Optional[ExceptionInfo] = None\n    ) -> \"ReprEntry\":\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []  # type: List[str]\n        style = entry._repr_style if entry._repr_style is not None else self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            reprfileloc = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 768,
            "start_column": 25949,
            "end_line": 4,
            "end_column": 27245,
            "start_byte": 25949,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo: ExceptionInfo) -> \"ReprTraceback\":\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 809,
            "start_column": 27527,
            "end_line": 4,
            "end_column": 28203,
            "start_byte": 27527,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.reprtraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "reprtraceback = attr.ib(type=\"ReprTraceback\")",
            "start_line": 971,
            "start_column": 33932,
            "end_line": 4,
            "end_column": 33977,
            "start_byte": 33932,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.reprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "reprcrash = attr.ib(type=\"ReprFileLocation\")",
            "start_line": 972,
            "start_column": 33982,
            "end_line": 4,
            "end_column": 34026,
            "start_byte": 33982,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
            "start_line": 1010,
            "start_column": 38707,
            "end_line": 0,
            "end_column": 39888,
            "start_byte": 38707,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": "ol)):\n           ",
            "start_line": 1012,
            "start_column": 38761,
            "end_line": 4,
            "end_column": 38778,
            "start_byte": 38761,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "new_ids.append(str(id_value))\n            else:\n           ",
            "start_line": 1013,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 38842,
            "start_byte": 38783,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "msg = \"In {}: ids must be list o",
            "start_line": 1014,
            "start_column": 38847,
            "end_line": 4,
            "end_column": 38879,
            "start_byte": 38847,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ail(\n                    msg.format(func_name, saferepr(id_v",
            "start_line": 1016,
            "start_column": 38957,
            "end_line": 4,
            "end_column": 39017,
            "start_byte": 38957,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": ", idx),\n                    ",
            "start_line": 1017,
            "start_column": 39038,
            "end_line": 4,
            "end_column": 39066,
            "start_byte": 39038,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": "e=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
            "start_line": 1019,
            "start_column": 39072,
            "end_line": 4,
            "end_column": 39888,
            "start_byte": 39072,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1409,
            "start_column": 52332,
            "end_line": 0,
            "end_column": 57213,
            "start_byte": 52332,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1415,
            "start_column": 52532,
            "end_line": 4,
            "end_column": 52554,
            "start_byte": 52532,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname",
            "start_line": 1417,
            "start_column": 52560,
            "end_line": 4,
            "end_column": 54540,
            "start_byte": 52560,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1475,
            "start_column": 54546,
            "end_line": 4,
            "end_column": 54752,
            "start_byte": 54546,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1482,
            "start_column": 54758,
            "end_line": 4,
            "end_column": 54862,
            "start_byte": 54758,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1486,
            "start_column": 54868,
            "end_line": 4,
            "end_column": 54982,
            "start_byte": 54868,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)",
            "start_line": 1491,
            "start_column": 54988,
            "end_line": 4,
            "end_column": 55171,
            "start_byte": 54988,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1498,
            "start_column": 55177,
            "end_line": 4,
            "end_column": 55308,
            "start_byte": 55177,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1503,
            "start_column": 55314,
            "end_line": 4,
            "end_column": 55512,
            "start_byte": 55314,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1509,
            "start_column": 55518,
            "end_line": 4,
            "end_column": 55653,
            "start_byte": 55518,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1513,
            "start_column": 55659,
            "end_line": 4,
            "end_column": 55843,
            "start_byte": 55659,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1519,
            "start_column": 55849,
            "end_line": 4,
            "end_column": 56927,
            "start_byte": 55849,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1548,
            "start_column": 57216,
            "end_line": 0,
            "end_column": 57494,
            "start_byte": 57216,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1554,
            "start_column": 57368,
            "end_line": 4,
            "end_column": 57473,
            "start_byte": 57368,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1557,
            "start_column": 57479,
            "end_line": 4,
            "end_column": 57494,
            "start_byte": 57479,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "ault=\"prepend\",\n        choices=[\"prepend\", \"append\"],\n        dest=\"importmode\",\n        help=\"prepend/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
            "start_line": 109,
            "start_column": 3686,
            "end_line": 0,
            "end_column": 8712,
            "start_byte": 3686,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "end\", \"append\"],\n",
            "start_line": 110,
            "start_column": 3724,
            "end_line": 4,
            "end_column": 3741,
            "start_byte": 3724,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "   dest=\"import",
            "start_line": 111,
            "start_column": 3746,
            "end_line": 4,
            "end_column": 3761,
            "start_byte": 3746,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": ",\n        help=\"",
            "start_line": 112,
            "start_column": 3766,
            "end_line": 4,
            "end_column": 3782,
            "start_byte": 3766,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "d/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_g",
            "start_line": 114,
            "start_column": 3788,
            "end_line": 4,
            "end_column": 4111,
            "start_byte": 3788,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "e_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*mar",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "gs, **marker.kwargs, _param_mark=marker)  #",
            "start_line": 129,
            "start_column": 4326,
            "end_line": 4,
            "end_column": 4369,
            "start_byte": 4326,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip",
            "start_line": 132,
            "start_column": 4375,
            "end_line": 4,
            "end_column": 5757,
            "start_byte": 4375,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn",
            "start_line": 165,
            "start_column": 5763,
            "end_line": 4,
            "end_column": 5995,
            "start_byte": 5763,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "kip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: f",
            "start_line": 173,
            "start_column": 6001,
            "end_line": 4,
            "end_column": 6081,
            "start_byte": 6001,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "s[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.node",
            "start_line": 176,
            "start_column": 6087,
            "end_line": 4,
            "end_column": 6289,
            "start_byte": 6087,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "  return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns",
            "start_line": 183,
            "start_column": 6295,
            "end_line": 4,
            "end_column": 6478,
            "start_byte": 6295,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "            path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                ",
            "start_line": 189,
            "start_column": 6484,
            "end_line": 4,
            "end_column": 6588,
            "start_byte": 6484,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        ihook = parent.session.gethookproxy",
            "start_line": 192,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6638,
            "start_byte": 6594,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        return ihook.pytest_pycollect_mak",
            "start_line": 195,
            "start_column": 6644,
            "end_line": 4,
            "end_column": 6686,
            "start_byte": 6644,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "e(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(h",
            "start_line": 198,
            "start_column": 6692,
            "end_line": 4,
            "end_column": 7140,
            "start_byte": 6692,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "pper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n        ",
            "start_line": 207,
            "start_column": 7146,
            "end_line": 4,
            "end_column": 8441,
            "start_byte": 7146,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "  reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
            "start_line": 234,
            "start_column": 8447,
            "end_line": 4,
            "end_column": 8712,
            "start_byte": 8447,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def safeformat(obj: Any) -> str:\n    \"\"\"return a pretty printed string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info.\n    \"\"\"\n    try:\n        return pprint.pformat(obj)\n    except Exception as exc:\n        return _format_repr_exception(exc, obj)",
            "start_line": 63,
            "start_column": 1751,
            "end_line": 0,
            "end_column": 2074,
            "start_byte": 1751,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 577,
            "start_column": 19023,
            "end_line": 4,
            "end_column": 20900,
            "start_byte": 19023,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 868,
            "start_column": 30141,
            "end_line": 4,
            "end_column": 32060,
            "start_byte": 30141,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1540,
            "start_column": 56933,
            "end_line": 4,
            "end_column": 57213,
            "start_byte": 56933,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class BaseReport:\n    when = None  # type: Optional[str]\n    location = None  # type: Optional[Tuple[str, Optional[int], str]]\n    longrepr = None\n    sections = []  # type: List[Tuple[str, str]]\n    nodeid = None  # type: str\n\n    def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)\n\n    if TYPE_CHECKING:\n        # Can have arbitrary fields given to __init__().\n        def __getattr__(self, key: str) -> Any:\n            raise NotImplementedError()\n\n    def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")\n\n    def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content\n\n    @property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()\n\n    @property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )\n\n    @property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )\n\n    @property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )\n\n    passed = property(lambda x: x.outcome == \"passed\")\n    failed = property(lambda x: x.outcome == \"failed\")\n    skipped = property(lambda x: x.outcome == \"skipped\")\n\n    @property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]\n\n    @property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True\n\n    @property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain\n\n    def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose\n\n    def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)\n\n    @classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
            "start_line": 40,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 5629,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.BaseReport.when",
            "file_path": "src/_pytest/reports.py",
            "file_content": "when = None",
            "start_line": 41,
            "start_column": 1190,
            "end_line": 4,
            "end_column": 1201,
            "start_byte": 1190,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.location",
            "file_path": "src/_pytest/reports.py",
            "file_content": "location = None",
            "start_line": 42,
            "start_column": 1229,
            "end_line": 4,
            "end_column": 1244,
            "start_byte": 1229,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.longrepr",
            "file_path": "src/_pytest/reports.py",
            "file_content": "longrepr = None",
            "start_line": 43,
            "start_column": 1299,
            "end_line": 4,
            "end_column": 1314,
            "start_byte": 1299,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.sections",
            "file_path": "src/_pytest/reports.py",
            "file_content": "sections = []",
            "start_line": 44,
            "start_column": 1319,
            "end_line": 4,
            "end_column": 1332,
            "start_byte": 1319,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.nodeid",
            "file_path": "src/_pytest/reports.py",
            "file_content": "nodeid = None",
            "start_line": 45,
            "start_column": 1368,
            "end_line": 4,
            "end_column": 1381,
            "start_byte": 1368,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)",
            "start_line": 47,
            "start_column": 1400,
            "end_line": 4,
            "end_column": 1471,
            "start_byte": 1400,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.toterminal",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")",
            "start_line": 55,
            "start_column": 1645,
            "end_line": 4,
            "end_column": 2083,
            "start_byte": 1645,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.get_sections",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content",
            "start_line": 71,
            "start_column": 2089,
            "end_line": 4,
            "end_column": 2242,
            "start_byte": 2089,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.longreprtext",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()",
            "start_line": 76,
            "start_column": 2248,
            "end_line": 4,
            "end_column": 2600,
            "start_byte": 2248,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.caplog",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )",
            "start_line": 90,
            "start_column": 2606,
            "end_line": 4,
            "end_column": 2861,
            "start_byte": 2606,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.capstdout",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )",
            "start_line": 100,
            "start_column": 2867,
            "end_line": 4,
            "end_column": 3129,
            "start_byte": 2867,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.capstderr",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )",
            "start_line": 110,
            "start_column": 3135,
            "end_line": 4,
            "end_column": 3397,
            "start_byte": 3135,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.passed",
            "file_path": "src/_pytest/reports.py",
            "file_content": "passed = property(lambda x: x.outcome == \"passed\")",
            "start_line": 120,
            "start_column": 3403,
            "end_line": 4,
            "end_column": 3453,
            "start_byte": 3403,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.failed",
            "file_path": "src/_pytest/reports.py",
            "file_content": "failed = property(lambda x: x.outcome == \"failed\")",
            "start_line": 121,
            "start_column": 3458,
            "end_line": 4,
            "end_column": 3508,
            "start_byte": 3458,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.skipped",
            "file_path": "src/_pytest/reports.py",
            "file_content": "skipped = property(lambda x: x.outcome == \"skipped\")",
            "start_line": 122,
            "start_column": 3513,
            "end_line": 4,
            "end_column": 3565,
            "start_byte": 3513,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.fspath",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]",
            "start_line": 124,
            "start_column": 3571,
            "end_line": 4,
            "end_column": 3651,
            "start_byte": 3571,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.count_towards_summary",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True",
            "start_line": 128,
            "start_column": 3657,
            "end_line": 4,
            "end_column": 4070,
            "start_byte": 3657,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport.head_line",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain",
            "start_line": 143,
            "start_column": 4076,
            "end_line": 4,
            "end_column": 4676,
            "start_byte": 4076,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._get_verbose_word",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose",
            "start_line": 165,
            "start_column": 4682,
            "end_line": 4,
            "end_column": 4865,
            "start_byte": 4682,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)",
            "start_line": 171,
            "start_column": 4871,
            "end_line": 4,
            "end_column": 5174,
            "start_byte": 4871,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
            "start_line": 182,
            "start_column": 5180,
            "end_line": 4,
            "end_column": 5629,
            "start_byte": 5180,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 208,
            "start_column": 6154,
            "end_line": 0,
            "end_column": 9677,
            "start_byte": 6154,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 213,
            "start_column": 6289,
            "end_line": 4,
            "end_column": 6305,
            "start_byte": 6289,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 215,
            "start_column": 6311,
            "end_line": 4,
            "end_column": 7977,
            "start_byte": 6311,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 264,
            "start_column": 7983,
            "end_line": 4,
            "end_column": 8144,
            "start_byte": 7983,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 269,
            "start_column": 8150,
            "end_line": 4,
            "end_column": 9677,
            "start_byte": 8150,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n        return (self.fspath, None, self.fspath)\n\n    def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
            "start_line": 313,
            "start_column": 9680,
            "end_line": 0,
            "end_column": 10307,
            "start_byte": 9680,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.CollectReport.when",
            "file_path": "src/_pytest/reports.py",
            "file_content": "when = \"collect\"",
            "start_line": 314,
            "start_column": 9717,
            "end_line": 4,
            "end_column": 9733,
            "start_byte": 9717,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)",
            "start_line": 316,
            "start_column": 9739,
            "end_line": 4,
            "end_column": 10057,
            "start_byte": 9739,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport.location",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def location(self):\n        return (self.fspath, None, self.fspath)",
            "start_line": 326,
            "start_column": 10063,
            "end_line": 4,
            "end_column": 10144,
            "start_byte": 10063,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.CollectReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
            "start_line": 330,
            "start_column": 10150,
            "end_line": 4,
            "end_column": 10307,
            "start_byte": 10150,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The user describes an INTERNALERROR occurring in pytest when running a specific test. This issue seems to stem from a custom __repr__ method that raises an exception, which is subsequently causing pytest's internal error handling to fail.\n2. The issue was caused by an exception being raised in the __repr__ function defined in a test class used in pytest. This is significant because pytest uses repr() internally to generate error messages and debugging information. When there is an error in a __repr__ method, it might lead to such internal errors in testing frameworks.\n3. The expected result should be that even if __repr__ raises an exception, pytest should handle this gracefully without crashing.\n4. If not provided clearly by the user, the expectation is pytest manages such cases without running into internal errors.\n5. To fix the issue, the internal error handling of Pytest should be improved to manage exceptions raised by __repr__ methods more gracefully, possibly defaulting to a simpler or safer representation.\n\nLooking at the code provided, it seems that the methods involved in the string representation of exceptions in pytest are malfunctioning when __repr__ in user code raises an error. The _format_repr_exception and other related methods in the saferepr.py file of pytest are likely involved here. These methods attempt to catch exceptions for safe representation but might not be handling some edge cases properly.",
        "symbols": [
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This function formats exceptions that occur during representation, and it seems to be directly relevant because it should catch any exception raised during a __repr__ call."
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This method overrides the default repr method to provide a safe string representation. It's related because it should handle exceptions in __repr__."
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This is another method providing safe instance representation, catching exceptions from __repr__ specifically."
          },
          {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This function is aimed at safely formatting objects and utilizes _format_repr_exception, which is involved in scenarios causing this issue."
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This wrapper around repr uses SafeRepr which manages exceptions from object representations, associated with exceptions during repr calls."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "_pytest._io._format_repr_exception: This function handles exceptions raised in the __repr__ method, formats them and ensures that no further unhandled exceptions cause crashes. It seems crucial in solving the problem where an __repr__ causing an exception leads to an internal error in pytest.",
          "_pytest._io.SafeRepr.repr: The repr function here overrides the default to add a try-except block around the representation call, mitigating issues caused if __repr__ throws an error.",
          "_pytest._io.SafeRepr.repr_instance: Similar to the 'repr', this method deals specifically with instances and should safely cover cases where __repr__ could go wrong, likely involved in or affected by the issue in question.",
          "_pytest._io.safeformat: This method aims to provide a 'pretty' print of objects, integrating _format_repr_exception to handle cases where __repr__ fails. Relevant for handling these exceptions gracefully.",
          "_pytest._io.saferepr: Utilizes SafeRepr to return a safe string representation, catching exceptions from __repr__ methods."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:35:25.318584",
        "usage": "4.300117492675781 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_traceback_entry(\n        self, entry: TracebackEntry, excinfo: Optional[ExceptionInfo] = None\n    ) -> \"ReprEntry\":\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []  # type: List[str]\n        style = entry._repr_style if entry._repr_style is not None else self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            reprfileloc = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
              "start_line": 768,
              "start_column": 25949,
              "end_line": 4,
              "end_column": 27245,
              "start_byte": 25949,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_traceback(self, excinfo: ExceptionInfo) -> \"ReprTraceback\":\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
              "start_line": 809,
              "start_column": 27527,
              "end_line": 4,
              "end_column": 28203,
              "start_byte": 27527,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.reprtraceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "reprtraceback = attr.ib(type=\"ReprTraceback\")",
              "start_line": 971,
              "start_column": 33932,
              "end_line": 4,
              "end_column": 33977,
              "start_byte": 33932,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.reprcrash",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "reprcrash = attr.ib(type=\"ReprFileLocation\")",
              "start_line": 972,
              "start_column": 33982,
              "end_line": 4,
              "end_column": 34026,
              "start_byte": 33982,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker",
              "file_path": "src/_pytest/python.py",
              "file_content": "\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
              "start_line": 1010,
              "start_column": 38707,
              "end_line": 0,
              "end_column": 39888,
              "start_byte": 38707,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
              "file_path": "src/_pytest/python.py",
              "file_content": "ol)):\n           ",
              "start_line": 1012,
              "start_column": 38761,
              "end_line": 4,
              "end_column": 38778,
              "start_byte": 38761,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.params",
              "file_path": "src/_pytest/python.py",
              "file_content": "new_ids.append(str(id_value))\n            else:\n           ",
              "start_line": 1013,
              "start_column": 38783,
              "end_line": 4,
              "end_column": 38842,
              "start_byte": 38783,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
              "file_path": "src/_pytest/python.py",
              "file_content": "msg = \"In {}: ids must be list o",
              "start_line": 1014,
              "start_column": 38847,
              "end_line": 4,
              "end_column": 38879,
              "start_byte": 38847,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
              "file_path": "src/_pytest/python.py",
              "file_content": "ail(\n                    msg.format(func_name, saferepr(id_v",
              "start_line": 1016,
              "start_column": 38957,
              "end_line": 4,
              "end_column": 39017,
              "start_byte": 38957,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.name",
              "file_path": "src/_pytest/python.py",
              "file_content": ", idx),\n                    ",
              "start_line": 1017,
              "start_column": 39038,
              "end_line": 4,
              "end_column": 39066,
              "start_byte": 39038,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
              "file_path": "src/_pytest/python.py",
              "file_content": "e=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
              "start_line": 1019,
              "start_column": 39072,
              "end_line": 4,
              "end_column": 39888,
              "start_byte": 39072,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function",
              "file_path": "src/_pytest/python.py",
              "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1409,
              "start_column": 52332,
              "end_line": 0,
              "end_column": 57213,
              "start_byte": 52332,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Function._ALLOW_MARKERS",
              "file_path": "src/_pytest/python.py",
              "file_content": "_ALLOW_MARKERS = False",
              "start_line": 1415,
              "start_column": 52532,
              "end_line": 4,
              "end_column": 52554,
              "start_byte": 52532,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.__init__",
              "file_path": "src/_pytest/python.py",
              "file_content": "def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname",
              "start_line": 1417,
              "start_column": 52560,
              "end_line": 4,
              "end_column": 54540,
              "start_byte": 52560,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.from_parent",
              "file_path": "src/_pytest/python.py",
              "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
              "start_line": 1475,
              "start_column": 54546,
              "end_line": 4,
              "end_column": 54752,
              "start_byte": 54546,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._initrequest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)",
              "start_line": 1482,
              "start_column": 54758,
              "end_line": 4,
              "end_column": 54862,
              "start_byte": 54758,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.function",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
              "start_line": 1486,
              "start_column": 54868,
              "end_line": 4,
              "end_column": 54982,
              "start_byte": 54868,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._getobj",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)",
              "start_line": 1491,
              "start_column": 54988,
              "end_line": 4,
              "end_column": 55171,
              "start_byte": 54988,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._pyfuncitem",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
              "start_line": 1498,
              "start_column": 55177,
              "end_line": 4,
              "end_column": 55308,
              "start_byte": 55177,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.funcargnames",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
              "start_line": 1503,
              "start_column": 55314,
              "end_line": 4,
              "end_column": 55512,
              "start_byte": 55314,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
              "start_line": 1509,
              "start_column": 55518,
              "end_line": 4,
              "end_column": 55653,
              "start_byte": 55518,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
              "start_line": 1513,
              "start_column": 55659,
              "end_line": 4,
              "end_column": 55843,
              "start_byte": 55659,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
              "start_line": 1519,
              "start_column": 55849,
              "end_line": 4,
              "end_column": 56927,
              "start_byte": 55849,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.FunctionDefinition",
              "file_path": "src/_pytest/python.py",
              "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
              "start_line": 1548,
              "start_column": 57216,
              "end_line": 0,
              "end_column": 57494,
              "start_byte": 57216,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.FunctionDefinition.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
              "start_line": 1554,
              "start_column": 57368,
              "end_line": 4,
              "end_column": 57473,
              "start_byte": 57368,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.FunctionDefinition.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "setup = runtest",
              "start_line": 1557,
              "start_column": 57479,
              "end_line": 4,
              "end_column": 57494,
              "start_byte": 57479,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction",
              "file_path": "src/_pytest/python.py",
              "file_content": "ault=\"prepend\",\n        choices=[\"prepend\", \"append\"],\n        dest=\"importmode\",\n        help=\"prepend/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
              "start_line": 109,
              "start_column": 3686,
              "end_line": 0,
              "end_column": 8712,
              "start_byte": 3686,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
              "file_path": "src/_pytest/python.py",
              "file_content": "end\", \"append\"],\n",
              "start_line": 110,
              "start_column": 3724,
              "end_line": 4,
              "end_column": 3741,
              "start_byte": 3724,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._excinfo",
              "file_path": "src/_pytest/python.py",
              "file_content": "   dest=\"import",
              "start_line": 111,
              "start_column": 3746,
              "end_line": 4,
              "end_column": 3761,
              "start_byte": 3746,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._testcase",
              "file_path": "src/_pytest/python.py",
              "file_content": ",\n        help=\"",
              "start_line": 112,
              "start_column": 3766,
              "end_line": 4,
              "end_column": 3782,
              "start_byte": 3766,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "d/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_g",
              "start_line": 114,
              "start_column": 3788,
              "end_line": 4,
              "end_column": 4111,
              "start_byte": 3788,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.teardown",
              "file_path": "src/_pytest/python.py",
              "file_content": "e_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*mar",
              "start_line": 122,
              "start_column": 4117,
              "end_line": 4,
              "end_column": 4320,
              "start_byte": 4117,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.startTest",
              "file_path": "src/_pytest/python.py",
              "file_content": "gs, **marker.kwargs, _param_mark=marker)  #",
              "start_line": 129,
              "start_column": 4326,
              "end_line": 4,
              "end_column": 4369,
              "start_byte": 4326,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
              "file_path": "src/_pytest/python.py",
              "file_content": " ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip",
              "start_line": 132,
              "start_column": 4375,
              "end_line": 4,
              "end_column": 5757,
              "start_byte": 4375,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addError",
              "file_path": "src/_pytest/python.py",
              "file_content": "async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn",
              "start_line": 165,
              "start_column": 5763,
              "end_line": 4,
              "end_column": 5995,
              "start_byte": 5763,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addFailure",
              "file_path": "src/_pytest/python.py",
              "file_content": "kip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: f",
              "start_line": 173,
              "start_column": 6001,
              "end_line": 4,
              "end_column": 6081,
              "start_byte": 6001,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addSkip",
              "file_path": "src/_pytest/python.py",
              "file_content": "s[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.node",
              "start_line": 176,
              "start_column": 6087,
              "end_line": 4,
              "end_column": 6289,
              "start_byte": 6087,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
              "file_path": "src/_pytest/python.py",
              "file_content": "  return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns",
              "start_line": 183,
              "start_column": 6295,
              "end_line": 4,
              "end_column": 6478,
              "start_byte": 6295,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
              "file_path": "src/_pytest/python.py",
              "file_content": "            path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                ",
              "start_line": 189,
              "start_column": 6484,
              "end_line": 4,
              "end_column": 6588,
              "start_byte": 6484,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addSuccess",
              "file_path": "src/_pytest/python.py",
              "file_content": "\n        ihook = parent.session.gethookproxy",
              "start_line": 192,
              "start_column": 6594,
              "end_line": 4,
              "end_column": 6638,
              "start_byte": 6594,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.stopTest",
              "file_path": "src/_pytest/python.py",
              "file_content": "\n        return ihook.pytest_pycollect_mak",
              "start_line": 195,
              "start_column": 6644,
              "end_line": 4,
              "end_column": 6686,
              "start_byte": 6644,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "e(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(h",
              "start_line": 198,
              "start_column": 6692,
              "end_line": 4,
              "end_column": 7140,
              "start_byte": 6692,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "pper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n        ",
              "start_line": 207,
              "start_column": 7146,
              "end_line": 4,
              "end_column": 8441,
              "start_byte": 7146,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "  reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
              "start_line": 234,
              "start_column": 8447,
              "end_line": 4,
              "end_column": 8712,
              "start_byte": 8447,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest._io._format_repr_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
              "start_line": 14,
              "start_column": 259,
              "end_line": 0,
              "end_column": 665,
              "start_byte": 259,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 44,
              "start_column": 1193,
              "end_line": 4,
              "end_column": 1461,
              "start_byte": 1193,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 53,
              "start_column": 1467,
              "end_line": 4,
              "end_column": 1748,
              "start_byte": 1467,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.safeformat",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def safeformat(obj: Any) -> str:\n    \"\"\"return a pretty printed string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info.\n    \"\"\"\n    try:\n        return pprint.pformat(obj)\n    except Exception as exc:\n        return _format_repr_exception(exc, obj)",
              "start_line": 63,
              "start_column": 1751,
              "end_line": 0,
              "end_column": 2074,
              "start_byte": 1751,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
              "start_line": 74,
              "start_column": 2077,
              "end_line": 0,
              "end_column": 2512,
              "start_byte": 2077,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "",
              "start_line": 375,
              "start_column": 13624,
              "end_line": 0,
              "end_column": 14124,
              "start_byte": 13624,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
              "start_line": 577,
              "start_column": 19023,
              "end_line": 4,
              "end_column": 20900,
              "start_byte": 19023,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
              "start_line": 868,
              "start_column": 30141,
              "end_line": 4,
              "end_column": 32060,
              "start_byte": 30141,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
              "start_line": 74,
              "start_column": 2077,
              "end_line": 0,
              "end_column": 2512,
              "start_byte": 2077,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
              "start_line": 375,
              "start_column": 13624,
              "end_line": 0,
              "end_column": 14124,
              "start_byte": 13624,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Function.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1540,
              "start_column": 56933,
              "end_line": 4,
              "end_column": 57213,
              "start_byte": 56933,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport",
              "file_path": "src/_pytest/reports.py",
              "file_content": "class BaseReport:\n    when = None  # type: Optional[str]\n    location = None  # type: Optional[Tuple[str, Optional[int], str]]\n    longrepr = None\n    sections = []  # type: List[Tuple[str, str]]\n    nodeid = None  # type: str\n\n    def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)\n\n    if TYPE_CHECKING:\n        # Can have arbitrary fields given to __init__().\n        def __getattr__(self, key: str) -> Any:\n            raise NotImplementedError()\n\n    def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")\n\n    def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content\n\n    @property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()\n\n    @property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )\n\n    @property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )\n\n    @property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )\n\n    passed = property(lambda x: x.outcome == \"passed\")\n    failed = property(lambda x: x.outcome == \"failed\")\n    skipped = property(lambda x: x.outcome == \"skipped\")\n\n    @property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]\n\n    @property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True\n\n    @property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain\n\n    def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose\n\n    def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)\n\n    @classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
              "start_line": 40,
              "start_column": 1168,
              "end_line": 0,
              "end_column": 5629,
              "start_byte": 1168,
              "end_byte": 0
            },
            {
              "name": "_pytest.reports.BaseReport.when",
              "file_path": "src/_pytest/reports.py",
              "file_content": "when = None",
              "start_line": 41,
              "start_column": 1190,
              "end_line": 4,
              "end_column": 1201,
              "start_byte": 1190,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.location",
              "file_path": "src/_pytest/reports.py",
              "file_content": "location = None",
              "start_line": 42,
              "start_column": 1229,
              "end_line": 4,
              "end_column": 1244,
              "start_byte": 1229,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.longrepr",
              "file_path": "src/_pytest/reports.py",
              "file_content": "longrepr = None",
              "start_line": 43,
              "start_column": 1299,
              "end_line": 4,
              "end_column": 1314,
              "start_byte": 1299,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.sections",
              "file_path": "src/_pytest/reports.py",
              "file_content": "sections = []",
              "start_line": 44,
              "start_column": 1319,
              "end_line": 4,
              "end_column": 1332,
              "start_byte": 1319,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.nodeid",
              "file_path": "src/_pytest/reports.py",
              "file_content": "nodeid = None",
              "start_line": 45,
              "start_column": 1368,
              "end_line": 4,
              "end_column": 1381,
              "start_byte": 1368,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.__init__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)",
              "start_line": 47,
              "start_column": 1400,
              "end_line": 4,
              "end_column": 1471,
              "start_byte": 1400,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.toterminal",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")",
              "start_line": 55,
              "start_column": 1645,
              "end_line": 4,
              "end_column": 2083,
              "start_byte": 1645,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.get_sections",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content",
              "start_line": 71,
              "start_column": 2089,
              "end_line": 4,
              "end_column": 2242,
              "start_byte": 2089,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.longreprtext",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()",
              "start_line": 76,
              "start_column": 2248,
              "end_line": 4,
              "end_column": 2600,
              "start_byte": 2248,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.caplog",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )",
              "start_line": 90,
              "start_column": 2606,
              "end_line": 4,
              "end_column": 2861,
              "start_byte": 2606,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.capstdout",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )",
              "start_line": 100,
              "start_column": 2867,
              "end_line": 4,
              "end_column": 3129,
              "start_byte": 2867,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.capstderr",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )",
              "start_line": 110,
              "start_column": 3135,
              "end_line": 4,
              "end_column": 3397,
              "start_byte": 3135,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.passed",
              "file_path": "src/_pytest/reports.py",
              "file_content": "passed = property(lambda x: x.outcome == \"passed\")",
              "start_line": 120,
              "start_column": 3403,
              "end_line": 4,
              "end_column": 3453,
              "start_byte": 3403,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.failed",
              "file_path": "src/_pytest/reports.py",
              "file_content": "failed = property(lambda x: x.outcome == \"failed\")",
              "start_line": 121,
              "start_column": 3458,
              "end_line": 4,
              "end_column": 3508,
              "start_byte": 3458,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.skipped",
              "file_path": "src/_pytest/reports.py",
              "file_content": "skipped = property(lambda x: x.outcome == \"skipped\")",
              "start_line": 122,
              "start_column": 3513,
              "end_line": 4,
              "end_column": 3565,
              "start_byte": 3513,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.fspath",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]",
              "start_line": 124,
              "start_column": 3571,
              "end_line": 4,
              "end_column": 3651,
              "start_byte": 3571,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.count_towards_summary",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True",
              "start_line": 128,
              "start_column": 3657,
              "end_line": 4,
              "end_column": 4070,
              "start_byte": 3657,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport.head_line",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain",
              "start_line": 143,
              "start_column": 4076,
              "end_line": 4,
              "end_column": 4676,
              "start_byte": 4076,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport._get_verbose_word",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose",
              "start_line": 165,
              "start_column": 4682,
              "end_line": 4,
              "end_column": 4865,
              "start_byte": 4682,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport._to_json",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)",
              "start_line": 171,
              "start_column": 4871,
              "end_line": 4,
              "end_column": 5174,
              "start_byte": 4871,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport._from_json",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
              "start_line": 182,
              "start_column": 5180,
              "end_line": 4,
              "end_column": 5629,
              "start_byte": 5180,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport",
              "file_path": "src/_pytest/reports.py",
              "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
              "start_line": 208,
              "start_column": 6154,
              "end_line": 0,
              "end_column": 9677,
              "start_byte": 6154,
              "end_byte": 0
            },
            {
              "name": "_pytest.reports.TestReport.__test__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "__test__ = False",
              "start_line": 213,
              "start_column": 6289,
              "end_line": 4,
              "end_column": 6305,
              "start_byte": 6289,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport.__init__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
              "start_line": 215,
              "start_column": 6311,
              "end_line": 4,
              "end_column": 7977,
              "start_byte": 6311,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport.__repr__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
              "start_line": 264,
              "start_column": 7983,
              "end_line": 4,
              "end_column": 8144,
              "start_byte": 7983,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport.from_item_and_call",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
              "start_line": 269,
              "start_column": 8150,
              "end_line": 4,
              "end_column": 9677,
              "start_byte": 8150,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.CollectReport",
              "file_path": "src/_pytest/reports.py",
              "file_content": "class CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n        return (self.fspath, None, self.fspath)\n\n    def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
              "start_line": 313,
              "start_column": 9680,
              "end_line": 0,
              "end_column": 10307,
              "start_byte": 9680,
              "end_byte": 0
            },
            {
              "name": "_pytest.reports.CollectReport.when",
              "file_path": "src/_pytest/reports.py",
              "file_content": "when = \"collect\"",
              "start_line": 314,
              "start_column": 9717,
              "end_line": 4,
              "end_column": 9733,
              "start_byte": 9717,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.CollectReport.__init__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)",
              "start_line": 316,
              "start_column": 9739,
              "end_line": 4,
              "end_column": 10057,
              "start_byte": 9739,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.CollectReport.location",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@property\n    def location(self):\n        return (self.fspath, None, self.fspath)",
              "start_line": 326,
              "start_column": 10063,
              "end_line": 4,
              "end_column": 10144,
              "start_byte": 10063,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.CollectReport.__repr__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
              "start_line": 330,
              "start_column": 10150,
              "end_line": 4,
              "end_column": 10307,
              "start_byte": 10150,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The user describes an INTERNALERROR occurring in pytest when running a specific test. This issue seems to stem from a custom __repr__ method that raises an exception, which is subsequently causing pytest's internal error handling to fail.\n2. The issue was caused by an exception being raised in the __repr__ function defined in a test class used in pytest. This is significant because pytest uses repr() internally to generate error messages and debugging information. When there is an error in a __repr__ method, it might lead to such internal errors in testing frameworks.\n3. The expected result should be that even if __repr__ raises an exception, pytest should handle this gracefully without crashing.\n4. If not provided clearly by the user, the expectation is pytest manages such cases without running into internal errors.\n5. To fix the issue, the internal error handling of Pytest should be improved to manage exceptions raised by __repr__ methods more gracefully, possibly defaulting to a simpler or safer representation.\n\nLooking at the code provided, it seems that the methods involved in the string representation of exceptions in pytest are malfunctioning when __repr__ in user code raises an error. The _format_repr_exception and other related methods in the saferepr.py file of pytest are likely involved here. These methods attempt to catch exceptions for safe representation but might not be handling some edge cases properly.",
          "symbols": [
            {
              "name": "_pytest._io._format_repr_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This function formats exceptions that occur during representation, and it seems to be directly relevant because it should catch any exception raised during a __repr__ call."
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This method overrides the default repr method to provide a safe string representation. It's related because it should handle exceptions in __repr__."
            },
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This is another method providing safe instance representation, catching exceptions from __repr__ specifically."
            },
            {
              "name": "_pytest._io.safeformat",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This function is aimed at safely formatting objects and utilizes _format_repr_exception, which is involved in scenarios causing this issue."
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This wrapper around repr uses SafeRepr which manages exceptions from object representations, associated with exceptions during repr calls."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "_pytest._io._format_repr_exception: This function handles exceptions raised in the __repr__ method, formats them and ensures that no further unhandled exceptions cause crashes. It seems crucial in solving the problem where an __repr__ causing an exception leads to an internal error in pytest.",
            "_pytest._io.SafeRepr.repr: The repr function here overrides the default to add a try-except block around the representation call, mitigating issues caused if __repr__ throws an error.",
            "_pytest._io.SafeRepr.repr_instance: Similar to the 'repr', this method deals specifically with instances and should safely cover cases where __repr__ could go wrong, likely involved in or affected by the issue in question.",
            "_pytest._io.safeformat: This method aims to provide a 'pretty' print of objects, integrating _format_repr_exception to handle cases where __repr__ fails. Relevant for handling these exceptions gracefully.",
            "_pytest._io.saferepr: Utilizes SafeRepr to return a safe string representation, catching exceptions from __repr__ methods."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/_io/saferepr.py"
        ],
        "symbols": [
          "_pytest._io._format_repr_exception",
          "_pytest._io.SafeRepr.repr",
          "_pytest._io.SafeRepr.repr_instance",
          "_pytest._io.safeformat",
          "_pytest._io.saferepr"
        ],
        "code_spans": {
          "_pytest._code.FormattedExcinfo.repr_traceback_entry": {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(\n        self, entry: TracebackEntry, excinfo: Optional[ExceptionInfo] = None\n    ) -> \"ReprEntry\":\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []  # type: List[str]\n        style = entry._repr_style if entry._repr_style is not None else self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            reprfileloc = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 768,
            "start_column": 25949,
            "end_line": 4,
            "end_column": 27245,
            "start_byte": 25949,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_traceback": {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo: ExceptionInfo) -> \"ReprTraceback\":\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 809,
            "start_column": 27527,
            "end_line": 4,
            "end_column": 28203,
            "start_byte": 27527,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo.reprtraceback": {
            "name": "_pytest._code.ReprExceptionInfo.reprtraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "reprtraceback = attr.ib(type=\"ReprTraceback\")",
            "start_line": 971,
            "start_column": 33932,
            "end_line": 4,
            "end_column": 33977,
            "start_byte": 33932,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo.reprcrash": {
            "name": "_pytest._code.ReprExceptionInfo.reprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "reprcrash = attr.ib(type=\"ReprFileLocation\")",
            "start_line": 972,
            "start_column": 33982,
            "end_line": 4,
            "end_column": 34026,
            "start_byte": 33982,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
            "start_line": 1010,
            "start_column": 38707,
            "end_line": 0,
            "end_column": 39888,
            "start_byte": 38707,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": "ol)):\n           ",
            "start_line": 1012,
            "start_column": 38761,
            "end_line": 4,
            "end_column": 38778,
            "start_byte": 38761,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "new_ids.append(str(id_value))\n            else:\n           ",
            "start_line": 1013,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 38842,
            "start_byte": 38783,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "msg = \"In {}: ids must be list o",
            "start_line": 1014,
            "start_column": 38847,
            "end_line": 4,
            "end_column": 38879,
            "start_byte": 38847,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ail(\n                    msg.format(func_name, saferepr(id_v",
            "start_line": 1016,
            "start_column": 38957,
            "end_line": 4,
            "end_column": 39017,
            "start_byte": 38957,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": ", idx),\n                    ",
            "start_line": 1017,
            "start_column": 39038,
            "end_line": 4,
            "end_column": 39066,
            "start_byte": 39038,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": "e=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter ",
            "start_line": 1019,
            "start_column": 39072,
            "end_line": 4,
            "end_column": 39888,
            "start_byte": 39072,
            "end_byte": 4
          },
          "_pytest.python.Function": {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1409,
            "start_column": 52332,
            "end_line": 0,
            "end_column": 57213,
            "start_byte": 52332,
            "end_byte": 0
          },
          "_pytest.python.Function._ALLOW_MARKERS": {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1415,
            "start_column": 52532,
            "end_line": 4,
            "end_column": 52554,
            "start_byte": 52532,
            "end_byte": 4
          },
          "_pytest.python.Function.__init__": {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname",
            "start_line": 1417,
            "start_column": 52560,
            "end_line": 4,
            "end_column": 54540,
            "start_byte": 52560,
            "end_byte": 4
          },
          "_pytest.python.Function.from_parent": {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1475,
            "start_column": 54546,
            "end_line": 4,
            "end_column": 54752,
            "start_byte": 54546,
            "end_byte": 4
          },
          "_pytest.python.Function._initrequest": {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1482,
            "start_column": 54758,
            "end_line": 4,
            "end_column": 54862,
            "start_byte": 54758,
            "end_byte": 4
          },
          "_pytest.python.Function.function": {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1486,
            "start_column": 54868,
            "end_line": 4,
            "end_column": 54982,
            "start_byte": 54868,
            "end_byte": 4
          },
          "_pytest.python.Function._getobj": {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)",
            "start_line": 1491,
            "start_column": 54988,
            "end_line": 4,
            "end_column": 55171,
            "start_byte": 54988,
            "end_byte": 4
          },
          "_pytest.python.Function._pyfuncitem": {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1498,
            "start_column": 55177,
            "end_line": 4,
            "end_column": 55308,
            "start_byte": 55177,
            "end_byte": 4
          },
          "_pytest.python.Function.funcargnames": {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1503,
            "start_column": 55314,
            "end_line": 4,
            "end_column": 55512,
            "start_byte": 55314,
            "end_byte": 4
          },
          "_pytest.python.Function.runtest": {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1509,
            "start_column": 55518,
            "end_line": 4,
            "end_column": 55653,
            "start_byte": 55518,
            "end_byte": 4
          },
          "_pytest.python.Function.setup": {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1513,
            "start_column": 55659,
            "end_line": 4,
            "end_column": 55843,
            "start_byte": 55659,
            "end_byte": 4
          },
          "_pytest.python.Function._prunetraceback": {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1519,
            "start_column": 55849,
            "end_line": 4,
            "end_column": 56927,
            "start_byte": 55849,
            "end_byte": 4
          },
          "_pytest.python.FunctionDefinition": {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1548,
            "start_column": 57216,
            "end_line": 0,
            "end_column": 57494,
            "start_byte": 57216,
            "end_byte": 0
          },
          "_pytest.python.FunctionDefinition.runtest": {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1554,
            "start_column": 57368,
            "end_line": 4,
            "end_column": 57473,
            "start_byte": 57368,
            "end_byte": 4
          },
          "_pytest.python.FunctionDefinition.setup": {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1557,
            "start_column": 57479,
            "end_line": 4,
            "end_column": 57494,
            "start_byte": 57479,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction": {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "ault=\"prepend\",\n        choices=[\"prepend\", \"append\"],\n        dest=\"importmode\",\n        help=\"prepend/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
            "start_line": 109,
            "start_column": 3686,
            "end_line": 0,
            "end_column": 8712,
            "start_byte": 3686,
            "end_byte": 0
          },
          "_pytest.unittest.TestCaseFunction.nofuncargs": {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "end\", \"append\"],\n",
            "start_line": 110,
            "start_column": 3724,
            "end_line": 4,
            "end_column": 3741,
            "start_byte": 3724,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._excinfo": {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "   dest=\"import",
            "start_line": 111,
            "start_column": 3746,
            "end_line": 4,
            "end_column": 3761,
            "start_byte": 3746,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._testcase": {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": ",\n        help=\"",
            "start_line": 112,
            "start_column": 3766,
            "end_line": 4,
            "end_column": 3782,
            "start_byte": 3766,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.setup": {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "d/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )\n\n\ndef pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_g",
            "start_line": 114,
            "start_column": 3788,
            "end_line": 4,
            "end_column": 4111,
            "start_byte": 3788,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.teardown": {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "e_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*mar",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.startTest": {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "gs, **marker.kwargs, _param_mark=marker)  #",
            "start_line": 129,
            "start_column": 4326,
            "end_line": 4,
            "end_column": 4369,
            "start_byte": 4326,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._addexcinfo": {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip",
            "start_line": 132,
            "start_column": 4375,
            "end_line": 4,
            "end_column": 5757,
            "start_byte": 4375,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addError": {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn",
            "start_line": 165,
            "start_column": 5763,
            "end_line": 4,
            "end_column": 5995,
            "start_byte": 5763,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "kip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: f",
            "start_line": 173,
            "start_column": 6001,
            "end_line": 4,
            "end_column": 6081,
            "start_byte": 6001,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addSkip": {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "s[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.node",
            "start_line": 176,
            "start_column": 6087,
            "end_line": 4,
            "end_column": 6289,
            "start_byte": 6087,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addExpectedFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "  return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns",
            "start_line": 183,
            "start_column": 6295,
            "end_line": 4,
            "end_column": 6478,
            "start_byte": 6295,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "            path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                ",
            "start_line": 189,
            "start_column": 6484,
            "end_line": 4,
            "end_column": 6588,
            "start_byte": 6484,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        ihook = parent.session.gethookproxy",
            "start_line": 192,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6638,
            "start_byte": 6594,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.stopTest": {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        return ihook.pytest_pycollect_mak",
            "start_line": 195,
            "start_column": 6644,
            "end_line": 4,
            "end_column": 6686,
            "start_byte": 6644,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._expecting_failure": {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "e(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)\n\n\n@hookimpl(h",
            "start_line": 198,
            "start_column": 6692,
            "end_line": 4,
            "end_column": 7140,
            "start_byte": 6692,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "pper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n        ",
            "start_line": 207,
            "start_column": 7146,
            "end_line": 4,
            "end_column": 8441,
            "start_byte": 7146,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._prunetraceback": {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "  reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n ",
            "start_line": 234,
            "start_column": 8447,
            "end_line": 4,
            "end_column": 8712,
            "start_byte": 8447,
            "end_byte": 4
          },
          "_pytest._io._format_repr_exception": {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          "_pytest._io.SafeRepr.repr": {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr.repr_instance": {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          "_pytest._io.safeformat": {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def safeformat(obj: Any) -> str:\n    \"\"\"return a pretty printed string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info.\n    \"\"\"\n    try:\n        return pprint.pformat(obj)\n    except Exception as exc:\n        return _format_repr_exception(exc, obj)",
            "start_line": 63,
            "start_column": 1751,
            "end_line": 0,
            "end_column": 2074,
            "start_byte": 1751,
            "end_byte": 0
          },
          "_pytest._io.saferepr": {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          "_pytest.assertion._saferepr": {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 577,
            "start_column": 19023,
            "end_line": 4,
            "end_column": 20900,
            "start_byte": 19023,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_excinfo": {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 868,
            "start_column": 30141,
            "end_line": 4,
            "end_column": 32060,
            "start_byte": 30141,
            "end_byte": 4
          },
          "_pytest.python.Function.repr_failure": {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1540,
            "start_column": 56933,
            "end_line": 4,
            "end_column": 57213,
            "start_byte": 56933,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport": {
            "name": "_pytest.reports.BaseReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class BaseReport:\n    when = None  # type: Optional[str]\n    location = None  # type: Optional[Tuple[str, Optional[int], str]]\n    longrepr = None\n    sections = []  # type: List[Tuple[str, str]]\n    nodeid = None  # type: str\n\n    def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)\n\n    if TYPE_CHECKING:\n        # Can have arbitrary fields given to __init__().\n        def __getattr__(self, key: str) -> Any:\n            raise NotImplementedError()\n\n    def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")\n\n    def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content\n\n    @property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()\n\n    @property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )\n\n    @property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )\n\n    @property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )\n\n    passed = property(lambda x: x.outcome == \"passed\")\n    failed = property(lambda x: x.outcome == \"failed\")\n    skipped = property(lambda x: x.outcome == \"skipped\")\n\n    @property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]\n\n    @property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True\n\n    @property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain\n\n    def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose\n\n    def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)\n\n    @classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
            "start_line": 40,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 5629,
            "start_byte": 1168,
            "end_byte": 0
          },
          "_pytest.reports.BaseReport.when": {
            "name": "_pytest.reports.BaseReport.when",
            "file_path": "src/_pytest/reports.py",
            "file_content": "when = None",
            "start_line": 41,
            "start_column": 1190,
            "end_line": 4,
            "end_column": 1201,
            "start_byte": 1190,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.location": {
            "name": "_pytest.reports.BaseReport.location",
            "file_path": "src/_pytest/reports.py",
            "file_content": "location = None",
            "start_line": 42,
            "start_column": 1229,
            "end_line": 4,
            "end_column": 1244,
            "start_byte": 1229,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.longrepr": {
            "name": "_pytest.reports.BaseReport.longrepr",
            "file_path": "src/_pytest/reports.py",
            "file_content": "longrepr = None",
            "start_line": 43,
            "start_column": 1299,
            "end_line": 4,
            "end_column": 1314,
            "start_byte": 1299,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.sections": {
            "name": "_pytest.reports.BaseReport.sections",
            "file_path": "src/_pytest/reports.py",
            "file_content": "sections = []",
            "start_line": 44,
            "start_column": 1319,
            "end_line": 4,
            "end_column": 1332,
            "start_byte": 1319,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.nodeid": {
            "name": "_pytest.reports.BaseReport.nodeid",
            "file_path": "src/_pytest/reports.py",
            "file_content": "nodeid = None",
            "start_line": 45,
            "start_column": 1368,
            "end_line": 4,
            "end_column": 1381,
            "start_byte": 1368,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.__init__": {
            "name": "_pytest.reports.BaseReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)",
            "start_line": 47,
            "start_column": 1400,
            "end_line": 4,
            "end_column": 1471,
            "start_byte": 1400,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.toterminal": {
            "name": "_pytest.reports.BaseReport.toterminal",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")",
            "start_line": 55,
            "start_column": 1645,
            "end_line": 4,
            "end_column": 2083,
            "start_byte": 1645,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.get_sections": {
            "name": "_pytest.reports.BaseReport.get_sections",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content",
            "start_line": 71,
            "start_column": 2089,
            "end_line": 4,
            "end_column": 2242,
            "start_byte": 2089,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.longreprtext": {
            "name": "_pytest.reports.BaseReport.longreprtext",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        tw = TerminalWriter(stringio=True)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = tw.stringio.getvalue()\n        return exc.strip()",
            "start_line": 76,
            "start_column": 2248,
            "end_line": 4,
            "end_column": 2600,
            "start_byte": 2248,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.caplog": {
            "name": "_pytest.reports.BaseReport.caplog",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )",
            "start_line": 90,
            "start_column": 2606,
            "end_line": 4,
            "end_column": 2861,
            "start_byte": 2606,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.capstdout": {
            "name": "_pytest.reports.BaseReport.capstdout",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )",
            "start_line": 100,
            "start_column": 2867,
            "end_line": 4,
            "end_column": 3129,
            "start_byte": 2867,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.capstderr": {
            "name": "_pytest.reports.BaseReport.capstderr",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )",
            "start_line": 110,
            "start_column": 3135,
            "end_line": 4,
            "end_column": 3397,
            "start_byte": 3135,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.passed": {
            "name": "_pytest.reports.BaseReport.passed",
            "file_path": "src/_pytest/reports.py",
            "file_content": "passed = property(lambda x: x.outcome == \"passed\")",
            "start_line": 120,
            "start_column": 3403,
            "end_line": 4,
            "end_column": 3453,
            "start_byte": 3403,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.failed": {
            "name": "_pytest.reports.BaseReport.failed",
            "file_path": "src/_pytest/reports.py",
            "file_content": "failed = property(lambda x: x.outcome == \"failed\")",
            "start_line": 121,
            "start_column": 3458,
            "end_line": 4,
            "end_column": 3508,
            "start_byte": 3458,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.skipped": {
            "name": "_pytest.reports.BaseReport.skipped",
            "file_path": "src/_pytest/reports.py",
            "file_content": "skipped = property(lambda x: x.outcome == \"skipped\")",
            "start_line": 122,
            "start_column": 3513,
            "end_line": 4,
            "end_column": 3565,
            "start_byte": 3513,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.fspath": {
            "name": "_pytest.reports.BaseReport.fspath",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]",
            "start_line": 124,
            "start_column": 3571,
            "end_line": 4,
            "end_column": 3651,
            "start_byte": 3571,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.count_towards_summary": {
            "name": "_pytest.reports.BaseReport.count_towards_summary",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True",
            "start_line": 128,
            "start_column": 3657,
            "end_line": 4,
            "end_column": 4070,
            "start_byte": 3657,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport.head_line": {
            "name": "_pytest.reports.BaseReport.head_line",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain",
            "start_line": 143,
            "start_column": 4076,
            "end_line": 4,
            "end_column": 4676,
            "start_byte": 4076,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport._get_verbose_word": {
            "name": "_pytest.reports.BaseReport._get_verbose_word",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose",
            "start_line": 165,
            "start_column": 4682,
            "end_line": 4,
            "end_column": 4865,
            "start_byte": 4682,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport._to_json": {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)",
            "start_line": 171,
            "start_column": 4871,
            "end_line": 4,
            "end_column": 5174,
            "start_byte": 4871,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport._from_json": {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)",
            "start_line": 182,
            "start_column": 5180,
            "end_line": 4,
            "end_column": 5629,
            "start_byte": 5180,
            "end_byte": 4
          },
          "_pytest.reports.TestReport": {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 208,
            "start_column": 6154,
            "end_line": 0,
            "end_column": 9677,
            "start_byte": 6154,
            "end_byte": 0
          },
          "_pytest.reports.TestReport.__test__": {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 213,
            "start_column": 6289,
            "end_line": 4,
            "end_column": 6305,
            "start_byte": 6289,
            "end_byte": 4
          },
          "_pytest.reports.TestReport.__init__": {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 215,
            "start_column": 6311,
            "end_line": 4,
            "end_column": 7977,
            "start_byte": 6311,
            "end_byte": 4
          },
          "_pytest.reports.TestReport.__repr__": {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 264,
            "start_column": 7983,
            "end_line": 4,
            "end_column": 8144,
            "start_byte": 7983,
            "end_byte": 4
          },
          "_pytest.reports.TestReport.from_item_and_call": {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 269,
            "start_column": 8150,
            "end_line": 4,
            "end_column": 9677,
            "start_byte": 8150,
            "end_byte": 4
          },
          "_pytest.reports.CollectReport": {
            "name": "_pytest.reports.CollectReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n        return (self.fspath, None, self.fspath)\n\n    def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
            "start_line": 313,
            "start_column": 9680,
            "end_line": 0,
            "end_column": 10307,
            "start_byte": 9680,
            "end_byte": 0
          },
          "_pytest.reports.CollectReport.when": {
            "name": "_pytest.reports.CollectReport.when",
            "file_path": "src/_pytest/reports.py",
            "file_content": "when = \"collect\"",
            "start_line": 314,
            "start_column": 9717,
            "end_line": 4,
            "end_column": 9733,
            "start_byte": 9717,
            "end_byte": 4
          },
          "_pytest.reports.CollectReport.__init__": {
            "name": "_pytest.reports.CollectReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)",
            "start_line": 316,
            "start_column": 9739,
            "end_line": 4,
            "end_column": 10057,
            "start_byte": 9739,
            "end_byte": 4
          },
          "_pytest.reports.CollectReport.location": {
            "name": "_pytest.reports.CollectReport.location",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@property\n    def location(self):\n        return (self.fspath, None, self.fspath)",
            "start_line": 326,
            "start_column": 10063,
            "end_line": 4,
            "end_column": 10144,
            "start_byte": 10063,
            "end_byte": 4
          },
          "_pytest.reports.CollectReport.__repr__": {
            "name": "_pytest.reports.CollectReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )",
            "start_line": 330,
            "start_column": 10150,
            "end_line": 4,
            "end_column": 10307,
            "start_byte": 10150,
            "end_byte": 4
          }
        }
      }
    }
  ]
}