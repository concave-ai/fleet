{
    "file_paths": [
        "src/_pytest/nodes.py"
    ],
    "symbols": [
        "_pytest.nodes.Node.add_marker"
    ],
    "code_spans": {
        "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureRequest.applymarker": {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker) -> None:\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 548,
            "start_column": 21159,
            "end_line": 4,
            "end_column": 21551,
            "start_byte": 21159,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
        },
        "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
        },
        "_pytest.mark.MarkMatcher": {
            "name": "_pytest.mark.MarkMatcher",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "lf.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 214,
            "start_column": 7079,
            "end_line": 0,
            "end_column": 7525,
            "start_byte": 7079,
            "end_byte": 0
        },
        "_pytest.mark.MarkMatcher.own_mark_names": {
            "name": "_pytest.mark.MarkMatcher.own_mark_names",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": " Mark.\n\n        Combines b",
            "start_line": 221,
            "start_column": 7251,
            "end_line": 4,
            "end_column": 7277,
            "start_byte": 7251,
            "end_byte": 4
        },
        "_pytest.mark.MarkMatcher.from_item": {
            "name": "_pytest.mark.MarkMatcher.from_item",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "nding args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert s",
            "start_line": 223,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7438,
            "start_byte": 7283,
            "end_byte": 4
        },
        "_pytest.mark.MarkMatcher.__call__": {
            "name": "_pytest.mark.MarkMatcher.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "me == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 228,
            "start_column": 7444,
            "end_line": 4,
            "end_column": 7525,
            "start_byte": 7444,
            "end_byte": 4
        },
        "_pytest.mark.Mark": {
            "name": "_pytest.mark.Mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 195,
            "start_column": 6452,
            "end_line": 0,
            "end_column": 7948,
            "start_byte": 6452,
            "end_byte": 0
        },
        "_pytest.mark.Mark.name": {
            "name": "_pytest.mark.Mark.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "name = attr.ib(type=str)",
            "start_line": 198,
            "start_column": 6514,
            "end_line": 4,
            "end_column": 6538,
            "start_byte": 6514,
            "end_byte": 4
        },
        "_pytest.mark.Mark.args": {
            "name": "_pytest.mark.Mark.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "args = attr.ib(type=Tuple[Any, ...])",
            "start_line": 200,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6630,
            "start_byte": 6594,
            "end_byte": 4
        },
        "_pytest.mark.Mark.kwargs": {
            "name": "_pytest.mark.Mark.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "kwargs = attr.ib(type=Mapping[str, Any])",
            "start_line": 202,
            "start_column": 6683,
            "end_line": 4,
            "end_column": 6723,
            "start_byte": 6683,
            "end_byte": 4
        },
        "_pytest.mark.Mark._param_ids_from": {
            "name": "_pytest.mark.Mark._param_ids_from",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)",
            "start_line": 205,
            "start_column": 6780,
            "end_line": 4,
            "end_column": 6854,
            "start_byte": 6780,
            "end_byte": 4
        },
        "_pytest.mark.Mark._param_ids_generated": {
            "name": "_pytest.mark.Mark._param_ids_generated",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )",
            "start_line": 207,
            "start_column": 6913,
            "end_line": 4,
            "end_column": 7013,
            "start_byte": 6913,
            "end_byte": 4
        },
        "_pytest.mark.Mark._has_param_ids": {
            "name": "_pytest.mark.Mark._has_param_ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4",
            "start_line": 211,
            "start_column": 7019,
            "end_line": 4,
            "end_column": 7111,
            "start_byte": 7019,
            "end_byte": 4
        },
        "_pytest.mark.Mark.combined_with": {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 214,
            "start_column": 7117,
            "end_line": 4,
            "end_column": 7948,
            "start_byte": 7117,
            "end_byte": 4
        },
        "_pytest.mark._Markable": {
            "name": "_pytest.mark._Markable",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_Markable = TypeVar(\"_Markable\", bound=Union[Callable[..., object], type])",
            "start_line": 245,
            "start_column": 8132,
            "end_line": 0,
            "end_column": 8206,
            "start_byte": 8132,
            "end_byte": 0
        },
        "_pytest.mark.MarkDecorator": {
            "name": "_pytest.mark.MarkDecorator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    # Type ignored because the overloads overlap with an incompatible\n    # return type. Not much we can do about that. Thankfully mypy picks\n    # the first match so it works out even if we break the rules.\n    @overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()\n\n    def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 248,
            "start_column": 8209,
            "end_line": 0,
            "end_column": 11549,
            "start_byte": 8209,
            "end_byte": 0
        },
        "_pytest.mark.MarkDecorator.mark": {
            "name": "_pytest.mark.MarkDecorator.mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))",
            "start_line": 284,
            "start_column": 9608,
            "end_line": 4,
            "end_column": 9678,
            "start_byte": 9608,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.name": {
            "name": "_pytest.mark.MarkDecorator.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name",
            "start_line": 286,
            "start_column": 9684,
            "end_line": 4,
            "end_column": 9785,
            "start_byte": 9684,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.args": {
            "name": "_pytest.mark.MarkDecorator.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args",
            "start_line": 291,
            "start_column": 9791,
            "end_line": 4,
            "end_column": 9904,
            "start_byte": 9791,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.kwargs": {
            "name": "_pytest.mark.MarkDecorator.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs",
            "start_line": 296,
            "start_column": 9910,
            "end_line": 4,
            "end_column": 10031,
            "start_byte": 9910,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.markname": {
            "name": "_pytest.mark.MarkDecorator.markname",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)",
            "start_line": 301,
            "start_column": 10037,
            "end_line": 4,
            "end_column": 10147,
            "start_byte": 10037,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.__repr__": {
            "name": "_pytest.mark.MarkDecorator.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)",
            "start_line": 305,
            "start_column": 10153,
            "end_line": 4,
            "end_column": 10235,
            "start_byte": 10153,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.with_args": {
            "name": "_pytest.mark.MarkDecorator.with_args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))",
            "start_line": 308,
            "start_column": 10241,
            "end_line": 4,
            "end_column": 10647,
            "start_byte": 10241,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.__call__": {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 332,
            "start_column": 11156,
            "end_line": 4,
            "end_column": 11549,
            "start_byte": 11156,
            "end_byte": 4
        },
        "_pytest.mark.store_mark": {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
            "start_line": 369,
            "start_column": 12372,
            "end_line": 0,
            "end_column": 12724,
            "start_byte": 12372,
            "end_byte": 0
        },
        "_pytest.mark.MarkGenerator": {
            "name": "_pytest.mark.MarkGenerator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None  # type: Optional[Config]\n    _markers = set()  # type: Set[str]\n\n    # See TYPE_CHECKING above.\n    if TYPE_CHECKING:\n        # Using casts instead of type comments intentionally - issue #7473.\n        # TODO(py36): Change to builtin annotation syntax.\n        skip = cast(_SkipMarkDecorator, None)\n        skipif = cast(_SkipifMarkDecorator, None)\n        xfail = cast(_XfailMarkDecorator, None)\n        parametrize = cast(_ParametrizeMarkDecorator, None)\n        usefixtures = cast(_UsefixturesMarkDecorator, None)\n        filterwarnings = cast(_FilterwarningsMarkDecorator, None)\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 450,
            "start_column": 15252,
            "end_line": 0,
            "end_column": 18166,
            "start_byte": 15252,
            "end_byte": 0
        },
        "_pytest.mark.MarkGenerator._config": {
            "name": "_pytest.mark.MarkGenerator._config",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_config = None",
            "start_line": 465,
            "start_column": 15571,
            "end_line": 4,
            "end_column": 15585,
            "start_byte": 15571,
            "end_byte": 4
        },
        "_pytest.mark.MarkGenerator._markers": {
            "name": "_pytest.mark.MarkGenerator._markers",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_markers = set()",
            "start_line": 466,
            "start_column": 15616,
            "end_line": 4,
            "end_column": 15632,
            "start_byte": 15616,
            "end_byte": 4
        },
        "_pytest.mark.MarkGenerator.__getattr__": {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 479,
            "start_column": 16175,
            "end_line": 4,
            "end_column": 18166,
            "start_byte": 16175,
            "end_byte": 4
        },
        "_pytest.warning_types.PytestUnknownMarkWarning": {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "\"values\", Sequence[Union[object, NotSetType]]),\n            (\"marks\", \"typing.Collection[Union[MarkDecorator, Mark]]\"),\n            (\"id\", Optional[str]),\n        ],\n    )\n):\n    @classmethod\n    d",
            "start_line": 77,
            "start_column": 1903,
            "end_line": 0,
            "end_column": 2100,
            "start_byte": 1903,
            "end_byte": 0
        },
        "_pytest.warning_types.PytestUnknownMarkWarning.__module__": {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning.__module__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "   @classmethod\n    d",
            "start_line": 83,
            "start_column": 2079,
            "end_line": 4,
            "end_column": 2100,
            "start_byte": 2079,
            "end_byte": 4
        },
        "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
        },
        "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
        },
        "_pytest.skipping.evaluate_xfail_marks": {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
        },
        "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
        }
    }
}