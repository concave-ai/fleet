{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5413",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:33:50.732321",
        "usage": "1609.6360683441162 ms"
      },
      "request": {
        "repo_tokens": [
          "summary_passes",
          "Cache",
          "summary_failures",
          "visit_Name",
          "fixturenames",
          "push_format_context",
          "extract_suffixes",
          "processoption",
          "fnmatch_lines",
          "LogCaptureHandler",
          "append_collect_error",
          "_read_pyc",
          "getpluginversioninfo",
          "typename",
          "cacheprovider",
          "find",
          "summary_errors",
          "_plugin_nameversions",
          "ids",
          "append_collect_skipped",
          "exit",
          "traceback",
          "_consider_importhook",
          "_validate_args",
          "delattr",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "CallInfo",
          "write_fspath_result",
          "CLOSE_STDIN",
          "cwd_relative_nodeid",
          "mkdir",
          "getpathnode",
          "obj",
          "pytest_warning_captured",
          "FunctionMixin",
          "_import_plugin_specs",
          "_given_basetemp",
          "YIELD_TESTS",
          "addSkip",
          "last_failed_paths",
          "add_global_property",
          "store_mark",
          "resultlog",
          "OutcomeException",
          "parseconfig",
          "_format_args",
          "_ensure_basetemp",
          "runpytest",
          "builtin_plugins",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "getlocals",
          "_getnextfixturedef",
          "_get_allow_unicode_flag",
          "check_interactive_exception",
          "id",
          "getitems",
          "pastebin",
          "capsys",
          "NFPlugin",
          "approx",
          "RN",
          "deselect_by_keyword",
          "_early_rewrite_bailout",
          "_get_increasing_order",
          "_collect",
          "safeformat",
          "_determine_show_progress_info",
          "pytest_sessionstart",
          "writeorg",
          "_translate_non_printable",
          "cleanup_numbered_dir",
          "is_rewrite_disabled",
          "_get_plugin_specs_as_list",
          "_rewrite_test",
          "_assertion_supported",
          "consider_module",
          "Failed",
          "_ensure_supporting_files",
          "pathlib",
          "terminal",
          "PytestPluginManager",
          "buffer",
          "pytest_runtest_call",
          "TEST_OUTCOME",
          "_compilecounter",
          "suspend_global_capture",
          "SysCaptureBinary",
          "get_lines_after",
          "pytest_internalerror",
          "pytestPDB",
          "runtest",
          "getrawcode",
          "__str__",
          "Exit",
          "getlocation",
          "UsageError",
          "SetupState",
          "_ensure_only_one_capture_fixture",
          "RE_IMPORT_ERROR_NAME",
          "match",
          "write_ensure_prefix",
          "_check_scope",
          "pytester",
          "_inject_setup_method_fixture",
          "EXIT_NOTESTSCOLLECTED",
          "_is_capturing",
          "Session",
          "activate_fixture",
          "setenv",
          "IGNORE_PAM",
          "getexplanation",
          "_call_and_format_exception",
          "pytest_report_collectionfinish",
          "classnamefilter",
          "args",
          "assign",
          "get_plugin_manager",
          "MultipleDoctestFailures",
          "showlongtestinfo",
          "ReprLocals",
          "is_package",
          "_matchnodes",
          "get_location",
          "_bestrelpath_cache",
          "NOTSET",
          "excinfo",
          "UnitTestCase",
          "fnmatch_lines_random",
          "LsofFdLeakChecker",
          "CallSpec2",
          "_iter_rewritable_modules",
          "raises",
          "_write_progress_information_filling_space",
          "addFailure",
          "cut",
          "readlines",
          "records",
          "pytest_assertrepr_compare",
          "getcrashentry",
          "_runtest_for_main",
          "pytest_enter_pdb",
          "collect_one_node",
          "Module",
          "consider_conftest",
          "compile",
          "_config_for_test",
          "notset",
          "runpython_c",
          "pytest_pycollect_makeitem",
          "from_item",
          "frame",
          "getargs",
          "pytest_collectstart",
          "_checkversion",
          "set_when",
          "FDCapture",
          "_force_symlink",
          "countoutcomes",
          "scope",
          "CaptureIO",
          "__test__",
          "compile_",
          "_LiveLoggingStreamHandler",
          "_init_runner_class",
          "ApproxBase",
          "_reprcompare",
          "_validate_usepdb_cls",
          "pytest_collection_modifyitems",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "getfixturevalue",
          "_make_xunit_fixture",
          "isdatacls",
          "pytest_collect_directory",
          "ExceptionRepr",
          "_getconftestmodules",
          "nofuncargs",
          "re_match_lines_random",
          "_matches_prefix_or_glob_option",
          "get_common_ancestor",
          "pop_format_context",
          "scope2index",
          "pytest_report_teststatus",
          "ReprFailDoctest",
          "PytestCollectionWarning",
          "NodeMarkers",
          "_collectfile",
          "_dump_lines",
          "fix_cache_order",
          "CollectErrorRepr",
          "_for_parametrize",
          "_try_load_conftest",
          "SysModulesSnapshot",
          "rmtree",
          "SubRequest",
          "HelpAction",
          "type",
          "pytest_fixture_post_finalizer",
          "python",
          "stop_global_capturing",
          "build_summary_stats_line",
          "visit_Starred",
          "reports",
          "extract_from",
          "mktemp",
          "getreports",
          "initialnames",
          "matchnodes",
          "fileno",
          "families",
          "_format_assertmsg",
          "DEFAULT_RELATIVE_TOLERANCE",
          "isdict",
          "LogCaptureFixture",
          "fail",
          "_warn_already_imported",
          "context",
          "explanation_param",
          "mkpydir",
          "AssertionRewritingHook",
          "getoption",
          "from_call",
          "MoreQuietAction",
          "find_prefixed",
          "out",
          "_PytestWrapper",
          "listextrakeywords",
          "RemovedInPytest4Warning",
          "getstatement",
          "template",
          "N",
          "pytest_logwarning",
          "get_records",
          "maybe_delete_a_numbered_dir",
          "_getscopeitem",
          "popen",
          "pytest_collect_file",
          "conftest_options",
          "EXIT_OK",
          "getfixtureclosure",
          "readline",
          "Interrupted",
          "TracebackEntry",
          "pytest_runtest_protocol",
          "record_tuples",
          "istrue",
          "_teardown_towards",
          "summary_warnings",
          "_seen",
          "write_captured_output",
          "location",
          "_cachedir",
          "_resolve_arg_value_types",
          "done",
          "MarkMapping",
          "post_mortem",
          "pytest_deselected",
          "__version__",
          "_approx_scalar",
          "NodeKeywords",
          "__setitem__",
          "skip",
          "_add_simple",
          "cached_eval",
          "_is_marked_for_rewrite",
          "for_later",
          "_update_current_test_var",
          "record_xml_attribute",
          "SysCapture",
          "resolve_from_str",
          "PytestAssertRewriteWarning",
          "print_teardown_sections",
          "append_error",
          "_truncate_explanation",
          "writelines",
          "funcargnames",
          "_folded_skips",
          "statement",
          "start_capturing",
          "list",
          "pytest_plugin_registered",
          "line",
          "helpconfig",
          "MarkEvaluator",
          "re_match_lines",
          "_ALLOW_MARKERS",
          "close",
          "PytestConfigWarning",
          "format",
          "_do_configure",
          "get_open_files",
          "call_runtest_hook",
          "node_reporter",
          "pytest_generate_tests",
          "_py_ext_re",
          "compat",
          "_getentrysource",
          "doctest",
          "rex_outcome",
          "_tmppath_factory",
          "Function",
          "get_parametrized_fixture_keys",
          "tmpdir_factory",
          "PyobjMixin",
          "_getcrashline",
          "ReprExceptionInfo",
          "determine_setup",
          "caplog",
          "visit_Assert",
          "pytest_make_collect_report",
          "isparseable",
          "pytest_keyboard_interrupt",
          "getfuncargvalue",
          "patchsysdict",
          "syspathinsert",
          "scopes",
          "get_user",
          "parse_setoption",
          "BaseReport",
          "warning_record_to_str",
          "_getvaluepath",
          "_main",
          "simple",
          "File",
          "CwdSnapshot",
          "visit_BinOp",
          "Junit",
          "HookRecorder",
          "LineMatcher",
          "pytest_collection",
          "_setoption",
          "pytest_runtestloop",
          "_show_fixtures_per_test",
          "repr_instance",
          "show_test_item",
          "get_source",
          "getsource",
          "parse_known_and_unknown_args",
          "function",
          "_get_runner",
          "cleanup_candidates",
          "makefile",
          "setitem",
          "ApproxScalar",
          "start",
          "MODULE_NOT_FOUND_ERROR",
          "capture",
          "add_funcarg_pseudo_fixture_def",
          "_get_verbose_word",
          "_create_formatter",
          "set_session",
          "get_lock_path",
          "eval",
          "_version",
          "_start",
          "_typ_map",
          "_ensure_unconfigure",
          "__version_tuple__",
          "chdir",
          "_update_message",
          "_node_location_to_relpath",
          "runner",
          "readouterr",
          "_postmortem_traceback",
          "node",
          "_initini",
          "teardown_exact",
          "get_default_arg_names",
          "junitxml",
          "illegal_xml_re",
          "cls",
          "repr_args",
          "spawn",
          "ReprEntry",
          "_exec_lsof",
          "Instance",
          "ReprEntryNative",
          "keywords",
          "STRING_TYPES",
          "_report_unserialization_failure",
          "_outrep_summary",
          "_recursive_debug",
          "module",
          "ReprTraceback",
          "source",
          "resolve_fixture_function",
          "PyobjContext",
          "pytest_report_from_serializable",
          "pop_outerr_to_orig",
          "_log",
          "_showfixtures_main",
          "Class",
          "wrap_function_to_error_out_if_called_directly",
          "DEFAULT_MAX_LINES",
          "LEVELNAME_FMT_REGEX",
          "consider_preparse",
          "to_xml",
          "_pytest",
          "PytestExperimentalApiWarning",
          "__call__",
          "__nonzero__",
          "handler",
          "_truncate_recursive_traceback",
          "_repr_style",
          "update",
          "_width_of_current_line",
          "ensure_deletable",
          "applymarker",
          "_PLUGGY_DIR",
          "_pyfuncitem",
          "USAGE_MSG",
          "python_api",
          "repr_unicode",
          "_compare_eq_verbose",
          "prepare",
          "_import_pdb_cls",
          "TempdirFactory",
          "EXIT_INTERNALERROR",
          "formatrepr",
          "assert_contains",
          "XFailed",
          "summary_stats",
          "_callfinalizers",
          "errors",
          "head_line",
          "idmaker",
          "_inject_setup_class_fixture",
          "set_repr_style",
          "_parsearg",
          "_ANSI_ESCAPE_SEQ",
          "_getindent",
          "iter_markers_with_node",
          "display",
          "_callhelper",
          "Node",
          "_printcollecteditems",
          "pytest_runtest_logstart",
          "add_property",
          "MarkDecorator",
          "showlocals",
          "_sys_snapshot",
          "register_assert_rewrite",
          "warning_types",
          "directory_arg",
          "Package",
          "consider_env",
          "WARNS_EXEC",
          "get_fslocation_from_item",
          "_strtobool",
          "rewrite",
          "showheader",
          "_get_override_ini_value",
          "__repr__",
          "getini",
          "_inject_setup_function_fixture",
          "helper",
          "istestfunction",
          "deactivate_fixture",
          "parse",
          "_running_on_ci",
          "_basetemp",
          "FastFilesCompleter",
          "showversion",
          "gethookproxy",
          "indent",
          "__getitem__",
          "get_empty_parameterset_mark",
          "log_outcome",
          "EncodedFile",
          "ihook",
          "prune_dependency_tree",
          "_importtestmodule",
          "_get_checker",
          "warn_about_none_ast",
          "_match_lines_random",
          "get_optionflags",
          "LogXML",
          "Skipped",
          "_compare_eq_set",
          "_should_repr_global_name",
          "pytest_exception_interact",
          "TestReport",
          "_init_pdb",
          "_ConfigDeprecated",
          "MultiCapture",
          "yield_fixture",
          "_resolve_arg_ids",
          "kwargs",
          "nodeid",
          "TestCaseFunction",
          "get_exconly",
          "_preparse",
          "_mark_plugins_for_rewrite",
          "UnformattedWarning",
          "visit_Compare",
          "getfslineno",
          "reorder_items",
          "message",
          "__init__",
          "_issue_warning_captured",
          "visit_UnaryOp",
          "_is_numpy_array",
          "normalize_mark_list",
          "CFG_PYTEST_SECTION",
          "when",
          "_yield_comparisons",
          "_install_capture_fixture_on_item",
          "isatty",
          "catch_warnings_for_item",
          "params",
          "_check_type",
          "ApproxMapping",
          "Source",
          "pytest_addoption",
          "parse_args",
          "listchain",
          "get",
          "NoCapture",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "__all__",
          "listnames",
          "_finalize",
          "safe_text_dupfile",
          "cookie_re",
          "PYC_TAIL",
          "append",
          "hasopt",
          "getstatementrange_ast",
          "assert_contains_lines",
          "_set_opt_strings",
          "pytest_pycollect_makemodule",
          "_genfunctions",
          "Config",
          "_readline_workaround",
          "pyobj_property",
          "from_current",
          "bin_xml_escape",
          "tmp_path_factory",
          "_getpytestargs",
          "get_closest_marker",
          "isclass",
          "REPORT_COLLECTING_RESOLUTION",
          "__delitem__",
          "get_real_func",
          "SysPathsSnapshot",
          "_write_pyc",
          "_is_mocked",
          "_get_xunit_setup_teardown",
          "funcargs",
          "RaisesContext",
          "matchreport",
          "set_location",
          "essential_plugins",
          "parsefactories",
          "_should_rewrite",
          "prog",
          "update_testcase_duration",
          "DEFAULT_LOG_DATE_FORMAT",
          "linecomp",
          "pytest_collectreport",
          "mark_rewrite",
          "unittest",
          "FILE_OR_DIR",
          "_getparser",
          "_call_with_optional_argument",
          "generic_visit",
          "_getfailureheadline",
          "skipped",
          "CaptureResult",
          "capfdbinary",
          "abspath",
          "register_cleanup_lock_removal",
          "isfunction",
          "EMPTY_BUFFER",
          "pytest_itemstart",
          "FIXTURE_FUNCTION_CALL",
          "DOCTEST_REPORT_CHOICES",
          "addSuccess",
          "istext",
          "safe_getattr",
          "get_scope_node",
          "addError",
          "AssertionState",
          "raiseerror",
          "assertoutcome",
          "pytest_pyfunc_call",
          "ishidden",
          "_show_fixture_action",
          "NoMatch",
          "getmodulecol",
          "_getglobals",
          "_perform_collect",
          "getreportopt",
          "DummyRewriteHook",
          "_check_all_skipped",
          "cacheshow",
          "load_module",
          "pytest_configure",
          "copy_example",
          "find_module",
          "_check_initialpaths_for_relpath",
          "_recurse",
          "WarningsRecorder",
          "xfail",
          "_getini",
          "_runtest_for",
          "logging",
          "_pop_and_teardown",
          "warn",
          "run",
          "hookspec",
          "Item",
          "report_collect",
          "spawn_pytest",
          "messages",
          "setall",
          "name2fixturedefs",
          "fslocation",
          "_state",
          "astcache",
          "addoption",
          "reportinfo",
          "finish_recording",
          "repr",
          "ReprTracebackNative",
          "inline_runsource",
          "fromdictargs",
          "_get_direct_parametrize_args",
          "check_strict_xfail",
          "cmdline",
          "unary_map",
          "annotated_getattr",
          "get_unpacked_marks",
          "runpytest_inprocess",
          "capstdout",
          "_resume",
          "getfixturedefs",
          "__array_ufunc__",
          "setupplan",
          "strip",
          "start_global_capturing",
          "PYTEST_ENSURETEMP",
          "pytest_leave_pdb",
          "_markers",
          "getparent",
          "_imp_find_module",
          "_idval",
          "PYTESTER_COPY_EXAMPLE",
          "FIXTURE_NAMED_REQUEST",
          "Traceback",
          "issequence",
          "safe_isclass",
          "deselect_by_mark",
          "get_scope_package",
          "GETFUNCARGVALUE",
          "scope2props",
          "ensure_reset_dir",
          "MarkGenerator",
          "ApproxSequencelike",
          "ExceptionChainRepr",
          "exconly",
          "SHOW_PYTEST_WARNINGS_ARG",
          "pytest_terminal_summary",
          "wrap_session",
          "LOGLEVEL_COLOROPTS",
          "delenv",
          "finish",
          "_in_venv",
          "collect_by_name",
          "repr_traceback",
          "getplugin",
          "showfixtures",
          "config",
          "getinicfg",
          "_get_pdb_wrapper_class",
          "binop_map",
          "add_cleanup",
          "assert_outcomes",
          "_colorama_workaround",
          "cached_result",
          "builtin",
          "warns",
          "addExpectedFailure",
          "_truncate_by_char_count",
          "record_property",
          "TimeoutExpired",
          "__enter__",
          "_idvalset",
          "newinstance",
          "getparam",
          "PrintHelp",
          "_makepath",
          "rewrite_asserts",
          "ensuretemp",
          "fillfixtures",
          "visit_Call",
          "DoctestTextfile",
          "showfspath",
          "recursionindex",
          "consider_pluginarg",
          "_parse_parametrize_parameters",
          "make_numbered_dir",
          "deprecated_call",
          "filter",
          "_saferepr",
          "_inject_setup_teardown_fixtures",
          "version_tuple",
          "defaultfuncargprefixmarker",
          "toterminal",
          "global_and_fixture_disabled",
          "repr_excinfo",
          "execute",
          "getfirstlinesource",
          "DEFAULT_MAX_CHARS",
          "inline_genitems",
          "DontReadFromInput",
          "write",
          "addsection",
          "pytest_unconfigure",
          "FixtureRequest",
          "findsource",
          "runpytest_subprocess",
          "delitem",
          "param",
          "_getlines",
          "getnode",
          "_PY_DIR",
          "with_args",
          "truncate_locals",
          "make_hook_recorder",
          "_factorytraceback",
          "PdbInvoke",
          "_rget_with_confmod",
          "exprinfo",
          "_test_pytest_function",
          "RunResult",
          "FixtureLookupError",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "visit_Attribute",
          "_bytes_to_ascii",
          "markname",
          "_getautousenames",
          "getdecoded",
          "_legal_xml_re",
          "skipping",
          "is_globally_capturing",
          "_non_printable_ascii_translate_table",
          "isnosetest",
          "find_suffixes",
          "copy",
          "pytest_addhooks",
          "make_properties_node",
          "CaptureFixture",
          "_py36_windowsconsoleio_workaround",
          "_code",
          "create_cleanup_lock",
          "write_line",
          "pytest_cmdline_main",
          "teardown_all",
          "LOCK_TIMEOUT",
          "_result",
          "_compare_eq_cls",
          "repr_traceback_entry",
          "_write_report_lines_from_hooks",
          "isinitpath",
          "_addfinalizer",
          "fspath",
          "set_level",
          "PytestArg",
          "collect",
          "_validate_if_using_arg_names",
          "is_generator",
          "PyCollector",
          "ReprFileLocation",
          "filename_arg",
          "SEP",
          "getfuncargnames",
          "call_optional",
          "get_statement_startend2",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "get_option_ini",
          "is_capturing",
          "from_item_and_call",
          "_striptext",
          "addUnexpectedSuccess",
          "resolve",
          "pytest_report_to_serializable",
          "ResultLog",
          "_cmp_raises_type_error",
          "pytest_runtest_setup",
          "isset",
          "getrepr",
          "PytestUnhandledCoroutineWarning",
          "version",
          "_getobj",
          "FixtureManager",
          "PytestCacheWarning",
          "_compare_eq_sequence",
          "scopename2class",
          "RAISES_EXEC",
          "_NodeReporter",
          "teardown_nose",
          "finalize",
          "runpython",
          "setuponly",
          "deprecated",
          "resume_global_capture",
          "scopeproperty",
          "REGEX_TYPE",
          "ensure_newline",
          "__take_sys_modules_snapshot",
          "import_plugin",
          "getcalls",
          "is_true",
          "makeini",
          "setup",
          "_parse_lsof_output",
          "getfixturemarker",
          "_argcomplete",
          "pytest_runtest_logfinish",
          "tmp_path",
          "addinivalue_line",
          "addfinalizer",
          "_find_parametrized_scope",
          "MARK_GEN",
          "write_log_entry",
          "_disable_output_capturing_for_darwin",
          "encoding",
          "setmulti2",
          "__hash__",
          "create_terminal_writer",
          "_iter_all_modules",
          "getvalueorskip",
          "RESULT_LOG",
          "TYPE_CHECKING",
          "filter_traceback",
          "getfailedcollections",
          "Frame",
          "for_config",
          "resume_fixture",
          "_wrapped_pdb_cls",
          "DEFAULT_LOG_FORMAT",
          "parametrize",
          "ReprFuncArgs",
          "_compare_eq_dict",
          "teardown",
          "__ne__",
          "EXIT_TESTSFAILED",
          "listoutcomes",
          "_get_report_choice",
          "ParsedCall",
          "_locationline",
          "passed",
          "MonkeyPatch",
          "register",
          "FuncFixtureInfo",
          "AssertionRewriter",
          "tbfilter",
          "install_importhook",
          "parseconfigure",
          "_addexcinfo",
          "__array_priority__",
          "saferepr",
          "getmodpath",
          "stopTest",
          "read",
          "__next__",
          "showhelp",
          "getcfg",
          "runitem",
          "pytest_ignore_collect",
          "FuncargnamesCompatAttr",
          "gethookrecorder",
          "verbosity",
          "longreprtext",
          "mode",
          "append_pass",
          "is_potential_nosetest",
          "perform_collect",
          "FixtureFunctionMarker",
          "_notin_text",
          "capture_fixtures",
          "_prepareconfig",
          "try_cleanup",
          "mangle_test_address",
          "PYTEST_LOGWARNING",
          "_format_boolop",
          "PytestDeprecationWarning",
          "pytest_cmdline_parse",
          "_assert_start_repr",
          "monkeypatch",
          "_format_action_invocation",
          "set_trace",
          "argnames",
          "_log_text",
          "CollectReport",
          "WarningReport",
          "getimfunc",
          "add_stats",
          "FunctionDefinition",
          "_warn_about_missing_assertion",
          "genitems",
          "stop_capturing",
          "reorder_items_atscope",
          "section",
          "autouse",
          "_excinfo",
          "parseoutcomes",
          "matchmark",
          "_handle_skip",
          "relline",
          "pytest_sessionfinish",
          "Mark",
          "ischildnode",
          "_diff_text",
          "parse_num",
          "exec_",
          "_should_truncate_item",
          "main",
          "matchkeyword",
          "fail_marker",
          "read_global_capture",
          "FDCaptureBinary",
          "get_terminal_writer",
          "get_sections",
          "hasplugin",
          "_processopt",
          "pytest_doctest_prepare_content",
          "names_closure",
          "_parse_parametrize_args",
          "ApproxNumpy",
          "truncate_if_required",
          "__bool__",
          "_recursive_list_map",
          "style",
          "_get_pos",
          "write_sep",
          "repr_locals",
          "notify_exception",
          "DOCTEST_REPORT_CHOICE_NONE",
          "recwarn",
          "path",
          "_get_continue_on_failure",
          "__eq__",
          "scopemismatch",
          "resume_capturing",
          "nextitem",
          "_traceback",
          "parts",
          "add_report_section",
          "getcall",
          "set_log_path",
          "Entry",
          "README_CONTENT",
          "fail_fixturefunc",
          "pop",
          "item_capture",
          "_teardown_yield_fixture",
          "_makeitem",
          "isiterable",
          "Testdir",
          "names",
          "_get_active_fixturedef",
          "__len__",
          "call_fixture_func",
          "addini",
          "pytest_report_header",
          "_checkargnotcontained",
          "DoctestModule",
          "name",
          "getgroup",
          "_get_allow_bytes_flag",
          "make_numbered_dir_with_cleanup",
          "alias",
          "mark",
          "startTest",
          "CaptureManager",
          "suspend_fixture",
          "dummy_context_manager",
          "suspend_capturing",
          "get_data",
          "add_marker",
          "_format_lines",
          "_addoption",
          "popcall",
          "_warn_incompatibility_with_xunit2",
          "wasvalid",
          "PYC_EXT",
          "tmpdir",
          "nose",
          "tb",
          "FixtureDef",
          "write_docstring",
          "istestclass",
          "session",
          "PdbTrace",
          "_makefile",
          "_io",
          "_compute_fixture_value",
          "_pluginmanager",
          "_importconftest",
          "debugging",
          "DropShorterLongHelpFormatter",
          "append_failure",
          "exc_clear",
          "importorskip",
          "testdir",
          "getslaveinfoline",
          "RAISES_MESSAGE_PARAMETER",
          "deindent",
          "_setup_cli_logging",
          "pytest_collection_finish",
          "funcnamefilter",
          "pytest_load_initial_conftests",
          "undo",
          "SafeRepr",
          "pytest_cmdline_preparse",
          "_get_progress_information_message",
          "getstatementrange",
          "repr_failure",
          "default_plugins",
          "_setup_collect_fakemodule",
          "_istrue",
          "_remove_ansi_escape_sequences",
          "from_config",
          "_schedule_finalizers",
          "setattr",
          "hasinit",
          "_getconftest_pathlist",
          "hookimpl",
          "nodes",
          "_initrequest",
          "_legal_chars",
          "FixtureLookupErrorRepr",
          "check_xfail_no_run",
          "parse_hookimpl_opts",
          "flow_marker",
          "tracebackcutdir",
          "OptionGroup",
          "reset",
          "_testcase",
          "FSCollector",
          "LFPlugin",
          "_repr_failure_py",
          "hasnew",
          "own_markers",
          "format_explanation",
          "visit_BoolOp",
          "getitem",
          "cache_dir_from_config",
          "BOM_UTF8",
          "capstderr",
          "get_dirs_from_args",
          "_set_initial_conftests",
          "_split_explanation",
          "_suspend",
          "iter_markers",
          "_get_fixturestack",
          "disabled",
          "addhooks",
          "chain",
          "capsysbinary",
          "syspath_prepend",
          "getfailures",
          "inline_run",
          "_report_keyboardinterrupt",
          "TerminalRepr",
          "path_matches_patterns",
          "snap",
          "_mk_tmp",
          "FormattedExcinfo",
          "record_testreport",
          "warnings",
          "PseudoFixtureDef",
          "EXIT_INTERRUPTED",
          "matching_platform",
          "pytest_itemcollected",
          "stepwise",
          "record_testsuite_property",
          "TerminalReporter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "ArgumentError",
          "_legal_ranges",
          "call_and_report",
          "_addoption_instance",
          "freeze_support",
          "KeywordMapping",
          "_config",
          "_get_line_with_reprcrash_message",
          "_inject_setup_module_fixture",
          "fnmatch_ex",
          "variable",
          "get_real_method",
          "CollectError",
          "Code",
          "_to_json",
          "LoggingPlugin",
          "ColoredLevelFormatter",
          "Collector",
          "merge_family",
          "_getcapture",
          "scopenum_function",
          "__setattr__",
          "PYTEST_CONFIG_GLOBAL",
          "suspend",
          "PercentStyleMultiline",
          "restore",
          "_opentestcase",
          "doctest_namespace",
          "append_skipped",
          "WarningsChecker",
          "StepwisePlugin",
          "get_actual_log_level",
          "_setup_fixtures",
          "pytest_runtest_makereport",
          "get_public_names",
          "get_config",
          "LineMatcher_fixture",
          "ParameterSet",
          "DoctestItem",
          "EXIT_USAGEERROR",
          "locals",
          "_get_non_fixture_func",
          "instance",
          "_tryconvertpyarg",
          "_log_cli_enabled",
          "catching_logs",
          "CACHEDIR_TAG_CONTENT",
          "_get_flag_lookup",
          "resume",
          "tolerance",
          "_get_marks",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "__iter__",
          "__getattr__",
          "_enter_pdb",
          "__exit__",
          "co_equal",
          "Metafunc",
          "PytestUnknownMarkWarning",
          "BASE_TYPE",
          "set",
          "entrysep",
          "errisinstance",
          "_patch_unwrap_mock_aware",
          "invalidraise",
          "setns",
          "_getreprcrash",
          "_splitnode",
          "result",
          "pytest_runtest_logreport",
          "Parser",
          "istestfunc",
          "outcomes",
          "iscoroutinefunction",
          "combined_with",
          "fixtures",
          "fullsource",
          "_from_json",
          "get_skip_exceptions",
          "LineComp",
          "at_level",
          "assertrepr_compare",
          "show_fixtures_per_test",
          "failed",
          "EMPTY_PARAMETERSET_OPTION",
          "_call_reprcompare",
          "MyOptionParser",
          "TempPathFactory",
          "getbasetemp",
          "clear",
          "__module__",
          "_teardown_with_finalization",
          "value",
          "error",
          "pytest_make_parametrize_id",
          "ApproxDecimal",
          "putaround",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "_ascii_escaped_by_config",
          "_prunetraceback",
          "ExceptionInfo",
          "emit",
          "RUNNER_CLASS",
          "pytest_fixture_setup",
          "_match_lines",
          "count_towards_summary",
          "isattrs",
          "Notset",
          "maketxtfile",
          "parse_known_args",
          "makeconftest",
          "derive_importpath",
          "str",
          "_PYTEST_DIR",
          "num_mock_patch_args",
          "stop",
          "exists",
          "runtestprotocol",
          "category",
          "pytestconfig",
          "_fillfixtures",
          "fixture",
          "check_testcase_implements_trial_reporter",
          "ascii_escaped",
          "add_attribute",
          "_visit_filter",
          "getvalue",
          "_get_global_properties_node",
          "FSHookProxy",
          "_is_setup_py",
          "_matchfactories",
          "freeze_includes",
          "own_mark_names",
          "create_new_paste",
          "text",
          "pytest_runtest_teardown",
          "parse_hookspec_opts",
          "PytestWarning",
          "_trace",
          "__missing__",
          "short_test_summary",
          "_ensure_immutable_ids",
          "ConftestImportFailure",
          "get_direct_param_fixture_func",
          "_saved",
          "Argument",
          "capfd",
          "makedir",
          "_non_numeric_type_error",
          "cache",
          "_ensure_removed_sysmodule",
          "getfixtureinfo",
          "_check_record_param_type",
          "assertion",
          "attrs",
          "_is_doctest",
          "_compare_eq_iterable",
          "python_keywords_allowed_list",
          "makepyfile"
        ]
      },
      "response": {
        "keywords": [
          "raises",
          "excinfo",
          "pytest",
          "pytest_warning_captured",
          "raises",
          "Function",
          "Session",
          "CallInfo",
          "raises",
          "decorator"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:33:52.341971",
        "usage": "233.78896713256836 ms"
      },
      "request": {
        "tokens": [
          "raises",
          "excinfo",
          "pytest",
          "pytest_warning_captured",
          "raises",
          "Function",
          "Session",
          "CallInfo",
          "raises",
          "decorator"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/compat.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/pytest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/main.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/stepwise.py"
          ],
          "pytest_warning_captured": [
            "src/_pytest/deprecated.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/warnings.py",
            "src/_pytest/terminal.py"
          ],
          "excinfo": [
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/capture.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/python.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/skipping.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py",
            "src/_pytest/nose.py"
          ],
          "CallInfo": [
            "src/_pytest/hookspec.py",
            "src/_pytest/nose.py",
            "src/_pytest/runner.py"
          ],
          "raises": [
            "src/_pytest/deprecated.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/pytest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/skipping.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "Function": [
            "src/_pytest/_argcomplete.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/unittest.py",
            "src/pytest.py",
            "src/_pytest/python.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/nose.py",
            "src/_pytest/compat.py"
          ],
          "Session": [
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py",
            "src/pytest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/pytester.py",
            "src/_pytest/compat.py"
          ],
          "decorator": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/compat.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:33:52.575770",
        "usage": "9884.683847427368 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/compat.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/pytest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/main.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/stepwise.py"
          ],
          "pytest_warning_captured": [
            "src/_pytest/deprecated.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/warnings.py",
            "src/_pytest/terminal.py"
          ],
          "excinfo": [
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/capture.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/python.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/skipping.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py",
            "src/_pytest/nose.py"
          ],
          "CallInfo": [
            "src/_pytest/hookspec.py",
            "src/_pytest/nose.py",
            "src/_pytest/runner.py"
          ],
          "raises": [
            "src/_pytest/deprecated.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/pytest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/skipping.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "Function": [
            "src/_pytest/_argcomplete.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/unittest.py",
            "src/pytest.py",
            "src/_pytest/python.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/nose.py",
            "src/_pytest/compat.py"
          ],
          "Session": [
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py",
            "src/pytest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/pytester.py",
            "src/_pytest/compat.py"
          ],
          "decorator": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/compat.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue at hand is about the behavior of the `pytest.raises` context manager and its interaction with string representations of exceptions that differ from the usual `try-except` block in Python. We need to find where this behavior is documented or implemented.\n\nGiven keywords are:\n\n1. **pytest** - This is the main library involved, but it gives a large number of unrelated files.\n\n2. **pytest_warning_captured** - Not directly related to our issue about exception handling.\n\n3. **excinfo** - This could be relevant because `excinfo` carries exception related information and could be involved in altering how exceptions are represented in pytest.\n\n4. **CallInfo** - While related to pytest's internal call structure, it doesn't seem directly relevant to the described issue of exception representation.\n\n5. **raises** - This is the most relevant keyword since it's directly related to the issue with `pytest.raises`. Files containing this keyword will likely contain the logic or documentation pertinent to the behavior of `pytest.raises`.\n\nCombining this analysis, the most relevant files are likely:\n- `src/_pytest/python_api.py`: This is likely where the `raises` context manager is implemented or defined.\n- `src/_pytest/_code/code.py`: Often files dealing with code or internal pytest handling might address exception information storage.\n- `src/_pytest/doctest.py`: If doctest interaction covers `raises`, this could be relevant.\n\nAdditional consideration for:\n- `src/_pytest/assertion/rewrite.py`: This might rewrite assertions and affect `raises` behavior.\n- `src/_pytest/debugging.py`: Might contain debugging utilities that relate to exception handling.\n- `src/pytest.py`: The root file often has important imports and might provide use-case implementations.",
        "file_paths": [
          "src/_pytest/python_api.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/debugging.py",
          "src/_pytest/doctest.py",
          "src/pytest.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:02.460470",
        "usage": "7558.987140655518 ms"
      },
      "request": {
        "file_path": "src/_pytest/python_api.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue with the way pytest.raises context manager is handling exception objects compared to a regular try-except block in Python.\n1.2 Reproduction steps were provided:\n   - Regular try-except prints the correct exception message when str(e) is called.\n   - pytest.raises context manager requires str(e.value) to get the full message.\n   - This is because pytest.raises sets e to an ExceptionInfo object, which behaves differently.\n1.3 The cause of the issue is that pytest.raises returns an ExceptionInfo object, but str() is called directly on this object instead of on the value attribute containing the actual exception. This is different from Python's usual exception handling, where e directly captures the raised exception.\n1.4 User expectation is to have consistent behavior between pytest.raises and the traditional try-except block so there's no need to access `e.value` separately to get the full error message.\n1.5 The discrepancy lies in the behavior of ExceptionInfo.\n1.6 Possible solutions might include adjusting the documentation to make users aware or integrating a more intuitive access directly via `str()` on the context variable itself when using pytest.\n\n2. Make file evaluation:\n2.1 Analyzing the code related to pytest.raises and how it constructs the RaisesContext and ExceptionInfo.\n2.2 The RaisesContext class and its `__enter__` and `__exit__` methods are directly relevant because they explain that an ExceptionInfo object is returned.\n2.3 The behavior difference stems from how ExceptionInfo objects are being returned on the context manager and used.\n2.4 The exception information is accessed differently compared to standard exceptions.\n2.5 There might be relevant methods within the ExceptionInfo implementation elsewhere in the code base. RaisesContext essentially returns this.\n2.6 This file points to raises as being related, but an actual adjustment might need to be done in the ExceptionInfo implementation to change str() behavior explicitly.\n\nOverall, identifies that RaisesContext and ExceptionInfo usage creates the difference between typical exception handling and pytest.raises.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_code/code.py"
        ],
        "relevant_symbols": [
          "raises",
          "RaisesContext"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:10.019471",
        "usage": "8878.912687301636 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/code.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the issue:**\n   - The issue is about a difference in behavior when accessing the exception message in a `pytest.raises` context manager compared to a regular `try...except` block in Python. \n   - In a `try...except` block, calling `str(e)` on the exception object results in the full exception message being printed.\n   - In contrast, when using `pytest.raises`, calling `str(e)` on the context variable returns a string representing the context manager but not the exception's full message. To get the full message, one must use `str(e.value)`.\n\n2. **User concerns and expectation:**\n   - The user expects `str(e)` to behave similarly in both contexts for consistency and possibly a more intuitive use.\n   - The use pattern in `pytest` introduces a 'gotcha', necessitating users to understand that they need to access the `.value` attribute on the context manager object.\n\n3. **Analysis of `code.py` file for relevance:**\n   - The file `code.py` contains classes and methods related to exception and traceback handling in pytest. \n   - The `ExceptionInfo` class wraps exception information and provides interface methods like `__str__`, `exconly`, and `match` which might influence how exception messages are represented or accessed.\n   - The `__str__` method of `ExceptionInfo` curtails information when `_excinfo` is None, returning a less informative string.\n   - The property methods for accessing exception information (`value`, `type`, `traceback`) are relevant since accessing `str(e)` defaults to these properties.\n\n4. **Hypothesis on potential cause:**\n   - It is likely the `__str__()` implementation of `ExceptionInfo` is not designed to match the default `str(exception)` behavior of Python exceptions, resulting in confusion.\n\n5. **Relevant components in the file:**\n   - The `ExceptionInfo` class is critical because it encapsulates exception-related data which relates directly to the issue described.\n   - `ExceptionInfo.__str__()` method is pivotal in providing the string representation.\n   - The properties `value` and `exconly` may also contribute due to how they format or relay exception data.\n\n6. **Conclusion:**\n   - This file is relevant, as it has the `ExceptionInfo` class that directly contributes to how exceptions are being handled and displayed in pytest, which is where the issue lies. While it may not directly \"cause\" the behavior, it is critical to resolving or addressing user concerns through potential modifications.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [],
        "relevant_symbols": [
          "ExceptionInfo",
          "ExceptionInfo.__str__",
          "ExceptionInfo.value",
          "ExceptionInfo.exconly"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:18.898397",
        "usage": "7601.672887802124 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/rewrite.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is about the difference in behavior of the `str()` function on the exception object captured by `pytest.raises` compared to a typical try-except block. The user notes that when using `pytest.raises`, `str(e)` only gives part of the information unless `str(e.value)` is used, which is documented but inconsistent with expected behavior.\n1.2 The user provides reproduction steps with two Python code snippets to highlight the difference in outputs when using `pytest.raises` vs a normal exception catch.\n1.3 This behavior is caused by how pytest handles exceptions in its `raises` context. It stores the exception instance in `e.value` rather than just in `e`, which is the object that `str()` would directly operate on.\n1.4 The user's expectation is that `str(e)` should directly give the complete error message, just like a normal `except` block.\n1.5 Possible solutions could involve modifying how `pytest.raises` structures its context object or providing additional documentation on this behavior.\n\n2. Make file evaluation:\n2.1 The provided file `src/_pytest/assertion/rewrite.py` is related to rewriting assertions for better error messages, which is indirectly connected to error handling and message formatting.\n2.2 The provided file does not explicitly deal with `pytest.raises` directly nor does it handle the storage of exception objects relevant to this issue.\n2.3 The file's functions are related to assertion rewriting, error messaging but not directly handling exceptions from `pytest.raises`.\n\nDecision: The file is not directly relevant to the issue with `pytest.raises` context behavior since it focuses on assertion rewriting. The root cause likely lies elsewhere, particularly in the part of pytest that implements the `raises` context manager or exception handling modules. I suggest looking into files related to exception handling within pytest, possibly within `pytest.raises` related files.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/raises.py",
          "src/_pytest/_code/code.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:26.500091",
        "usage": "7666.158199310303 ms"
      },
      "request": {
        "file_path": "src/_pytest/debugging.py"
      },
      "response": {
        "scratch_pad": "### Analyze User Instructions\n1. The user reports that converting the `pytest.raises` context variable to a string using `str()` does not work the same way as it does for a normal exception catch. In the normal exception catch, `str(e)` gives the full multi-line error message, whereas with `pytest.raises`, `str(e)` only provides a single-line message.\n2. To reproduce, the user sets up two code snippets to raise an exception and prints the exception messages using `str(e)`.\n3. The discrepancy is due to the fact that `pytest.raises` has a different API and `e` in this context is not a standard exception object but a `ExceptionInfo` object where the actual exception is stored in `e.value`.\n4. The user expects `str()` to behave similarly in both scenarios without requiring additional knowledge or changes to use `e.value`.\n5. This could potentially be solved by modifying `ExceptionInfo` or its interface to mimic normal exception handling more closely.\n\n### Make File Evaluation\n1. The file `src/_pytest/debugging.py` mainly deals with debugging, configuring pdb integration, and seems to focus on managing debugger settings and debug states, using classes like `pytestPDB`, `PdbInvoke`, etc. \n2. There are no explicit references to `pytest.raises` or how exceptions are handled in tests, suggesting this might not be directly related to the way `pytest.raises` handles exceptions.\n3. The core issue might be more related to the `raises` or `ExceptionInfo` handling part of pytest instead of this debugging configuration, pointing towards this not being the root cause.\n\n### Determine Relevance\n1. The file seems relevant in the larger context of pytest's exception handling ecosystem, as debugging can sometimes overlap with exception information handling.\n2. However, the main logic around `pytest.raises` and `ExceptionInfo` is not pinpointed here. No clear symbols directly corresponding to the issue were identified.\n\n### Conclusion\nThis file is related in context (debugging), but it is not directly the root cause of the reported issue. It does not handle `ExceptionInfo` formatting directly.\n\n### Relevant Files Suggestion\n- src/_pytest/raises.py (likely contains the `raises` and `ExceptionInfo` logic)\n- src/_pytest/_code/code.py (might handle exception info formatting or wrappers)\n- src/_pytest/main.py (general entry points and execution management)",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/raises.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:34.166290",
        "usage": "12589.969158172607 ms"
      },
      "request": {
        "file_path": "src/_pytest/doctest.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue**: \n   - The issue describes a divergence in behavior when using the `pytest.raises` context manager versus a typical try-except block to capture and print exceptions. Specifically, when an exception is captured using `pytest.raises`, the context variable `e` does not behave like a standard exception object. Instead, calling `str(e)` does not give the full error message, it just gives a brief summary.\n   - This problem seems to be part of the design of how `pytest.raises` context manager works. While the standard Python `try-except` block captures the exception directly allowing `str(e)` to function normally, `pytest.raises` stores the exception into the `.value` attribute, thus requiring `str(e.value)` to access the full message.\n   \n2. **File Analysis**:\n   - The file `src/_pytest/doctest.py` contains code related to the pytest testing framework, particularly for handling doctest modules and textfiles.\n   - Upon inspection, the file involves options and utilities for collecting and running doctests, setting up options, handling failures, and other test-related functionality. \n   - It utilizes custom exception handling via classes like `ReprFailDoctest`, `MultipleDoctestFailures`, and others.\n   \n   - There is not a direct handling of `pytest.raises` or its context variable within this file. The file is more related to handling and collecting doctests rather than the inner workings of `pytest.raises` or how exceptions are printed.\n   - The functions and classes here focus on running and reporting doctests using doctest's custom runner and related utilities rather than general exception context management.\n   \n3. **Decision**:\n   - There are no classes, or functions directly specifying how `pytest.raises` stores or handles its exception information or context variable, meaning this file is not part of the root cause for the issue stated in the report, focusing instead on another aspect of pytest.\n   - Therefore, this file is not directly relevant to the user's problem.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/main.py",
          "src/_pytest/fixtures.py",
          "src/_pytest/runners.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:46.756278",
        "usage": "6252.970933914185 ms"
      },
      "request": {
        "file_path": "src/pytest.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the User's Issue:\n1.1 The user reports that when catching an exception with `pytest.raises`, the string representation of the context variable `e` behaves differently than a normal exception block. Normally, `str(e)` should print the exception message, but with pytest's `raises`, `str(e)` doesn't give the expected result; `str(e.value)` is needed instead.\n1.2 The user provides a clear comparison between normal exception handling and using `pytest.raises`. This indicates that there's a discrepancy in how the `pytext.raises` context manager stores the exception.\n1.3 The issue seems to be caused by the fact that the `pytest.raises` context manager wraps exceptions differently, storing the actual exception in an `e.value` attribute, leading to confusion since `str(e)` doesn't return the exception message directly.\n1.4 User expects consistency between traditional exception handling and pytest's handling to avoid confusion.\n\n2. Evaluating the File Content:\n2.1 The provided file is `src/pytest.py`. This file primarily imports various components from submodules but does not directly define the behavior of the `raises` context manager.\n2.2 the file imports `raises` from `_pytest.python_api`.\n2.3 There's no direct implementation of the `raises` function in this file; hence, it is not directly relevant to modifying or understanding the behavior of `pytest.raises`.\n\nSince there is no specific code related to the `raises` context manager implementation, this file does not contain the root cause or directly implement functionality related to the issue.\n\n3. Conclusion:\n- This file is not the root cause of the issue. The implementation of `raises` is not located in this file.\n- To find the root cause, searching within `_pytest/python_api` for the definition of the `raises` context manager would be necessary.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/python_api.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:34:53.009277",
        "usage": "94.35009956359863 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/python_api.py",
            "relevant_symbol_keys": [
              "raises",
              "RaisesContext"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/_code/code.py",
            "relevant_symbol_keys": [
              "ExceptionInfo",
              "ExceptionInfo.__str__",
              "ExceptionInfo.value",
              "ExceptionInfo.exconly"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/rewrite.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/debugging.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/doctest.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/pytest.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 435,
            "start_column": 13339,
            "end_line": 4,
            "end_column": 13536,
            "start_byte": 13339,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": []
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:53.103633",
        "usage": "14210.072040557861 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 435,
            "start_column": 13339,
            "end_line": 4,
            "end_column": 13536,
            "start_byte": 13339,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": []
      },
      "response": {
        "scratch_pad": "1. Analyze the issue:\n- The issue is with the behavior of `pytest.raises` context variable compared to a standard try-except block. Specifically, `str(e)` on the context manager's variable doesn't return the full exception string but a concise error message instead.\n- This is seen as inconsistent since outside the context manager, calling `str()` on an exception gives the full error string.\n- The expected behavior is to have consistency, where `str()` should behave similarly inside and outside the `pytest.raises` context.\n\n2. Analyze the symbols:\n- `_pytest.python_api.raises` is the function that sets up the raising context, returning a `RaisesContext`.\n- `RaisesContext` class handles context manager interface, with `__enter__()` returning an `ExceptionInfo` instance (`self.excinfo`).\n- `ExceptionInfo` class encapsulates the exception information, and it seems `__str__()` is overridden here, returning the formatted representation involving traceback and exception message.\n- Inside `ExceptionInfo`, `__str__` and `exconly` methods seem involved in string conversion of exception info, possibly contributing to the concise output.\n\n3. Resolution step exploration:\n- The problematic output stems from `__str__` in `ExceptionInfo` not aligning with how Python's direct exception `__str__` representation works.\n- A potential change is modifying or adding to `__str__` method in `ExceptionInfo` to check if it should directly return `self.value`'s string conversion if the traceback isn't specifically requested.\n- Exploring this aligns `ExceptionInfo`'s behavior with the traditional exception handling model, providing the expected output.\n\nIn conclusion, changes are likely needed in `ExceptionInfo.__str__` or `exconly` to modify the string representation behavior to support full exception message display when `str()` is called.",
        "symbols": [
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "reason": "This symbol has an overridden __str__ method that processes the exception representation but doesn't directly mirror the usual behavior of str() on exceptions outside pytest. Modifying it could help fix the issue by making it concatenate full messages akin to default exception str."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "1. `_pytest.python_api._cmp_raises_type_error`: Not directly related to the issue of string conversion, this function deals with type errors for comparisons.\n\n2. `_pytest.python_api.raises`: Relevant because it sets up the context where the `RaisesContext` and subsequently, `ExceptionInfo` comes into play. However, it doesn't directly involve how str() behaves.\n\n3. `_pytest.python_api.RaisesContext`: This class is involved, with `__enter__` returning `ExceptionInfo`, the latter whose string behavior is questioned. However, `RaisesContext` itself doesn't handle the str logic.\n\n4. `_pytest.python_api.RaisesContext.__init__`, `__enter__`, and `__exit__`: These methods setup and exit the context but defer exception string representation handling to `ExceptionInfo`.\n\n5. `_pytest._code.ExceptionInfo`: Highly relevant as its __str__ method contributes to the behavior of str() on exceptions within pytest context managers.\n- `_excinfo` variable holds exception info used by __str__.\n\n6. `_pytest._code.ExceptionInfo.from_current`, `for_later`, `type`, `value`, `tb`, `typename`, `traceback`: \n  - These aren't directly about string conversion but are data-access methods that inform `ExceptionInfo` on what exception data is to be processed.\n\n7. `_pytest._code.ExceptionInfo.__str__`: Directly involved in the issue. The method involves custom representation of exceptions, not just `value` conversion, potentially causing the indirection that leads to this unintended behavior.\n\nThe above focus on `__str__` indicates the fix may involve adjustments here to align exception string conversion with typical Python expectations outside `pytest.raises`."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:35:07.313728",
        "usage": "1.44195556640625 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.python_api._cmp_raises_type_error",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
              "start_line": 22,
              "start_column": 496,
              "end_line": 0,
              "end_column": 951,
              "start_byte": 496,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.raises",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
              "start_line": 542,
              "start_column": 20241,
              "end_line": 0,
              "end_column": 26789,
              "start_byte": 20241,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.RaisesContext",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
              "start_line": 708,
              "start_column": 26828,
              "end_line": 0,
              "end_column": 27562,
              "start_byte": 26828,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.RaisesContext.__init__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
              "start_line": 709,
              "start_column": 26853,
              "end_line": 4,
              "end_column": 27062,
              "start_byte": 26853,
              "end_byte": 4
            },
            {
              "name": "_pytest.python_api.RaisesContext.__enter__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
              "start_line": 715,
              "start_column": 27068,
              "end_line": 4,
              "end_column": 27179,
              "start_byte": 27068,
              "end_byte": 4
            },
            {
              "name": "_pytest.python_api.RaisesContext.__exit__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
              "start_line": 719,
              "start_column": 27185,
              "end_line": 4,
              "end_column": 27562,
              "start_byte": 27185,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
              "start_line": 372,
              "start_column": 11617,
              "end_line": 0,
              "end_column": 17390,
              "start_byte": 11617,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionInfo._assert_start_repr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_assert_start_repr = \"AssertionError('assert \"",
              "start_line": 378,
              "start_column": 11762,
              "end_line": 4,
              "end_column": 11808,
              "start_byte": 11762,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_excinfo = attr.ib()",
              "start_line": 380,
              "start_column": 11814,
              "end_line": 4,
              "end_column": 11834,
              "start_byte": 11814,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._striptext",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_striptext = attr.ib(default=\"\")",
              "start_line": 381,
              "start_column": 11839,
              "end_line": 4,
              "end_column": 11871,
              "start_byte": 11839,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_traceback = attr.ib(default=None)",
              "start_line": 382,
              "start_column": 11876,
              "end_line": 4,
              "end_column": 11910,
              "start_byte": 11876,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_current",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
              "start_line": 384,
              "start_column": 11916,
              "end_line": 4,
              "end_column": 12782,
              "start_byte": 11916,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.for_later",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
              "start_line": 409,
              "start_column": 12788,
              "end_line": 4,
              "end_column": 12905,
              "start_byte": 12788,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.type",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
              "start_line": 415,
              "start_column": 12911,
              "end_line": 4,
              "end_column": 13006,
              "start_byte": 12911,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.value",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
              "start_line": 420,
              "start_column": 13012,
              "end_line": 4,
              "end_column": 13108,
              "start_byte": 13012,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.tb",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
              "start_line": 425,
              "start_column": 13114,
              "end_line": 4,
              "end_column": 13215,
              "start_byte": 13114,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.typename",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
              "start_line": 430,
              "start_column": 13221,
              "end_line": 4,
              "end_column": 13333,
              "start_byte": 13221,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
              "start_line": 435,
              "start_column": 13339,
              "end_line": 4,
              "end_column": 13536,
              "start_byte": 13339,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
              "start_line": 442,
              "start_column": 13542,
              "end_line": 4,
              "end_column": 13623,
              "start_byte": 13542,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__repr__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
              "start_line": 446,
              "start_column": 13629,
              "end_line": 4,
              "end_column": 13829,
              "start_byte": 13629,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.exconly",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
              "start_line": 451,
              "start_column": 13835,
              "end_line": 4,
              "end_column": 14454,
              "start_byte": 13835,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.errisinstance",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
              "start_line": 467,
              "start_column": 14460,
              "end_line": 4,
              "end_column": 14599,
              "start_byte": 14460,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._getreprcrash",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
              "start_line": 471,
              "start_column": 14605,
              "end_line": 4,
              "end_column": 14851,
              "start_byte": 14605,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
              "start_line": 477,
              "start_column": 14857,
              "end_line": 4,
              "end_column": 16613,
              "start_byte": 14857,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
              "start_line": 536,
              "start_column": 16619,
              "end_line": 4,
              "end_column": 16837,
              "start_byte": 16619,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.match",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
              "start_line": 543,
              "start_column": 16843,
              "end_line": 4,
              "end_column": 17390,
              "start_byte": 16843,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 850,
              "start_column": 28209,
              "end_line": 0,
              "end_column": 28507,
              "start_byte": 28209,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
              "start_line": 851,
              "start_column": 28253,
              "end_line": 4,
              "end_column": 28403,
              "start_byte": 28253,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 856,
              "start_column": 28409,
              "end_line": 4,
              "end_column": 28507,
              "start_byte": 28409,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": []
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze the issue:\n- The issue is with the behavior of `pytest.raises` context variable compared to a standard try-except block. Specifically, `str(e)` on the context manager's variable doesn't return the full exception string but a concise error message instead.\n- This is seen as inconsistent since outside the context manager, calling `str()` on an exception gives the full error string.\n- The expected behavior is to have consistency, where `str()` should behave similarly inside and outside the `pytest.raises` context.\n\n2. Analyze the symbols:\n- `_pytest.python_api.raises` is the function that sets up the raising context, returning a `RaisesContext`.\n- `RaisesContext` class handles context manager interface, with `__enter__()` returning an `ExceptionInfo` instance (`self.excinfo`).\n- `ExceptionInfo` class encapsulates the exception information, and it seems `__str__()` is overridden here, returning the formatted representation involving traceback and exception message.\n- Inside `ExceptionInfo`, `__str__` and `exconly` methods seem involved in string conversion of exception info, possibly contributing to the concise output.\n\n3. Resolution step exploration:\n- The problematic output stems from `__str__` in `ExceptionInfo` not aligning with how Python's direct exception `__str__` representation works.\n- A potential change is modifying or adding to `__str__` method in `ExceptionInfo` to check if it should directly return `self.value`'s string conversion if the traceback isn't specifically requested.\n- Exploring this aligns `ExceptionInfo`'s behavior with the traditional exception handling model, providing the expected output.\n\nIn conclusion, changes are likely needed in `ExceptionInfo.__str__` or `exconly` to modify the string representation behavior to support full exception message display when `str()` is called.",
          "symbols": [
            {
              "name": "_pytest._code.ExceptionInfo.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "reason": "This symbol has an overridden __str__ method that processes the exception representation but doesn't directly mirror the usual behavior of str() on exceptions outside pytest. Modifying it could help fix the issue by making it concatenate full messages akin to default exception str."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "1. `_pytest.python_api._cmp_raises_type_error`: Not directly related to the issue of string conversion, this function deals with type errors for comparisons.\n\n2. `_pytest.python_api.raises`: Relevant because it sets up the context where the `RaisesContext` and subsequently, `ExceptionInfo` comes into play. However, it doesn't directly involve how str() behaves.\n\n3. `_pytest.python_api.RaisesContext`: This class is involved, with `__enter__` returning `ExceptionInfo`, the latter whose string behavior is questioned. However, `RaisesContext` itself doesn't handle the str logic.\n\n4. `_pytest.python_api.RaisesContext.__init__`, `__enter__`, and `__exit__`: These methods setup and exit the context but defer exception string representation handling to `ExceptionInfo`.\n\n5. `_pytest._code.ExceptionInfo`: Highly relevant as its __str__ method contributes to the behavior of str() on exceptions within pytest context managers.\n- `_excinfo` variable holds exception info used by __str__.\n\n6. `_pytest._code.ExceptionInfo.from_current`, `for_later`, `type`, `value`, `tb`, `typename`, `traceback`: \n  - These aren't directly about string conversion but are data-access methods that inform `ExceptionInfo` on what exception data is to be processed.\n\n7. `_pytest._code.ExceptionInfo.__str__`: Directly involved in the issue. The method involves custom representation of exceptions, not just `value` conversion, potentially causing the indirection that leads to this unintended behavior.\n\nThe above focus on `__str__` indicates the fix may involve adjustments here to align exception string conversion with typical Python expectations outside `pytest.raises`."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/_code/code.py"
        ],
        "symbols": [
          "_pytest._code.ExceptionInfo.__str__"
        ],
        "code_spans": {
          "_pytest.python_api._cmp_raises_type_error": {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          "_pytest.python_api.raises": {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          "_pytest.python_api.RaisesContext": {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          "_pytest.python_api.RaisesContext.__init__": {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          "_pytest.python_api.RaisesContext.__enter__": {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          "_pytest.python_api.RaisesContext.__exit__": {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo": {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          "_pytest._code.ExceptionInfo._assert_start_repr": {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._excinfo": {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._striptext": {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._traceback": {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.from_current": {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.for_later": {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.type": {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.value": {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.tb": {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.typename": {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.traceback": {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__repr__": {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.exconly": {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.errisinstance": {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._getreprcrash": {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__str__": {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.match": {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo": {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          "_pytest._code.ReprExceptionInfo.__init__": {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo.toterminal": {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        }
      }
    }
  ]
}