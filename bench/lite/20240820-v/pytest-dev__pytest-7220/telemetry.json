{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7220",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:34:23.728501",
        "usage": "1769.4098949432373 ms"
      },
      "request": {
        "repo_tokens": [
          "summary_passes",
          "Cache",
          "summary_failures",
          "visit_Name",
          "fixturenames",
          "push_format_context",
          "extract_suffixes",
          "extraline",
          "processoption",
          "fnmatch_lines",
          "reprfileloc",
          "_fixturemanager",
          "LogCaptureHandler",
          "append_collect_error",
          "_read_pyc",
          "getpluginversioninfo",
          "typename",
          "cacheprovider",
          "summary_errors",
          "_plugin_nameversions",
          "ids",
          "append_collect_skipped",
          "exit",
          "traceback",
          "_consider_importhook",
          "_validate_args",
          "delattr",
          "CallInfo",
          "write_fspath_result",
          "CLOSE_STDIN",
          "cwd_relative_nodeid",
          "mkdir",
          "getpathnode",
          "obj",
          "pytest_warning_captured",
          "_import_plugin_specs",
          "plugins",
          "_given_basetemp",
          "addSkip",
          "add_global_property",
          "store_mark",
          "resultlog",
          "OutcomeException",
          "parseconfig",
          "_format_args",
          "_ensure_basetemp",
          "_surrounding_parens_on_own_lines",
          "runpytest",
          "builtin_plugins",
          "writer",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "_getnextfixturedef",
          "_get_allow_unicode_flag",
          "check_interactive_exception",
          "id",
          "reprtraceback",
          "getitems",
          "pastebin",
          "capsys",
          "NFPlugin",
          "approx",
          "store",
          "deselect_by_keyword",
          "_early_rewrite_bailout",
          "_get_increasing_order",
          "_collect",
          "safeformat",
          "_determine_show_progress_info",
          "pytest_sessionstart",
          "writeorg",
          "_translate_non_printable",
          "cleanup_numbered_dir",
          "is_rewrite_disabled",
          "_no_match_line",
          "_get_plugin_specs_as_list",
          "_rewrite_test",
          "_assertion_supported",
          "consider_module",
          "Failed",
          "_ensure_supporting_files",
          "pathlib",
          "terminal",
          "PytestPluginManager",
          "buffer",
          "pytest_runtest_call",
          "TEST_OUTCOME",
          "_compilecounter",
          "suspend_global_capture",
          "SysCaptureBinary",
          "get_lines_after",
          "pytest_internalerror",
          "pytestPDB",
          "runtest",
          "getrawcode",
          "__str__",
          "Exit",
          "getlocation",
          "UsageError",
          "SetupState",
          "RE_IMPORT_ERROR_NAME",
          "match",
          "write_ensure_prefix",
          "from_parent",
          "_check_scope",
          "pytester",
          "_inject_setup_method_fixture",
          "_is_capturing",
          "Session",
          "_write_pyc_fp",
          "activate_fixture",
          "stream",
          "setenv",
          "_F",
          "IGNORE_PAM",
          "getexplanation",
          "_esctable",
          "pytest_report_collectionfinish",
          "classnamefilter",
          "args",
          "assign",
          "get_plugin_manager",
          "MultipleDoctestFailures",
          "showlongtestinfo",
          "ReprLocals",
          "_matchnodes",
          "get_location",
          "_bestrelpath_cache",
          "expr",
          "catch_log_records_key",
          "NOTSET",
          "_ET",
          "excinfo",
          "_ensure_relative_to_basetemp",
          "UnitTestCase",
          "fnmatch_lines_random",
          "LsofFdLeakChecker",
          "CallSpec2",
          "_iter_rewritable_modules",
          "raises",
          "_write_progress_information_filling_space",
          "addFailure",
          "cut",
          "readlines",
          "records",
          "pytest_assertrepr_compare",
          "getcrashentry",
          "is_async_function",
          "pytest_enter_pdb",
          "collect_one_node",
          "Module",
          "consider_conftest",
          "compile",
          "_try_repr_or_str",
          "reprcrash",
          "_config_for_test",
          "notset",
          "runpython_c",
          "_CACHE_PREFIX_VALUES",
          "pytest_pycollect_makeitem",
          "from_item",
          "frame",
          "getargs",
          "pytest_collectstart",
          "_checkversion",
          "set_when",
          "FDCapture",
          "_force_symlink",
          "countoutcomes",
          "scope",
          "CaptureIO",
          "__test__",
          "compile_",
          "_LiveLoggingStreamHandler",
          "_init_runner_class",
          "LFPluginCollWrapper",
          "ApproxBase",
          "_reprcompare",
          "_validate_usepdb_cls",
          "pytest_collection_modifyitems",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_is_last_item",
          "getfixturevalue",
          "_make_xunit_fixture",
          "isdatacls",
          "_get_main_color",
          "pytest_collect_directory",
          "ExceptionRepr",
          "_getconftestmodules",
          "nofuncargs",
          "re_match_lines_random",
          "_matches_prefix_or_glob_option",
          "get_common_ancestor",
          "pop_format_context",
          "_color_for_type",
          "scope2index",
          "pytest_report_teststatus",
          "ReprFailDoctest",
          "PytestCollectionWarning",
          "_write_entry_lines",
          "NodeMeta",
          "_collectfile",
          "_dump_lines",
          "fix_cache_order",
          "CollectErrorRepr",
          "_for_parametrize",
          "_try_load_conftest",
          "SysModulesSnapshot",
          "fault_handler_stderr_key",
          "SubRequest",
          "_report_to_json",
          "HelpAction",
          "type",
          "pytest_fixture_post_finalizer",
          "python",
          "stop_global_capturing",
          "build_summary_stats_line",
          "visit_Starred",
          "reports",
          "extract_from",
          "Expression",
          "getreports",
          "mktemp",
          "initialnames",
          "matchnodes",
          "fileno",
          "families",
          "_format_assertmsg",
          "DEFAULT_RELATIVE_TOLERANCE",
          "isdict",
          "LogCaptureFixture",
          "fail",
          "_warn_already_imported",
          "context",
          "explanation_param",
          "mkpydir",
          "AssertionRewritingHook",
          "getoption",
          "from_call",
          "MoreQuietAction",
          "find_prefixed",
          "_PytestWrapper",
          "IDENT",
          "listextrakeywords",
          "getstatement",
          "template",
          "_AnyPurePath",
          "get_records",
          "maybe_delete_a_numbered_dir",
          "_call_assertion_pass",
          "_getscopeitem",
          "popen",
          "pytest_collect_file",
          "conftest_options",
          "getfixtureclosure",
          "readline",
          "Interrupted",
          "_has_param_ids",
          "_color_for_type_default",
          "TracebackEntry",
          "lines",
          "pytest_runtest_protocol",
          "record_tuples",
          "_assert_state",
          "istrue",
          "_teardown_towards",
          "summary_warnings",
          "_seen",
          "write_captured_output",
          "location",
          "_cachedir",
          "_resolve_arg_value_types",
          "done",
          "post_mortem",
          "pytest_deselected",
          "__version__",
          "_approx_scalar",
          "NodeKeywords",
          "__setitem__",
          "skip",
          "_add_simple",
          "cached_eval",
          "_is_marked_for_rewrite",
          "for_later",
          "_update_current_test_var",
          "record_xml_attribute",
          "SysCapture",
          "resolve_from_str",
          "PytestAssertRewriteWarning",
          "print_teardown_sections",
          "append_error",
          "_truncate_explanation",
          "funcargnames",
          "_folded_skips",
          "statement",
          "USAGE_ERROR",
          "start_capturing",
          "list",
          "_report_kwargs_from_json",
          "pytest_plugin_registered",
          "line",
          "helpconfig",
          "MarkEvaluator",
          "re_match_lines",
          "_write_content",
          "_ALLOW_MARKERS",
          "close",
          "PytestConfigWarning",
          "format",
          "_do_configure",
          "get_open_files",
          "call_runtest_hook",
          "node_reporter",
          "_get_stderr_fileno",
          "COLLECT_DIRECTORY_HOOK",
          "pytest_generate_tests",
          "_py_ext_re",
          "compat",
          "_getentrysource",
          "doctest",
          "rex_outcome",
          "_tmppath_factory",
          "Function",
          "get_parametrized_fixture_keys",
          "tmpdir_factory",
          "exec_module",
          "PyobjMixin",
          "ReprExceptionInfo",
          "_getcrashline",
          "determine_setup",
          "caplog",
          "UNARY_MAP",
          "visit_Assert",
          "isparseable",
          "pytest_make_collect_report",
          "pytest_keyboard_interrupt",
          "patchsysdict",
          "syspathinsert",
          "scopes",
          "get_user",
          "parse_setoption",
          "BaseReport",
          "warning_record_to_str",
          "_getvaluepath",
          "_main",
          "simple",
          "File",
          "CwdSnapshot",
          "visit_BinOp",
          "Junit",
          "HookRecorder",
          "LineMatcher",
          "pytest_collection",
          "console_main",
          "pytest_runtestloop",
          "_show_fixtures_per_test",
          "repr_instance",
          "show_test_item",
          "get_source",
          "getsource",
          "parse_known_and_unknown_args",
          "function",
          "_get_runner",
          "cleanup_candidates",
          "makefile",
          "setitem",
          "invocation_dir",
          "ApproxScalar",
          "start",
          "MODULE_NOT_FOUND_ERROR",
          "_handle_teardown_sections",
          "evalxfail_key",
          "capture",
          "add_funcarg_pseudo_fixture_def",
          "_expecting_failure",
          "_get_verbose_word",
          "_create_formatter",
          "set_session",
          "get_lock_path",
          "eval",
          "_version",
          "_start",
          "_typ_map",
          "_ensure_unconfigure",
          "__version_tuple__",
          "chdir",
          "_update_message",
          "_node_location_to_relpath",
          "runner",
          "readouterr",
          "_postmortem_traceback",
          "node",
          "_initini",
          "teardown_exact",
          "get_default_arg_names",
          "format_session_duration",
          "junitxml",
          "illegal_xml_re",
          "cls",
          "xml_key",
          "repr_args",
          "spawn",
          "ReprEntry",
          "_exec_lsof",
          "Instance",
          "__dir__",
          "ReprEntryNative",
          "keywords",
          "STRING_TYPES",
          "_report_unserialization_failure",
          "_outrep_summary",
          "dir",
          "_recursive_debug",
          "module",
          "ReprTraceback",
          "NOT",
          "source",
          "_check_if_assertion_pass_impl",
          "resolve_fixture_function",
          "_get_teardown_reports",
          "reprlocals",
          "pytest_report_from_serializable",
          "pop_outerr_to_orig",
          "_log",
          "_showfixtures_main",
          "Class",
          "async_warn_and_skip",
          "reject",
          "wrap_function_to_error_out_if_called_directly",
          "FILLFUNCARGS",
          "DEFAULT_MAX_LINES",
          "LEVELNAME_FMT_REGEX",
          "consider_preparse",
          "to_xml",
          "_pytest",
          "PytestExperimentalApiWarning",
          "__call__",
          "handler",
          "_assertion_pass",
          "_truncate_recursive_traceback",
          "_repr_style",
          "_width_of_current_line",
          "ensure_deletable",
          "applymarker",
          "_find_spec",
          "_PLUGGY_DIR",
          "_pyfuncitem",
          "USAGE_MSG",
          "python_api",
          "_compare_eq_verbose",
          "prepare",
          "_import_pdb_cls",
          "TempdirFactory",
          "formatrepr",
          "assert_contains",
          "XFailed",
          "summary_stats",
          "_callfinalizers",
          "head_line",
          "idmaker",
          "_inject_setup_class_fixture",
          "set_repr_style",
          "_parsearg",
          "_ANSI_ESCAPE_SEQ",
          "_getindent",
          "iter_markers_with_node",
          "display",
          "EOF",
          "Node",
          "_printcollecteditems",
          "pytest_runtest_logstart",
          "add_property",
          "MarkDecorator",
          "maybe_wrap_pytest_function_for_tracing",
          "showlocals",
          "set_fixture",
          "_sys_snapshot",
          "register_assert_rewrite",
          "warning_types",
          "faulthandler",
          "_get_assertion_exprs",
          "directory_arg",
          "Package",
          "consider_env",
          "CHECKER_CLASS",
          "get_fslocation_from_item",
          "_strtobool",
          "rewrite",
          "showheader",
          "_get_override_ini_value",
          "__repr__",
          "getini",
          "_inject_setup_function_fixture",
          "helper",
          "unset_fixture",
          "istestfunction",
          "deactivate_fixture",
          "parse",
          "_running_on_ci",
          "_basetemp",
          "FastFilesCompleter",
          "showversion",
          "gethookproxy",
          "indent",
          "__getitem__",
          "get_empty_parameterset_mark",
          "log_outcome",
          "EncodedFile",
          "ihook",
          "prune_dependency_tree",
          "_importtestmodule",
          "_get_checker",
          "_match_lines_random",
          "get_optionflags",
          "LogXML",
          "Skipped",
          "_set_main_color",
          "_compare_eq_set",
          "_is_skipped",
          "_should_repr_global_name",
          "pytest_exception_interact",
          "TestReport",
          "_init_pdb",
          "MultiCapture",
          "yield_fixture",
          "_resolve_arg_ids",
          "kwargs",
          "nodeid",
          "TestCaseFunction",
          "get_exconly",
          "get_last_failed_paths",
          "_preparse",
          "_mark_plugins_for_rewrite",
          "TokenType",
          "UnformattedWarning",
          "_parse_filter",
          "visit_Compare",
          "getfslineno",
          "reorder_items",
          "message",
          "__init__",
          "_issue_warning_captured",
          "visit_UnaryOp",
          "_is_numpy_array",
          "MINUS_K_COLON",
          "normalize_mark_list",
          "CFG_PYTEST_SECTION",
          "when",
          "_yield_comparisons",
          "isatty",
          "catch_warnings_for_item",
          "OK",
          "params",
          "_check_type",
          "ApproxMapping",
          "Source",
          "pytest_addoption",
          "parse_args",
          "pytest",
          "listchain",
          "get",
          "NoCapture",
          "_prepare_content",
          "__all__",
          "listnames",
          "_finalize",
          "duration",
          "PYC_TAIL",
          "append",
          "hasopt",
          "getstatementrange_ast",
          "assert_contains_lines",
          "fill_unfilled",
          "unexpectedsuccess_key",
          "_set_opt_strings",
          "pytest_pycollect_makemodule",
          "_genfunctions",
          "_format",
          "catch_log_handler_key",
          "Config",
          "_readline_workaround",
          "from_current",
          "bin_xml_escape",
          "tmp_path_factory",
          "clear_cache",
          "_getpytestargs",
          "get_closest_marker",
          "get_line_width",
          "NO_TESTS_COLLECTED",
          "longrepr",
          "REPORT_COLLECTING_RESOLUTION",
          "__delitem__",
          "get_real_func",
          "SysPathsSnapshot",
          "_is_mocked",
          "try_makedirs",
          "T",
          "funcargs",
          "get_log_level_for_setting",
          "RaisesContext",
          "_setupstate",
          "matchreport",
          "set_location",
          "essential_plugins",
          "parsefactories",
          "_should_rewrite",
          "prog",
          "update_testcase_duration",
          "DEFAULT_LOG_DATE_FORMAT",
          "linecomp",
          "pytest_collectreport",
          "mark_rewrite",
          "unittest",
          "FILE_OR_DIR",
          "_pformat_dispatch",
          "_getparser",
          "_call_with_optional_argument",
          "generic_visit",
          "_get_auto_indent",
          "ParseError",
          "_getfailureheadline",
          "skipped",
          "reprentries",
          "flush",
          "CaptureResult",
          "capfdbinary",
          "abspath",
          "register_cleanup_lock_removal",
          "find_spec",
          "EMPTY_BUFFER",
          "rm_rf",
          "NODE_USE_FROM_PARENT",
          "LPAREN",
          "DOCTEST_REPORT_CHOICES",
          "addSuccess",
          "old_mark_config_key",
          "istext",
          "safe_getattr",
          "get_scope_node",
          "addError",
          "AssertionState",
          "raiseerror",
          "assertoutcome",
          "pytest_pyfunc_call",
          "ishidden",
          "_show_fixture_action",
          "NoMatch",
          "getmodulecol",
          "_getglobals",
          "_perform_collect",
          "getreportopt",
          "DummyRewriteHook",
          "_check_all_skipped",
          "cacheshow",
          "Exception",
          "pytest_configure",
          "copy_example",
          "_check_initialpaths_for_relpath",
          "_recurse",
          "WarningsRecorder",
          "xfail",
          "_getini",
          "_runtest_for",
          "FakeCollectModule",
          "logging",
          "_highlight",
          "warn",
          "_pop_and_teardown",
          "run",
          "hookspec",
          "Item",
          "report_collect",
          "spawn_pytest",
          "messages",
          "name2fixturedefs",
          "fslocation",
          "_state",
          "ExitCode",
          "astcache",
          "addoption",
          "reportinfo",
          "finish_recording",
          "repr",
          "ReprTracebackNative",
          "inline_runsource",
          "fromdictargs",
          "_get_direct_parametrize_args",
          "check_strict_xfail",
          "cmdline",
          "annotated_getattr",
          "get_unpacked_marks",
          "runpytest_inprocess",
          "capstdout",
          "_resume",
          "getfixturedefs",
          "__array_ufunc__",
          "setupplan",
          "strip",
          "start_global_capturing",
          "pytest_leave_pdb",
          "_markers",
          "getparent",
          "_idval",
          "PYTESTER_COPY_EXAMPLE",
          "_with_exception",
          "Traceback",
          "issequence",
          "LFPluginCollSkipfiles",
          "safe_isclass",
          "deselect_by_mark",
          "get_scope_package",
          "scope2props",
          "ensure_reset_dir",
          "TerminalWriter",
          "MarkGenerator",
          "pastebinfile_key",
          "ApproxSequencelike",
          "ExceptionChainRepr",
          "exconly",
          "_assert_expr_to_lineno",
          "pytest_terminal_summary",
          "wrap_session",
          "LOGLEVEL_COLOROPTS",
          "delenv",
          "finish",
          "_in_venv",
          "collect_by_name",
          "repr_traceback",
          "getplugin",
          "showfixtures",
          "config",
          "getinicfg",
          "_get_pdb_wrapper_class",
          "add_cleanup",
          "assert_outcomes",
          "_colorama_workaround",
          "cached_result",
          "builtin",
          "warns",
          "addExpectedFailure",
          "_truncate_by_char_count",
          "record_property",
          "TimeoutExpired",
          "__enter__",
          "_idvalset",
          "_format_repr_exception",
          "newinstance",
          "getparam",
          "_PluggyPlugin",
          "PrintHelp",
          "_makepath",
          "rewrite_asserts",
          "fillfixtures",
          "INTERRUPTED",
          "visit_Call",
          "DoctestTextfile",
          "no_re_match_line",
          "showfspath",
          "recursionindex",
          "_get_number_flag",
          "_CACHE_PREFIX_DIRS",
          "consider_pluginarg",
          "_parse_parametrize_parameters",
          "make_numbered_dir",
          "deprecated_call",
          "filter",
          "_saferepr",
          "_inject_setup_teardown_fixtures",
          "version_tuple",
          "toterminal",
          "global_and_fixture_disabled",
          "repr_excinfo",
          "execute",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "create_module",
          "getfirstlinesource",
          "DEFAULT_MAX_CHARS",
          "inline_genitems",
          "_WithException",
          "DontReadFromInput",
          "write",
          "BINOP_MAP",
          "addsection",
          "pytest_unconfigure",
          "FixtureRequest",
          "findsource",
          "runpytest_subprocess",
          "delitem",
          "param",
          "_getlines",
          "getnode",
          "_PY_DIR",
          "with_args",
          "truncate_locals",
          "make_hook_recorder",
          "_factorytraceback",
          "Store",
          "PdbInvoke",
          "_rget_with_confmod",
          "exprinfo",
          "RunResult",
          "FixtureLookupError",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "TeeCaptureIO",
          "visit_Attribute",
          "_bytes_to_ascii",
          "markname",
          "_getautousenames",
          "_legal_xml_re",
          "InvocationParams",
          "skipping",
          "is_globally_capturing",
          "_non_printable_ascii_translate_table",
          "get_timeout_config_value",
          "PYTEST_TAG",
          "isnosetest",
          "find_suffixes",
          "copy",
          "pytest_addhooks",
          "_FileHandler",
          "make_properties_node",
          "CaptureFixture",
          "_py36_windowsconsoleio_workaround",
          "_code",
          "create_cleanup_lock",
          "no_fnmatch_line",
          "write_line",
          "pytest_cmdline_main",
          "teardown_all",
          "LOCK_TIMEOUT",
          "_result",
          "_compare_eq_cls",
          "KNOWN_TYPES",
          "sections",
          "assertstate_key",
          "repr_traceback_entry",
          "TERMINALWRITER_WRITER",
          "_write_report_lines_from_hooks",
          "isinitpath",
          "_addfinalizer",
          "fspath",
          "_fail",
          "set_level",
          "PytestArg",
          "_gethookproxy",
          "collect",
          "_validate_if_using_arg_names",
          "is_generator",
          "_names",
          "PyCollector",
          "ReprFileLocation",
          "filename_arg",
          "evaluate",
          "SEP",
          "getfuncargnames",
          "call_optional",
          "get_statement_startend2",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "get_option_ini",
          "is_capturing",
          "FaultHandlerHooks",
          "from_item_and_call",
          "_striptext",
          "addUnexpectedSuccess",
          "resolve",
          "pytest_report_to_serializable",
          "ResultLog",
          "and_expr",
          "wrap_pytest_function_for_tracing",
          "pytest_runtest_setup",
          "isset",
          "rex_session_duration",
          "getrepr",
          "FUNCARGNAMES",
          "PytestUnhandledCoroutineWarning",
          "version",
          "reprfuncargs",
          "_getobj",
          "FixtureManager",
          "on_rm_rf_error",
          "PytestCacheWarning",
          "_compare_eq_sequence",
          "scopename2class",
          "JUNIT_XML_DEFAULT_FAMILY",
          "_NodeReporter",
          "teardown_nose",
          "finalize",
          "runpython",
          "setuponly",
          "deprecated",
          "_init_checker_class",
          "resume_global_capture",
          "scopeproperty",
          "REGEX_TYPE",
          "ensure_newline",
          "__take_sys_modules_snapshot",
          "import_plugin",
          "getcalls",
          "is_true",
          "makeini",
          "setup",
          "_parse_lsof_output",
          "getfixturemarker",
          "_argcomplete",
          "pytest_runtest_logfinish",
          "tmp_path",
          "addinivalue_line",
          "addfinalizer",
          "_find_parametrized_scope",
          "_ellipsize",
          "MARK_GEN",
          "write_log_entry",
          "_disable_output_capturing_for_darwin",
          "encoding",
          "setmulti2",
          "__hash__",
          "StoreKey",
          "create_terminal_writer",
          "_iter_all_modules",
          "getvalueorskip",
          "RESULT_LOG",
          "Token",
          "TYPE_CHECKING",
          "filter_traceback",
          "getfailedcollections",
          "Frame",
          "get_cache_dir",
          "for_config",
          "__attrs_post_init__",
          "resume_fixture",
          "_wrapped_pdb_cls",
          "DEFAULT_LOG_FORMAT",
          "parametrize",
          "ReprFuncArgs",
          "_compare_eq_dict",
          "teardown",
          "__ne__",
          "listoutcomes",
          "_get_report_choice",
          "ParsedCall",
          "_locationline",
          "passed",
          "MonkeyPatch",
          "register",
          "exitstatus",
          "FuncFixtureInfo",
          "AssertionRewriter",
          "tbfilter",
          "install_importhook",
          "parseconfigure",
          "_addexcinfo",
          "__array_priority__",
          "saferepr",
          "getmodpath",
          "stopTest",
          "read",
          "__next__",
          "showhelp",
          "_E",
          "getcfg",
          "runitem",
          "pytest_ignore_collect",
          "gethookrecorder",
          "verbosity",
          "longreprtext",
          "mode",
          "append_pass",
          "is_potential_nosetest",
          "perform_collect",
          "FixtureFunctionMarker",
          "_notin_text",
          "_split_lines",
          "__contains__",
          "_prepareconfig",
          "try_cleanup",
          "mangle_test_address",
          "_format_boolop",
          "PytestDeprecationWarning",
          "not_expr",
          "pytest_cmdline_parse",
          "_assert_start_repr",
          "monkeypatch",
          "_format_action_invocation",
          "set_trace",
          "argnames",
          "_log_text",
          "CollectReport",
          "WarningReport",
          "getimfunc",
          "add_stats",
          "FunctionDefinition",
          "_warn_about_missing_assertion",
          "genitems",
          "stop_capturing",
          "reorder_items_atscope",
          "section",
          "autouse",
          "_excinfo",
          "_param_ids_from",
          "from_exc_info",
          "parseoutcomes",
          "_get_first_non_fixture_func",
          "relline",
          "pytest_sessionfinish",
          "Mark",
          "ischildnode",
          "_diff_text",
          "parse_num",
          "exec_",
          "_should_truncate_item",
          "_eval_scope_callable",
          "main",
          "setdefault",
          "fail_marker",
          "read_global_capture",
          "FDCaptureBinary",
          "get_terminal_writer",
          "handleError",
          "get_sections",
          "hasplugin",
          "_processopt",
          "pytest_doctest_prepare_content",
          "names_closure",
          "_parse_parametrize_args",
          "ApproxNumpy",
          "truncate_if_required",
          "__bool__",
          "expression",
          "_recursive_list_map",
          "style",
          "_get_pos",
          "MatcherAdapter",
          "write_sep",
          "repr_locals",
          "notify_exception",
          "DOCTEST_REPORT_CHOICE_NONE",
          "recwarn",
          "path",
          "_get_continue_on_failure",
          "__eq__",
          "scopemismatch",
          "_W",
          "resume_capturing",
          "nextitem",
          "_traceback",
          "parts",
          "INTERNAL_ERROR",
          "add_report_section",
          "getcall",
          "set_log_path",
          "README_CONTENT",
          "OR",
          "fail_fixturefunc",
          "pop",
          "_validate_ids",
          "lineno",
          "item_capture",
          "_teardown_yield_fixture",
          "_makeitem",
          "isiterable",
          "Testdir",
          "names",
          "_get_active_fixturedef",
          "__len__",
          "call_fixture_func",
          "_get_multicapture",
          "addini",
          "pytest_report_header",
          "_checkargnotcontained",
          "DoctestModule",
          "name",
          "getgroup",
          "_get_allow_bytes_flag",
          "make_numbered_dir_with_cleanup",
          "mark",
          "startTest",
          "CaptureManager",
          "suspend_fixture",
          "RPAREN",
          "suspend_capturing",
          "get_data",
          "add_marker",
          "_format_lines",
          "_addoption",
          "_make_plural",
          "popcall",
          "_warn_incompatibility_with_xunit2",
          "wasvalid",
          "PYC_EXT",
          "tmpdir",
          "nose",
          "tb",
          "FixtureDef",
          "write_docstring",
          "istestclass",
          "session",
          "PdbTrace",
          "_check_non_top_pytest_plugins",
          "_makefile",
          "_io",
          "_compute_fixture_value",
          "_pluginmanager",
          "_importconftest",
          "debugging",
          "PYTEST_COLLECT_MODULE",
          "DropShorterLongHelpFormatter",
          "append_failure",
          "importorskip",
          "testdir",
          "_create",
          "getslaveinfoline",
          "deindent",
          "pytest_collection_finish",
          "funcnamefilter",
          "markup",
          "pytest_load_initial_conftests",
          "undo",
          "SafeRepr",
          "pytest_cmdline_preparse",
          "_get_progress_information_message",
          "getstatementrange",
          "repr_failure",
          "default_plugins",
          "_istrue",
          "_remove_ansi_escape_sequences",
          "from_config",
          "_schedule_finalizers",
          "setattr",
          "hasinit",
          "_getconftest_pathlist",
          "hookimpl",
          "nodes",
          "_initrequest",
          "_legal_chars",
          "FixtureLookupErrorRepr",
          "check_xfail_no_run",
          "parse_hookimpl_opts",
          "_S",
          "flow_marker",
          "tracebackcutdir",
          "OptionGroup",
          "reset",
          "_testcase",
          "FSCollector",
          "LFPlugin",
          "pytest_assertion_pass",
          "MarkMatcher",
          "_repr_failure_py",
          "hasnew",
          "format_explanation",
          "_determine_main_color",
          "visit_BoolOp",
          "getitem",
          "cache_dir_from_config",
          "capstderr",
          "get_dirs_from_args",
          "_set_initial_conftests",
          "_split_explanation",
          "_suspend",
          "iter_markers",
          "pos",
          "cache_key",
          "_LiveLoggingNullHandler",
          "_get_fixturestack",
          "disabled",
          "chain",
          "_write_source",
          "skipped_by_mark_key",
          "capsysbinary",
          "syspath_prepend",
          "getfailures",
          "inline_run",
          "_report_keyboardinterrupt",
          "TerminalRepr",
          "path_matches_patterns",
          "snap",
          "_mk_tmp",
          "FormattedExcinfo",
          "record_testreport",
          "PseudoFixtureDef",
          "warnings",
          "matching_platform",
          "pytest_itemcollected",
          "stepwise",
          "record_testsuite_property",
          "TerminalReporter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "ArgumentError",
          "_legal_ranges",
          "call_and_report",
          "_addoption_instance",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "_REPORTCHARS_DEFAULT",
          "freeze_support",
          "resultlog_key",
          "_config",
          "_get_line_with_reprcrash_message",
          "_inject_setup_module_fixture",
          "fnmatch_ex",
          "D",
          "variable",
          "get_real_method",
          "CollectError",
          "Code",
          "_to_json",
          "LoggingPlugin",
          "ColoredLevelFormatter",
          "lex",
          "Collector",
          "merge_family",
          "get_terminal_width",
          "scopenum_function",
          "suspend",
          "PercentStyleMultiline",
          "restore",
          "_opentestcase",
          "KeywordMatcher",
          "doctest_namespace",
          "sep",
          "append_skipped",
          "Scanner",
          "WarningsChecker",
          "StepwisePlugin",
          "_setup_fixtures",
          "pytest_runtest_makereport",
          "get_public_names",
          "get_config",
          "LineMatcher_fixture",
          "ParameterSet",
          "DoctestItem",
          "locals",
          "instance",
          "_tryconvertpyarg",
          "_log_cli_enabled",
          "catching_logs",
          "CACHEDIR_TAG_CONTENT",
          "fullwidth",
          "_get_flag_lookup",
          "resume",
          "tolerance",
          "_get_marks",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "__iter__",
          "__getattr__",
          "_enter_pdb",
          "__exit__",
          "co_equal",
          "Metafunc",
          "PytestUnknownMarkWarning",
          "BASE_TYPE",
          "set",
          "entrysep",
          "errisinstance",
          "_patch_unwrap_mock_aware",
          "invalidraise",
          "accept",
          "_getreprcrash",
          "_splitnode",
          "result",
          "pytest_runtest_logreport",
          "Parser",
          "istestfunc",
          "outcomes",
          "iscoroutinefunction",
          "combined_with",
          "fixtures",
          "fullsource",
          "_from_json",
          "LineComp",
          "at_level",
          "__slots__",
          "assertrepr_compare",
          "show_fixtures_per_test",
          "failed",
          "EMPTY_PARAMETERSET_OPTION",
          "_call_reprcompare",
          "MyOptionParser",
          "TempPathFactory",
          "getbasetemp",
          "clear",
          "__module__",
          "should_do_markup",
          "_add_stats",
          "_teardown_with_finalization",
          "value",
          "error",
          "pytest_make_parametrize_id",
          "ApproxDecimal",
          "putaround",
          "_ascii_escaped_by_config",
          "_prunetraceback",
          "ExceptionInfo",
          "emit",
          "RUNNER_CLASS",
          "pytest_fixture_setup",
          "_match_lines",
          "char_width",
          "count_towards_summary",
          "isattrs",
          "MINUS_K_DASH",
          "Notset",
          "maketxtfile",
          "parse_known_args",
          "makeconftest",
          "derive_importpath",
          "str",
          "_PYTEST_DIR",
          "num_mock_patch_args",
          "stop",
          "exists",
          "runtestprotocol",
          "category",
          "pytestconfig",
          "_fillfixtures",
          "fixture",
          "check_testcase_implements_trial_reporter",
          "ascii_escaped",
          "add_attribute",
          "TESTS_FAILED",
          "_visit_filter",
          "_T",
          "getvalue",
          "_get_global_properties_node",
          "width_of_current_line",
          "FSHookProxy",
          "_is_setup_py",
          "_matchfactories",
          "freeze_includes",
          "own_mark_names",
          "create_new_paste",
          "text",
          "pytest_runtest_teardown",
          "AND",
          "parse_hookspec_opts",
          "PytestWarning",
          "_trace",
          "__missing__",
          "short_test_summary",
          "_ensure_immutable_ids",
          "ConftestImportFailure",
          "get_direct_param_fixture_func",
          "_saved",
          "Argument",
          "evalcache_key",
          "capfd",
          "makedir",
          "_param_ids_generated",
          "_non_numeric_type_error",
          "cache",
          "_ensure_removed_sysmodule",
          "getfixtureinfo",
          "_check_record_param_type",
          "_in_suspended",
          "assertion",
          "AlwaysDispatchingPrettyPrinter",
          "attrs",
          "_is_doctest",
          "_compare_eq_iterable",
          "makepyfile"
        ]
      },
      "response": {
        "keywords": [
          "cwd_relative_nodeid",
          "chdir",
          "pytest_fixture_post_finalizer",
          "InvocationParams",
          "fixture",
          "cwd",
          "os",
          "AssertionError",
          "relative",
          "path"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:34:25.497931",
        "usage": "541.2678718566895 ms"
      },
      "request": {
        "tokens": [
          "cwd_relative_nodeid",
          "chdir",
          "pytest_fixture_post_finalizer",
          "InvocationParams",
          "fixture",
          "cwd",
          "os",
          "AssertionError",
          "relative",
          "path"
        ]
      },
      "response": {
        "results": {
          "path": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/reports.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/doctest.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/main.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/compat.py"
          ],
          "os": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/main.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/compat.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "fixture": [
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/setuponly.py",
            "src/pytest/__init__.py",
            "src/_pytest/compat.py"
          ],
          "AssertionError": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/util.py"
          ],
          "relative": [
            "src/_pytest/main.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/python.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py"
          ],
          "cwd_relative_nodeid": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py"
          ],
          "cwd": [
            "src/_pytest/config/findpaths.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/pytester.py"
          ],
          "chdir": [
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/main.py"
          ],
          "pytest_fixture_post_finalizer": [
            "src/_pytest/setuponly.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/fixtures.py"
          ],
          "InvocationParams": [
            "src/_pytest/config/__init__.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:34:26.039217",
        "usage": "6861.116170883179 ms"
      },
      "request": {
        "keyword_search_results": {
          "path": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/reports.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/doctest.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/main.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/compat.py"
          ],
          "os": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/main.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/compat.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "fixture": [
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/setuponly.py",
            "src/pytest/__init__.py",
            "src/_pytest/compat.py"
          ],
          "AssertionError": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/util.py"
          ],
          "relative": [
            "src/_pytest/main.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/python.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py"
          ],
          "cwd_relative_nodeid": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py"
          ],
          "cwd": [
            "src/_pytest/config/findpaths.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/pytester.py"
          ],
          "chdir": [
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/main.py"
          ],
          "pytest_fixture_post_finalizer": [
            "src/_pytest/setuponly.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/fixtures.py"
          ],
          "InvocationParams": [
            "src/_pytest/config/__init__.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue outlined is related to the wrong file path being displayed when a directory is changed within a fixture in pytest. The key aspects revolve around directory/path management and fixture handling.\n\n1. **Path and Fixture Keywords:** \n   - These keywords appear prominently in the issue. We need to look for areas in the pytest codebase dealing with path manipulation during test execution and how fixtures are managed.\n   - 'path', 'fixture', 'relative', 'cwd_relative_nodeid', 'cwd', and 'chdir' are crucial keywords since they suggest file handling, directory context management, and possible relative path constructions.\n\n2. **Analyzing the Search Results:**\n   - **'src/_pytest/config/__init__.py':** Appears under 'relative', 'cwd_relative_nodeid', 'cwd', 'InvocationParams'. This is likely to handle configuration and might relate to managing relative paths.\n   - **'src/_pytest/fixtures.py':** Matched with 'fixture', suggesting relevance where the fixture's directory context might be modified or managed.\n   - **'src/_pytest/monkeypatch.py':** In 'fixture' and 'chdir', this might involve direct manipulation of directory context during tests.\n   - **'src/_pytest/pytester.py':** Found under 'fixture', 'cwd', 'chdir', indicating possible involvement in directory changes in testing.\n   - **'src/_pytest/main.py':** Linked with 'relative', 'chdir', implies some management or alteration of path references during directory changes.\n   - **'src/_pytest/terminal.py':** Found under 'relative', 'cwd_relative_nodeid', relates to terminal outputs where paths may appear incorrectly.\n\nBased on these observations, the most likely candidates to explore further for fixing or understanding the asserted bug include configuration, fixture adjustments, and path editing during test execution. These could possibly lead to path inconsistencies when directories are modified during tests.",
        "file_paths": [
          "src/_pytest/config/__init__.py",
          "src/_pytest/fixtures.py",
          "src/_pytest/main.py",
          "src/_pytest/monkeypatch.py",
          "src/_pytest/pytester.py",
          "src/_pytest/terminal.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:32.900408",
        "usage": "4880.376100540161 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing Reported Issue:\n   - The issue is about the display of incorrect file paths in test output when a working directory is changed within a pytest fixture. The paths are relative to the changed directory rather than the original directory.\n   - The expected behavior is that paths should remain relative to the original directory even if the working directory is changed.\n   - The problem occurs during test execution where the `os.chdir` is used to change directories, affecting the relative path displayed.\n\n2. File Content Analysis:\n   - The file appears to be part of the configuration and initialization process for pytest, dealing with options, environment variables, and command line arguments.\n   - Functions like `main`, `console_main`, and the `Config` class work with setup, configuration, and invocation of pytest processes, which might affect how paths are handled.\n   - However, nothing in the file explicitly addresses path resolution or adjustments based on directory changes during test execution.\n   - The `Config.cwd_relative_nodeid` method might play a role as it indicates it attempts to compute paths relative to the current working directory.\n\n3. Decision on Relevance:\n   - There is no clear indication that this file adjusts the path behavior after a directory change performed in a fixture like `os.chdir`. The issue seems to stem from the context of test execution, not from command-line or plugin configuration.\n\n4. Conclusion:\n   - This file provides configurations that could potentially influence the pytest's behavior, but it does not seem to implement logic to resolve path issues due to `os.chdir` changes.\n   - Relevance: This file is related but does not contain the root cause of the issue.\n   - Suggested files to evaluate might include path handling or reporting modules/components within pytest.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pathlib.py",
          "src/_pytest/fixtures.py",
          "src/_pytest/debugging.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:37.780805",
        "usage": "7625.043869018555 ms"
      },
      "request": {
        "file_path": "src/_pytest/fixtures.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing Issue:\n    - The issue describes a problem with pytest where a fixture changes the current working directory during a test, causing relative file paths to be incorrect in failure messages, thus preventing the editor from finding the files easily.\n    - The user expects paths to remain relative to the original working directory despite the change in the test setup.\n    - The primary code in question is the directory change within a pytest fixture conjoining pytest's output/config handling mechanisms.\n    - Possible solutions include capturing the original path and explicitly adjusting any path-related output or information to reflect that path.\n\n2. Evaluating File:\n    - The file `src/_pytest/fixtures.py` is part of the pytest framework handling fixture setup, execution, and management.\n    - `getlocation()` and functions that derive or deal with path information might affect how paths are reported in error messages when fixtures alter the state/environment of tests.\n    - General functions like `FixtureRequest`, `addfinalizer`, or sub-fixtures working with paths might play a role.\n    - `getfslineno()`, `request.node`, or `_pyfuncitem` could be involved if they use `os.getcwd()` internally or anything affecting how nodes report file locations.\n    - `FixtureManager`, `FixtureRequest`, or any subclass might modify outputs via `_getscopeitem` or during `config` references or session data changes.\n    - The direct cause seems absent; however, context modification from fixtures might lead to misleading outputs elsewhere in pytest.\n\nConclusion:\n    - While the file does not appear to be the direct root cause, components concerning fixture execution, teardown, and environment handling uncover elements of path context that could be modified but are not solely causing the incorrect path references directly.\n    - The error lay partly in fixtures but involves interplay between pytest's session/configuration management affecting how paths are perceived/managed during failures.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [
          "FixtureRequest._getscopeitem",
          "FixtureRequest.fspath",
          "FixtureRequest.getfixturevalue",
          "FixtureManager.getfixtureinfo"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:45.405862",
        "usage": "8554.746150970459 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions**:\n   - **Issue Description**: The issue describes a problem where test files are shown as relative to a new directory when the working directory is changed in a pytest fixture. This affects the editor's ability to jump to the error location because it is unaware of the directory change.\n   - **Reproduce Steps**: The issue arises when a pytest fixture changes the working directory, causing failure points in tests to report paths relative to this new directory rather than the original invocation directory.\n   - **Cause of the Issue**: This appears to be related to how paths are managed and reported when the current working directory is altered during test execution. Pytest seems to change directory context, influencing how paths are resolved/shown in reports.\n   - **User Expectation**: Users expect the paths in test failure messages to remain relative to the original directory from which pytest was invoked, not the temporary directory set by a fixture.\n   - **Possible Solution**: One solution could be ensuring that the paths are always normalized or converted back to the start directory when generating reports.\n\n2. **File Evaluation**:\n   - The file `_pytest/main.py` contains implementation for various pytest features including collection, session initiation, and reporting.\n   - The `Session` class in this file appears highly relevant to the issue. It uses `self.startdir` to store the start directory of the session.\n   - Notably, `_node_location_to_relpath()` and `_bestrelpath_cache` play roles in path management, which are central to altering path displays relative to the start directory.\n   - The method `_node_location_to_relpath()` converts node paths to relative paths. If wrong paths are displayed, this might be a misconfigured or mishandled path normalization issue.\n   - `wrap_session` uses `session.startdir.chdir()` when cleaning up at the end of the session, mentioning start directory normalization.\n   - The session setup (`wrap_session` and `Session.__init__`) appears to capture and store start directories, suggesting that paths should be relative here unless the directory is explicitly altered as part of a test's execution.\n   - The `_perform_collect`, `_parsearg`, and `_tryconvertpyarg` might also contribute to understanding how paths are collected or converted across sessions and directories. \n",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Session",
          "Session._node_location_to_relpath",
          "Session.startdir",
          "_bestrelpath_cache"
        ],
        "root_cause_symbols": [
          "Session",
          "Session._node_location_to_relpath",
          "Session.startdir",
          "_bestrelpath_cache"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:53.960627",
        "usage": "10779.175996780396 ms"
      },
      "request": {
        "file_path": "src/_pytest/monkeypatch.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue:**\n   - The issue is about incorrect path display in error messages when a test changes its working directory during execution, caused by a pytest fixture.\n   - The user expects the file paths in error messages to be relative to the original directory, but they are shown relative to the new working directory.\n\n2. **Reproduction Insight:**\n   - The problem arises due to the temporary directory change using a fixture that modifies the working directory to 'ddd'.\n   - This confuses file path tracking because the current directory context is altered in the middle of the test.\n\n3. **Cause Analysis:**\n   - The file in question `src/_pytest/monkeypatch.py` manages fixtures and environment modifications, including directory changes (via `monkeypatch.chdir()`).\n   - This could affect how pytest resolves paths and references during test execution, leading to misplaced file paths in error outputs.\n\n4. **Expectation:**\n   - The paths in the output should always reflect locations relative to the initial execution context, regardless of directory changes in the test logic.\n\n5. **Potential Solutions:**\n   - Modify the `monkeypatch.chdir()` or similar methods to maintain a consistent reference for path resolution.\n   - Ensure that any error handling or path referencing within pytest corrects for directory changes made during test operations.\n\n6. **Evaluating the Given File:**\n   - The file `src/_pytest/monkeypatch.py` involves methods for directory changing (`chdir`) and other environment modifications (`MonkeyPatch` class, `monkeypatch` fixture).\n   - The code manages modifications and is likely involved in altering test behaviors leading to the described issue.\n   - Particularly, methods like `MonkeyPatch.chdir()` and `MonkeyPatch.undo()` directly impact directory handling and restoration, likely influencing path resolution in errors.\n   \n7. **Conclusion:**\n   - The file is highly relevant, as it seems to handle the mechanics behind directory changing logic within pytest, which directly ties into the user's problem with incorrect path outputs.\n   - I categorize this file as not being the root cause but as significantly related.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pathlib.py",
          "_pytest/main.py",
          "src/_pytest/nodes.py"
        ],
        "relevant_symbols": [
          "monkeypatch",
          "MonkeyPatch.chdir",
          "MonkeyPatch.undo",
          "MonkeyPatch.__init__",
          "MonkeyPatch",
          "monkeypatch.chdir"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:35:04.739823",
        "usage": "10403.211832046509 ms"
      },
      "request": {
        "file_path": "src/_pytest/pytester.py"
      },
      "response": {
        "scratch_pad": "# Analyzer and Thoughts\n\n## Step 1: Analyze the Issue\n1. **What's the issue?**\n   The issue is related to pytest not displaying the correct path to test files when the working directory is changed within a fixture.\n\n2. **Reproduce steps provided?**\n   Yes, a provided fixture changes the working directory and then runs a test which fails, demonstrating that pytest outputs a path relative to the new directory, not the original.\n\n3. **How was this issue caused?**\n   The issue arises because the pytest framework computes file paths relative to the current working directory (changed by the fixture) rather than the original startup directory.\n\n4. **Summary of User Expectation**:\n   The user expects file paths to remain consistent and relative to the initial invocation directory, not the dynamically changed one during test runs.\n\n5. **Possible solutions**:\n   A possible solution could involve capturing the initial directory on pytest startup and adjusting the path computation logic to ensure that paths are output relative to the initial directory.\n\n\n## Step 2: Evaluate the File Content\n1. **Identify Relevant Parts**:\n   - There is a `Testdir` class that deals with directory handling and temporary test directories.\n   - Methods related to working directory (`chdir`, `makefile`, `makepyfile`, etc.) might be influencing this behavior.\n   - Path computation logic, if present, is crucial here.\n\n2. **Relevance to the Issue**:\n   - **`Testdir` class**: This class modifies the current working directory using its methods. However, it does not seem to directly relate to fixing path outputs. Instead, it primarily concerns the setup of testing environments and directory management.\n   - **Path Functions**: There are functions that change directories but these are utility functions for test execution, not directly tied to path display logic.\n\n3. **Root Cause Analysis**:\n   - The file context and its symbols are not directly involved in altering the path's display in pytest reports. The logic for outputting paths, which reflects the working directory changes made by fixtures, seems to be done elsewhere.\n\n4. **Conclusion**:\n   The file is not the root cause of the issue but may support operations that can cause such an effect when linked with other mechanisms that format output paths in reports.\n\n5. **Recommendations**:\n   - Check files related to test report generation and how paths are computed for outputs.\n   - Files in the `_pytest/reports.py` area or configuration handling might be relevant.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/reports.py",
          "src/_pytest/main.py",
          "src/_pytest/configurations.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:35:15.143056",
        "usage": "8728.862047195435 ms"
      },
      "request": {
        "file_path": "src/_pytest/terminal.py"
      },
      "response": {
        "scratch_pad": "### Analysis of User Issues\n1. **Issue Description:**\n   - The issue involves wrong paths to test files when the working directory is changed in a pytest fixture.\n   - Specifically, when using changing directories temporarily in a test fixture, pytest output shows test paths relative to this temporary directory rather than the original directory. This causes editors to fail in jumping to the error location because of incorrect path references.\n   \n2. **Reproduction Steps:**\n   - The user creates a fixture that changes the working directory.\n   - Pytest reports failure with a path relative to the new directory.\n\n3. **User Expectation:**\n   - The user expects test paths in error messages should be always relative to the original root directory, regardless of fixture-induced directory changes.\n\n4. **Possible Causes**\n   - The change in the working directory by the fixture might be affecting how paths are resolved and displayed in terminal outputs.\n\n5. **Potential Solutions**\n   - Ensure that the path reporting mechanism in pytest doesn't rely on the current working directory and is consistently based on the initial invocation directory.\n\n### Code Analysis\n1. **File Role in Issue**\n   - The file `src/_pytest/terminal.py` is related to terminal reporting coming from pytest execution.\n   - The methods related to reporting test results, like `pytest_runtest_logreport()` and `write_fspath_result()`, are key in determining the path shown in the output.\n\n2. **Relevant Symbols and Code**\n   - **`TerminalReporter.write_fspath_result()` method**: Responsible for writing paths in the terminal report. This method already uses bestrelpath which attempts to make paths relative.\n   - **`TerminalReporter` class**: Handles overall pytest terminal reporting. Look into attributes or other methods that change paths presented in test outputs.\n   - **`get_location()` method in `WarningReport` class**: Shows how `relto` method is used to make paths relative, which might be affected by the directory change from fixture.\n\n3. **Links to Issue**\n   - The solution needs `TerminalReporter` to handle and adjust paths considering the working directory changes during testing.\n   - Check where `write_fspath_result` is invoked and if state or invocations might revert to incorrect base paths.\n\n### Conclusion:\n- While the full root cause might not lie in this file alone, it is central to the issue of improper path reporting.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/main.py",
          "src/_pytest/nodes.py",
          "src/_pytest/config.py"
        ],
        "relevant_symbols": [
          "TerminalReporter.write_fspath_result",
          "TerminalReporter",
          "WarningReport.get_location"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:35:23.871997",
        "usage": "326.5352249145508 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/fixtures.py",
            "relevant_symbol_keys": [
              "FixtureRequest._getscopeitem",
              "FixtureRequest.fspath",
              "FixtureRequest.getfixturevalue",
              "FixtureManager.getfixtureinfo"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "Session",
              "Session._node_location_to_relpath",
              "Session.startdir",
              "_bestrelpath_cache"
            ],
            "root_cause_symbol_keys": [
              "Session",
              "Session._node_location_to_relpath",
              "Session.startdir",
              "_bestrelpath_cache"
            ]
          },
          {
            "file_path": "src/_pytest/monkeypatch.py",
            "relevant_symbol_keys": [
              "monkeypatch",
              "MonkeyPatch.chdir",
              "MonkeyPatch.undo",
              "MonkeyPatch.__init__",
              "MonkeyPatch",
              "monkeypatch.chdir"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/pytester.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/terminal.py",
            "relevant_symbol_keys": [
              "TerminalReporter.write_fspath_result",
              "TerminalReporter",
              "WarningReport.get_location"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self) -> py.path.local:\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore",
            "start_line": 432,
            "start_column": 16222,
            "end_line": 4,
            "end_column": 16481,
            "start_byte": 16222,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raise pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 482,
            "start_column": 18125,
            "end_line": 4,
            "end_column": 18655,
            "start_byte": 18125,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 624,
            "start_column": 24177,
            "end_line": 4,
            "end_column": 24816,
            "start_byte": 24177,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1273,
            "start_column": 48023,
            "end_line": 4,
            "end_column": 48743,
            "start_byte": 48023,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.RE_IMPORT_ERROR_NAME",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "RE_IMPORT_ERROR_NAME = re.compile(r\"^No module named (.*)$\")",
            "start_line": 12,
            "start_column": 251,
            "end_line": 0,
            "end_column": 311,
            "start_byte": 251,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.monkeypatch",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "@fixture\ndef monkeypatch():\n    \"\"\"The returned ``monkeypatch`` fixture provides these\n    helper methods to modify objects, dictionaries or os.environ::\n\n        monkeypatch.setattr(obj, name, value, raising=True)\n        monkeypatch.delattr(obj, name, raising=True)\n        monkeypatch.setitem(mapping, name, value)\n        monkeypatch.delitem(obj, name, raising=True)\n        monkeypatch.setenv(name, value, prepend=False)\n        monkeypatch.delenv(name, raising=True)\n        monkeypatch.syspath_prepend(path)\n        monkeypatch.chdir(path)\n\n    All modifications will be undone after the requesting\n    test function or fixture has finished. The ``raising``\n    parameter determines if a KeyError or AttributeError\n    will be raised if the set/deletion operation has no target.\n    \"\"\"\n    mpatch = MonkeyPatch()\n    yield mpatch\n    mpatch.undo()",
            "start_line": 15,
            "start_column": 314,
            "end_line": 0,
            "end_column": 1169,
            "start_byte": 314,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.resolve",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def resolve(name):\n    # simplified from zope.dottedname\n    parts = name.split(\".\")\n\n    used = parts.pop(0)\n    found = __import__(used)\n    for part in parts:\n        used += \".\" + part\n        try:\n            found = getattr(found, part)\n        except AttributeError:\n            pass\n        else:\n            continue\n        # we use explicit un-nesting of the handling block in order\n        # to avoid nested exceptions on python 3\n        try:\n            __import__(used)\n        except ImportError as ex:\n            # str is used for py2 vs py3\n            expected = str(ex).split()[-1]\n            if expected == used:\n                raise\n            else:\n                raise ImportError(\"import error in {}: {}\".format(used, ex))\n        found = annotated_getattr(found, part, used)\n    return found",
            "start_line": 39,
            "start_column": 1172,
            "end_line": 0,
            "end_column": 1994,
            "start_byte": 1172,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.annotated_getattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def annotated_getattr(obj, name, ann):\n    try:\n        obj = getattr(obj, name)\n    except AttributeError:\n        raise AttributeError(\n            \"{!r} object at {} has no attribute {!r}\".format(\n                type(obj).__name__, ann, name\n            )\n        )\n    return obj",
            "start_line": 68,
            "start_column": 1997,
            "end_line": 0,
            "end_column": 2281,
            "start_byte": 1997,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.derive_importpath",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def derive_importpath(import_path, raising):\n    if not isinstance(import_path, str) or \".\" not in import_path:\n        raise TypeError(\n            \"must be absolute import path string, not {!r}\".format(import_path)\n        )\n    module, attr = import_path.rsplit(\".\", 1)\n    target = resolve(module)\n    if raising:\n        annotated_getattr(target, attr, ann=module)\n    return attr, target",
            "start_line": 80,
            "start_column": 2284,
            "end_line": 0,
            "end_column": 2677,
            "start_byte": 2284,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.Notset",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "class Notset:\n    def __repr__(self):\n        return \"<notset>\"",
            "start_line": 92,
            "start_column": 2680,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2680,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.Notset.__repr__",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def __repr__(self):\n        return \"<notset>\"",
            "start_line": 93,
            "start_column": 2698,
            "end_line": 4,
            "end_column": 2743,
            "start_byte": 2698,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.notset",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "notset = Notset()",
            "start_line": 97,
            "start_column": 2746,
            "end_line": 0,
            "end_column": 2763,
            "start_byte": 2746,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "class MonkeyPatch:\n    \"\"\" Object returned by the ``monkeypatch`` fixture keeping a record of setattr/item/env/syspath changes.\n    \"\"\"\n\n    def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None\n\n    @contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()\n\n    def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)\n\n    def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)\n\n    def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value\n\n    def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]\n\n    def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)\n\n    def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)\n\n    def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()\n\n    def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)\n\n    def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 100,
            "start_column": 2766,
            "end_line": 0,
            "end_column": 11401,
            "start_byte": 2766,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.__init__",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None",
            "start_line": 104,
            "start_column": 2907,
            "end_line": 4,
            "end_column": 3038,
            "start_byte": 2907,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.context",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "@contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()",
            "start_line": 110,
            "start_column": 3044,
            "end_line": 4,
            "end_column": 3875,
            "start_byte": 3044,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.setattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)",
            "start_line": 135,
            "start_column": 3881,
            "end_line": 4,
            "end_column": 5427,
            "start_byte": 3881,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.delattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)",
            "start_line": 172,
            "start_column": 5433,
            "end_line": 4,
            "end_column": 6739,
            "start_byte": 5433,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.setitem",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value",
            "start_line": 206,
            "start_column": 6745,
            "end_line": 4,
            "end_column": 6928,
            "start_byte": 6745,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.delitem",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]",
            "start_line": 211,
            "start_column": 6934,
            "end_line": 4,
            "end_column": 7362,
            "start_byte": 6934,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.setenv",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)",
            "start_line": 224,
            "start_column": 7368,
            "end_line": 4,
            "end_column": 8244,
            "start_byte": 7368,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.delenv",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)",
            "start_line": 243,
            "start_column": 8250,
            "end_line": 4,
            "end_column": 8567,
            "start_byte": 8250,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.syspath_prepend",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()",
            "start_line": 252,
            "start_column": 8573,
            "end_line": 4,
            "end_column": 9520,
            "start_byte": 8573,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.chdir",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)",
            "start_line": 274,
            "start_column": 9526,
            "end_line": 4,
            "end_column": 9989,
            "start_byte": 9526,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.undo",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 288,
            "start_column": 9995,
            "end_line": 4,
            "end_column": 11401,
            "start_byte": 9995,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.WarningReport.get_location",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def get_location(self, config):\n        \"\"\"\n        Returns the more user-friendly information about the location\n        of a warning, or None.\n        \"\"\"\n        if self.nodeid:\n            return self.nodeid\n        if self.fslocation:\n            if isinstance(self.fslocation, tuple) and len(self.fslocation) >= 2:\n                filename, linenum = self.fslocation[:2]\n                relpath = py.path.local(filename).relto(config.invocation_dir)\n                if not relpath:\n                    relpath = str(filename)\n                return \"{}:{}\".format(relpath, linenum)\n            else:\n                return str(self.fslocation)\n        return None",
            "start_line": 242,
            "start_column": 6791,
            "end_line": 4,
            "end_column": 7460,
            "start_byte": 6791,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]\n\n    @property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw\n\n    @writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)\n\n    def flush(self) -> None:\n        self._tw.flush()\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()\n\n    @property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected\n\n    def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})\n\n    def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line\n\n    def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]\n\n    def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)\n\n    def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)\n\n    def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)\n\n    def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types\n\n    def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color\n\n    def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))\n\n    def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 261,
            "start_column": 7463,
            "end_line": 0,
            "end_column": 40474,
            "start_byte": 7463,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]",
            "start_line": 262,
            "start_column": 7491,
            "end_line": 4,
            "end_column": 8496,
            "start_byte": 7491,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.writer",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw",
            "start_line": 286,
            "start_column": 8502,
            "end_line": 4,
            "end_column": 8634,
            "start_byte": 8502,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.writer",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value",
            "start_line": 291,
            "start_column": 8640,
            "end_line": 4,
            "end_column": 8783,
            "start_byte": 8640,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 296,
            "start_column": 8789,
            "end_line": 4,
            "end_column": 9372,
            "start_byte": 8789,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 309,
            "start_column": 9378,
            "end_line": 4,
            "end_column": 9454,
            "start_byte": 9378,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 313,
            "start_column": 9460,
            "end_line": 4,
            "end_column": 9530,
            "start_byte": 9460,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath",
            "start_line": 317,
            "start_column": 9536,
            "end_line": 4,
            "end_column": 9679,
            "start_byte": 9536,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 323,
            "start_column": 9685,
            "end_line": 4,
            "end_column": 9769,
            "start_byte": 9685,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 327,
            "start_column": 9775,
            "end_line": 4,
            "end_column": 9850,
            "start_byte": 9775,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 331,
            "start_column": 9856,
            "end_line": 4,
            "end_column": 9983,
            "start_byte": 9856,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)",
            "start_line": 335,
            "start_column": 9989,
            "end_line": 4,
            "end_column": 10686,
            "start_byte": 9989,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 348,
            "start_column": 10692,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10692,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 357,
            "start_column": 10998,
            "end_line": 4,
            "end_column": 11120,
            "start_byte": 10998,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)",
            "start_line": 362,
            "start_column": 11126,
            "end_line": 4,
            "end_column": 11259,
            "start_byte": 11126,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.flush",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def flush(self) -> None:\n        self._tw.flush()",
            "start_line": 365,
            "start_column": 11265,
            "end_line": 4,
            "end_column": 11314,
            "start_byte": 11265,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 368,
            "start_column": 11320,
            "end_line": 4,
            "end_column": 11510,
            "start_byte": 11320,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 374,
            "start_column": 11516,
            "end_line": 4,
            "end_column": 12134,
            "start_byte": 11516,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 392,
            "start_column": 12140,
            "end_line": 4,
            "end_column": 12260,
            "start_byte": 12140,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 396,
            "start_column": 12266,
            "end_line": 4,
            "end_column": 12345,
            "start_byte": 12266,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 399,
            "start_column": 12351,
            "end_line": 4,
            "end_column": 12410,
            "start_byte": 12351,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._add_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()",
            "start_line": 402,
            "start_column": 12416,
            "end_line": 4,
            "end_column": 12648,
            "start_byte": 12416,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 408,
            "start_column": 12654,
            "end_line": 4,
            "end_column": 12811,
            "start_byte": 12654,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])",
            "start_line": 413,
            "start_column": 12817,
            "end_line": 4,
            "end_column": 13350,
            "start_byte": 12817,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 426,
            "start_column": 13356,
            "end_line": 4,
            "end_column": 13731,
            "start_byte": 13356,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)",
            "start_line": 434,
            "start_column": 13737,
            "end_line": 4,
            "end_column": 13817,
            "start_byte": 13737,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()",
            "start_line": 437,
            "start_column": 13823,
            "end_line": 4,
            "end_column": 14241,
            "start_byte": 13823,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()",
            "start_line": 448,
            "start_column": 14247,
            "end_line": 4,
            "end_column": 16159,
            "start_byte": 14247,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._is_last_item",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected",
            "start_line": 497,
            "start_column": 16165,
            "end_line": 4,
            "end_column": 16287,
            "start_byte": 16165,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})",
            "start_line": 501,
            "start_column": 16293,
            "end_line": 4,
            "end_column": 17210,
            "start_byte": 16293,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"",
            "start_line": 522,
            "start_column": 17216,
            "end_line": 4,
            "end_column": 17957,
            "start_byte": 17216,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})",
            "start_line": 539,
            "start_column": 17963,
            "end_line": 4,
            "end_column": 18259,
            "start_byte": 17963,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line",
            "start_line": 546,
            "start_column": 18265,
            "end_line": 4,
            "end_column": 18465,
            "start_byte": 18265,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)",
            "start_line": 551,
            "start_column": 18471,
            "end_line": 4,
            "end_column": 18821,
            "start_byte": 18471,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 559,
            "start_column": 18827,
            "end_line": 4,
            "end_column": 19212,
            "start_byte": 18827,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 569,
            "start_column": 19218,
            "end_line": 4,
            "end_column": 20633,
            "start_byte": 19218,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 609,
            "start_column": 20639,
            "end_line": 4,
            "end_column": 21805,
            "start_byte": 20639,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 637,
            "start_column": 21811,
            "end_line": 4,
            "end_column": 21954,
            "start_byte": 21811,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 642,
            "start_column": 21960,
            "end_line": 4,
            "end_column": 22615,
            "start_byte": 21960,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)",
            "start_line": 659,
            "start_column": 22621,
            "end_line": 4,
            "end_column": 23336,
            "start_byte": 22621,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))",
            "start_line": 679,
            "start_column": 23342,
            "end_line": 4,
            "end_column": 25064,
            "start_byte": 23342,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()",
            "start_line": 719,
            "start_column": 25070,
            "end_line": 4,
            "end_column": 26017,
            "start_byte": 25070,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 744,
            "start_column": 26023,
            "end_line": 4,
            "end_column": 26366,
            "start_byte": 26023,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 755,
            "start_column": 26372,
            "end_line": 4,
            "end_column": 26487,
            "start_byte": 26372,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 758,
            "start_column": 26493,
            "end_line": 4,
            "end_column": 26620,
            "start_byte": 26493,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 762,
            "start_column": 26626,
            "end_line": 4,
            "end_column": 27154,
            "start_byte": 26626,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 776,
            "start_column": 27160,
            "end_line": 4,
            "end_column": 27982,
            "start_byte": 27160,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 798,
            "start_column": 27988,
            "end_line": 4,
            "end_column": 28146,
            "start_byte": 27988,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 804,
            "start_column": 28152,
            "end_line": 4,
            "end_column": 28396,
            "start_byte": 28152,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 816,
            "start_column": 28448,
            "end_line": 4,
            "end_column": 28637,
            "start_byte": 28448,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 823,
            "start_column": 28643,
            "end_line": 4,
            "end_column": 31098,
            "start_byte": 28643,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 880,
            "start_column": 31104,
            "end_line": 4,
            "end_column": 31684,
            "start_byte": 31104,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_teardown_reports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]",
            "start_line": 894,
            "start_column": 31690,
            "end_line": 4,
            "end_column": 31916,
            "start_byte": 31690,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._handle_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)",
            "start_line": 901,
            "start_column": 31922,
            "end_line": 4,
            "end_column": 32086,
            "start_byte": 31922,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 905,
            "start_column": 32092,
            "end_line": 4,
            "end_column": 32598,
            "start_byte": 32092,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 918,
            "start_column": 32604,
            "end_line": 4,
            "end_column": 33288,
            "start_byte": 32604,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 935,
            "start_column": 33294,
            "end_line": 4,
            "end_column": 33890,
            "start_byte": 33294,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 950,
            "start_column": 33896,
            "end_line": 4,
            "end_column": 34353,
            "start_byte": 33896,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)",
            "start_line": 963,
            "start_column": 34359,
            "end_line": 4,
            "end_column": 35728,
            "start_byte": 34359,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 1000,
            "start_column": 35734,
            "end_line": 4,
            "end_column": 38473,
            "start_byte": 35734,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types",
            "start_line": 1069,
            "start_column": 38479,
            "end_line": 4,
            "end_column": 38777,
            "start_byte": 38479,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color",
            "start_line": 1076,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 39231,
            "start_byte": 38783,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))",
            "start_line": 1088,
            "start_column": 39237,
            "end_line": 4,
            "end_column": 39722,
            "start_byte": 39237,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.build_summary_stats_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 1097,
            "start_column": 39728,
            "end_line": 4,
            "end_column": 40474,
            "start_byte": 39728,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/main.py",
            "file_content": "@attr.s\nclass _bestrelpath_cache(dict):\n    path = attr.ib(type=py.path.local)\n\n    def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
            "start_line": 357,
            "start_column": 11180,
            "end_line": 0,
            "end_column": 11407,
            "start_byte": 11180,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/main.py",
            "file_content": "path = attr.ib(type=py.path.local)",
            "start_line": 359,
            "start_column": 11224,
            "end_line": 4,
            "end_column": 11258,
            "start_byte": 11224,
            "end_byte": 4
          },
          {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
            "start_line": 361,
            "start_column": 11264,
            "end_line": 4,
            "end_column": 11407,
            "start_byte": 11264,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11410,
            "end_line": 0,
            "end_column": 24577,
            "start_byte": 11410,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11448,
            "end_line": 4,
            "end_column": 11473,
            "start_byte": 11448,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11478,
            "end_line": 4,
            "end_column": 11493,
            "start_byte": 11478,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11554,
            "end_line": 4,
            "end_column": 11572,
            "start_byte": 11554,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11655,
            "end_line": 4,
            "end_column": 11677,
            "start_byte": 11655,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11706,
            "end_line": 4,
            "end_column": 11723,
            "start_byte": 11706,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11759,
            "end_line": 4,
            "end_column": 13037,
            "start_byte": 11759,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13043,
            "end_line": 4,
            "end_column": 13124,
            "start_byte": 13043,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13130,
            "end_line": 4,
            "end_column": 13410,
            "start_byte": 13130,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13416,
            "end_line": 4,
            "end_column": 13581,
            "start_byte": 13416,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13587,
            "end_line": 4,
            "end_column": 13801,
            "start_byte": 13587,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13807,
            "end_line": 4,
            "end_column": 14169,
            "start_byte": 13807,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14175,
            "end_line": 4,
            "end_column": 14222,
            "start_byte": 14175,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14228,
            "end_line": 4,
            "end_column": 14297,
            "start_byte": 14228,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14303,
            "end_line": 4,
            "end_column": 14394,
            "start_byte": 14303,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14400,
            "end_line": 4,
            "end_column": 14868,
            "start_byte": 14400,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14874,
            "end_line": 4,
            "end_column": 16108,
            "start_byte": 14874,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16114,
            "end_line": 4,
            "end_column": 16849,
            "start_byte": 16114,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16855,
            "end_line": 4,
            "end_column": 20651,
            "start_byte": 16855,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20657,
            "end_line": 4,
            "end_column": 20727,
            "start_byte": 20657,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20733,
            "end_line": 4,
            "end_column": 21337,
            "start_byte": 20733,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21343,
            "end_line": 4,
            "end_column": 22028,
            "start_byte": 21343,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22034,
            "end_line": 4,
            "end_column": 22418,
            "start_byte": 22034,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22424,
            "end_line": 4,
            "end_column": 24102,
            "start_byte": 22424,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24108,
            "end_line": 4,
            "end_column": 24577,
            "start_byte": 24108,
            "end_byte": 4
          },
          {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 801,
            "start_column": 26154,
            "end_line": 4,
            "end_column": 26171,
            "start_byte": 26154,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:35:24.198539",
        "usage": "16856.14800453186 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self) -> py.path.local:\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore",
            "start_line": 432,
            "start_column": 16222,
            "end_line": 4,
            "end_column": 16481,
            "start_byte": 16222,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raise pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 482,
            "start_column": 18125,
            "end_line": 4,
            "end_column": 18655,
            "start_byte": 18125,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 624,
            "start_column": 24177,
            "end_line": 4,
            "end_column": 24816,
            "start_byte": 24177,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1273,
            "start_column": 48023,
            "end_line": 4,
            "end_column": 48743,
            "start_byte": 48023,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.RE_IMPORT_ERROR_NAME",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "RE_IMPORT_ERROR_NAME = re.compile(r\"^No module named (.*)$\")",
            "start_line": 12,
            "start_column": 251,
            "end_line": 0,
            "end_column": 311,
            "start_byte": 251,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.monkeypatch",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "@fixture\ndef monkeypatch():\n    \"\"\"The returned ``monkeypatch`` fixture provides these\n    helper methods to modify objects, dictionaries or os.environ::\n\n        monkeypatch.setattr(obj, name, value, raising=True)\n        monkeypatch.delattr(obj, name, raising=True)\n        monkeypatch.setitem(mapping, name, value)\n        monkeypatch.delitem(obj, name, raising=True)\n        monkeypatch.setenv(name, value, prepend=False)\n        monkeypatch.delenv(name, raising=True)\n        monkeypatch.syspath_prepend(path)\n        monkeypatch.chdir(path)\n\n    All modifications will be undone after the requesting\n    test function or fixture has finished. The ``raising``\n    parameter determines if a KeyError or AttributeError\n    will be raised if the set/deletion operation has no target.\n    \"\"\"\n    mpatch = MonkeyPatch()\n    yield mpatch\n    mpatch.undo()",
            "start_line": 15,
            "start_column": 314,
            "end_line": 0,
            "end_column": 1169,
            "start_byte": 314,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.resolve",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def resolve(name):\n    # simplified from zope.dottedname\n    parts = name.split(\".\")\n\n    used = parts.pop(0)\n    found = __import__(used)\n    for part in parts:\n        used += \".\" + part\n        try:\n            found = getattr(found, part)\n        except AttributeError:\n            pass\n        else:\n            continue\n        # we use explicit un-nesting of the handling block in order\n        # to avoid nested exceptions on python 3\n        try:\n            __import__(used)\n        except ImportError as ex:\n            # str is used for py2 vs py3\n            expected = str(ex).split()[-1]\n            if expected == used:\n                raise\n            else:\n                raise ImportError(\"import error in {}: {}\".format(used, ex))\n        found = annotated_getattr(found, part, used)\n    return found",
            "start_line": 39,
            "start_column": 1172,
            "end_line": 0,
            "end_column": 1994,
            "start_byte": 1172,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.annotated_getattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def annotated_getattr(obj, name, ann):\n    try:\n        obj = getattr(obj, name)\n    except AttributeError:\n        raise AttributeError(\n            \"{!r} object at {} has no attribute {!r}\".format(\n                type(obj).__name__, ann, name\n            )\n        )\n    return obj",
            "start_line": 68,
            "start_column": 1997,
            "end_line": 0,
            "end_column": 2281,
            "start_byte": 1997,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.derive_importpath",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def derive_importpath(import_path, raising):\n    if not isinstance(import_path, str) or \".\" not in import_path:\n        raise TypeError(\n            \"must be absolute import path string, not {!r}\".format(import_path)\n        )\n    module, attr = import_path.rsplit(\".\", 1)\n    target = resolve(module)\n    if raising:\n        annotated_getattr(target, attr, ann=module)\n    return attr, target",
            "start_line": 80,
            "start_column": 2284,
            "end_line": 0,
            "end_column": 2677,
            "start_byte": 2284,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.Notset",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "class Notset:\n    def __repr__(self):\n        return \"<notset>\"",
            "start_line": 92,
            "start_column": 2680,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2680,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.Notset.__repr__",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def __repr__(self):\n        return \"<notset>\"",
            "start_line": 93,
            "start_column": 2698,
            "end_line": 4,
            "end_column": 2743,
            "start_byte": 2698,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.notset",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "notset = Notset()",
            "start_line": 97,
            "start_column": 2746,
            "end_line": 0,
            "end_column": 2763,
            "start_byte": 2746,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "class MonkeyPatch:\n    \"\"\" Object returned by the ``monkeypatch`` fixture keeping a record of setattr/item/env/syspath changes.\n    \"\"\"\n\n    def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None\n\n    @contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()\n\n    def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)\n\n    def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)\n\n    def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value\n\n    def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]\n\n    def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)\n\n    def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)\n\n    def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()\n\n    def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)\n\n    def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 100,
            "start_column": 2766,
            "end_line": 0,
            "end_column": 11401,
            "start_byte": 2766,
            "end_byte": 0
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.__init__",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None",
            "start_line": 104,
            "start_column": 2907,
            "end_line": 4,
            "end_column": 3038,
            "start_byte": 2907,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.context",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "@contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()",
            "start_line": 110,
            "start_column": 3044,
            "end_line": 4,
            "end_column": 3875,
            "start_byte": 3044,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.setattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)",
            "start_line": 135,
            "start_column": 3881,
            "end_line": 4,
            "end_column": 5427,
            "start_byte": 3881,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.delattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)",
            "start_line": 172,
            "start_column": 5433,
            "end_line": 4,
            "end_column": 6739,
            "start_byte": 5433,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.setitem",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value",
            "start_line": 206,
            "start_column": 6745,
            "end_line": 4,
            "end_column": 6928,
            "start_byte": 6745,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.delitem",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]",
            "start_line": 211,
            "start_column": 6934,
            "end_line": 4,
            "end_column": 7362,
            "start_byte": 6934,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.setenv",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)",
            "start_line": 224,
            "start_column": 7368,
            "end_line": 4,
            "end_column": 8244,
            "start_byte": 7368,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.delenv",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)",
            "start_line": 243,
            "start_column": 8250,
            "end_line": 4,
            "end_column": 8567,
            "start_byte": 8250,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.syspath_prepend",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()",
            "start_line": 252,
            "start_column": 8573,
            "end_line": 4,
            "end_column": 9520,
            "start_byte": 8573,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.chdir",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)",
            "start_line": 274,
            "start_column": 9526,
            "end_line": 4,
            "end_column": 9989,
            "start_byte": 9526,
            "end_byte": 4
          },
          {
            "name": "_pytest.monkeypatch.MonkeyPatch.undo",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 288,
            "start_column": 9995,
            "end_line": 4,
            "end_column": 11401,
            "start_byte": 9995,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.WarningReport.get_location",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def get_location(self, config):\n        \"\"\"\n        Returns the more user-friendly information about the location\n        of a warning, or None.\n        \"\"\"\n        if self.nodeid:\n            return self.nodeid\n        if self.fslocation:\n            if isinstance(self.fslocation, tuple) and len(self.fslocation) >= 2:\n                filename, linenum = self.fslocation[:2]\n                relpath = py.path.local(filename).relto(config.invocation_dir)\n                if not relpath:\n                    relpath = str(filename)\n                return \"{}:{}\".format(relpath, linenum)\n            else:\n                return str(self.fslocation)\n        return None",
            "start_line": 242,
            "start_column": 6791,
            "end_line": 4,
            "end_column": 7460,
            "start_byte": 6791,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]\n\n    @property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw\n\n    @writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)\n\n    def flush(self) -> None:\n        self._tw.flush()\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()\n\n    @property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected\n\n    def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})\n\n    def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line\n\n    def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]\n\n    def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)\n\n    def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)\n\n    def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)\n\n    def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types\n\n    def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color\n\n    def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))\n\n    def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 261,
            "start_column": 7463,
            "end_line": 0,
            "end_column": 40474,
            "start_byte": 7463,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]",
            "start_line": 262,
            "start_column": 7491,
            "end_line": 4,
            "end_column": 8496,
            "start_byte": 7491,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.writer",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw",
            "start_line": 286,
            "start_column": 8502,
            "end_line": 4,
            "end_column": 8634,
            "start_byte": 8502,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.writer",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value",
            "start_line": 291,
            "start_column": 8640,
            "end_line": 4,
            "end_column": 8783,
            "start_byte": 8640,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 296,
            "start_column": 8789,
            "end_line": 4,
            "end_column": 9372,
            "start_byte": 8789,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 309,
            "start_column": 9378,
            "end_line": 4,
            "end_column": 9454,
            "start_byte": 9378,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 313,
            "start_column": 9460,
            "end_line": 4,
            "end_column": 9530,
            "start_byte": 9460,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath",
            "start_line": 317,
            "start_column": 9536,
            "end_line": 4,
            "end_column": 9679,
            "start_byte": 9536,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 323,
            "start_column": 9685,
            "end_line": 4,
            "end_column": 9769,
            "start_byte": 9685,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 327,
            "start_column": 9775,
            "end_line": 4,
            "end_column": 9850,
            "start_byte": 9775,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 331,
            "start_column": 9856,
            "end_line": 4,
            "end_column": 9983,
            "start_byte": 9856,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)",
            "start_line": 335,
            "start_column": 9989,
            "end_line": 4,
            "end_column": 10686,
            "start_byte": 9989,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 348,
            "start_column": 10692,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10692,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 357,
            "start_column": 10998,
            "end_line": 4,
            "end_column": 11120,
            "start_byte": 10998,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)",
            "start_line": 362,
            "start_column": 11126,
            "end_line": 4,
            "end_column": 11259,
            "start_byte": 11126,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.flush",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def flush(self) -> None:\n        self._tw.flush()",
            "start_line": 365,
            "start_column": 11265,
            "end_line": 4,
            "end_column": 11314,
            "start_byte": 11265,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 368,
            "start_column": 11320,
            "end_line": 4,
            "end_column": 11510,
            "start_byte": 11320,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 374,
            "start_column": 11516,
            "end_line": 4,
            "end_column": 12134,
            "start_byte": 11516,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 392,
            "start_column": 12140,
            "end_line": 4,
            "end_column": 12260,
            "start_byte": 12140,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 396,
            "start_column": 12266,
            "end_line": 4,
            "end_column": 12345,
            "start_byte": 12266,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 399,
            "start_column": 12351,
            "end_line": 4,
            "end_column": 12410,
            "start_byte": 12351,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._add_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()",
            "start_line": 402,
            "start_column": 12416,
            "end_line": 4,
            "end_column": 12648,
            "start_byte": 12416,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 408,
            "start_column": 12654,
            "end_line": 4,
            "end_column": 12811,
            "start_byte": 12654,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])",
            "start_line": 413,
            "start_column": 12817,
            "end_line": 4,
            "end_column": 13350,
            "start_byte": 12817,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 426,
            "start_column": 13356,
            "end_line": 4,
            "end_column": 13731,
            "start_byte": 13356,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)",
            "start_line": 434,
            "start_column": 13737,
            "end_line": 4,
            "end_column": 13817,
            "start_byte": 13737,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()",
            "start_line": 437,
            "start_column": 13823,
            "end_line": 4,
            "end_column": 14241,
            "start_byte": 13823,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()",
            "start_line": 448,
            "start_column": 14247,
            "end_line": 4,
            "end_column": 16159,
            "start_byte": 14247,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._is_last_item",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected",
            "start_line": 497,
            "start_column": 16165,
            "end_line": 4,
            "end_column": 16287,
            "start_byte": 16165,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})",
            "start_line": 501,
            "start_column": 16293,
            "end_line": 4,
            "end_column": 17210,
            "start_byte": 16293,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"",
            "start_line": 522,
            "start_column": 17216,
            "end_line": 4,
            "end_column": 17957,
            "start_byte": 17216,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})",
            "start_line": 539,
            "start_column": 17963,
            "end_line": 4,
            "end_column": 18259,
            "start_byte": 17963,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line",
            "start_line": 546,
            "start_column": 18265,
            "end_line": 4,
            "end_column": 18465,
            "start_byte": 18265,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)",
            "start_line": 551,
            "start_column": 18471,
            "end_line": 4,
            "end_column": 18821,
            "start_byte": 18471,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 559,
            "start_column": 18827,
            "end_line": 4,
            "end_column": 19212,
            "start_byte": 18827,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 569,
            "start_column": 19218,
            "end_line": 4,
            "end_column": 20633,
            "start_byte": 19218,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 609,
            "start_column": 20639,
            "end_line": 4,
            "end_column": 21805,
            "start_byte": 20639,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 637,
            "start_column": 21811,
            "end_line": 4,
            "end_column": 21954,
            "start_byte": 21811,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 642,
            "start_column": 21960,
            "end_line": 4,
            "end_column": 22615,
            "start_byte": 21960,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)",
            "start_line": 659,
            "start_column": 22621,
            "end_line": 4,
            "end_column": 23336,
            "start_byte": 22621,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))",
            "start_line": 679,
            "start_column": 23342,
            "end_line": 4,
            "end_column": 25064,
            "start_byte": 23342,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()",
            "start_line": 719,
            "start_column": 25070,
            "end_line": 4,
            "end_column": 26017,
            "start_byte": 25070,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 744,
            "start_column": 26023,
            "end_line": 4,
            "end_column": 26366,
            "start_byte": 26023,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 755,
            "start_column": 26372,
            "end_line": 4,
            "end_column": 26487,
            "start_byte": 26372,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 758,
            "start_column": 26493,
            "end_line": 4,
            "end_column": 26620,
            "start_byte": 26493,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 762,
            "start_column": 26626,
            "end_line": 4,
            "end_column": 27154,
            "start_byte": 26626,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 776,
            "start_column": 27160,
            "end_line": 4,
            "end_column": 27982,
            "start_byte": 27160,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 798,
            "start_column": 27988,
            "end_line": 4,
            "end_column": 28146,
            "start_byte": 27988,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 804,
            "start_column": 28152,
            "end_line": 4,
            "end_column": 28396,
            "start_byte": 28152,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 816,
            "start_column": 28448,
            "end_line": 4,
            "end_column": 28637,
            "start_byte": 28448,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 823,
            "start_column": 28643,
            "end_line": 4,
            "end_column": 31098,
            "start_byte": 28643,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 880,
            "start_column": 31104,
            "end_line": 4,
            "end_column": 31684,
            "start_byte": 31104,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_teardown_reports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]",
            "start_line": 894,
            "start_column": 31690,
            "end_line": 4,
            "end_column": 31916,
            "start_byte": 31690,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._handle_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)",
            "start_line": 901,
            "start_column": 31922,
            "end_line": 4,
            "end_column": 32086,
            "start_byte": 31922,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 905,
            "start_column": 32092,
            "end_line": 4,
            "end_column": 32598,
            "start_byte": 32092,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 918,
            "start_column": 32604,
            "end_line": 4,
            "end_column": 33288,
            "start_byte": 32604,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 935,
            "start_column": 33294,
            "end_line": 4,
            "end_column": 33890,
            "start_byte": 33294,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 950,
            "start_column": 33896,
            "end_line": 4,
            "end_column": 34353,
            "start_byte": 33896,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)",
            "start_line": 963,
            "start_column": 34359,
            "end_line": 4,
            "end_column": 35728,
            "start_byte": 34359,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 1000,
            "start_column": 35734,
            "end_line": 4,
            "end_column": 38473,
            "start_byte": 35734,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types",
            "start_line": 1069,
            "start_column": 38479,
            "end_line": 4,
            "end_column": 38777,
            "start_byte": 38479,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color",
            "start_line": 1076,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 39231,
            "start_byte": 38783,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))",
            "start_line": 1088,
            "start_column": 39237,
            "end_line": 4,
            "end_column": 39722,
            "start_byte": 39237,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.build_summary_stats_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 1097,
            "start_column": 39728,
            "end_line": 4,
            "end_column": 40474,
            "start_byte": 39728,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/main.py",
            "file_content": "@attr.s\nclass _bestrelpath_cache(dict):\n    path = attr.ib(type=py.path.local)\n\n    def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
            "start_line": 357,
            "start_column": 11180,
            "end_line": 0,
            "end_column": 11407,
            "start_byte": 11180,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/main.py",
            "file_content": "path = attr.ib(type=py.path.local)",
            "start_line": 359,
            "start_column": 11224,
            "end_line": 4,
            "end_column": 11258,
            "start_byte": 11224,
            "end_byte": 4
          },
          {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
            "start_line": 361,
            "start_column": 11264,
            "end_line": 4,
            "end_column": 11407,
            "start_byte": 11264,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11410,
            "end_line": 0,
            "end_column": 24577,
            "start_byte": 11410,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11448,
            "end_line": 4,
            "end_column": 11473,
            "start_byte": 11448,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11478,
            "end_line": 4,
            "end_column": 11493,
            "start_byte": 11478,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11554,
            "end_line": 4,
            "end_column": 11572,
            "start_byte": 11554,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11655,
            "end_line": 4,
            "end_column": 11677,
            "start_byte": 11655,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11706,
            "end_line": 4,
            "end_column": 11723,
            "start_byte": 11706,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11759,
            "end_line": 4,
            "end_column": 13037,
            "start_byte": 11759,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13043,
            "end_line": 4,
            "end_column": 13124,
            "start_byte": 13043,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13130,
            "end_line": 4,
            "end_column": 13410,
            "start_byte": 13130,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13416,
            "end_line": 4,
            "end_column": 13581,
            "start_byte": 13416,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13587,
            "end_line": 4,
            "end_column": 13801,
            "start_byte": 13587,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13807,
            "end_line": 4,
            "end_column": 14169,
            "start_byte": 13807,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14175,
            "end_line": 4,
            "end_column": 14222,
            "start_byte": 14175,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14228,
            "end_line": 4,
            "end_column": 14297,
            "start_byte": 14228,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14303,
            "end_line": 4,
            "end_column": 14394,
            "start_byte": 14303,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14400,
            "end_line": 4,
            "end_column": 14868,
            "start_byte": 14400,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14874,
            "end_line": 4,
            "end_column": 16108,
            "start_byte": 14874,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16114,
            "end_line": 4,
            "end_column": 16849,
            "start_byte": 16114,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16855,
            "end_line": 4,
            "end_column": 20651,
            "start_byte": 16855,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20657,
            "end_line": 4,
            "end_column": 20727,
            "start_byte": 20657,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20733,
            "end_line": 4,
            "end_column": 21337,
            "start_byte": 20733,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21343,
            "end_line": 4,
            "end_column": 22028,
            "start_byte": 21343,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22034,
            "end_line": 4,
            "end_column": 22418,
            "start_byte": 22034,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22424,
            "end_line": 4,
            "end_column": 24102,
            "start_byte": 22424,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24108,
            "end_line": 4,
            "end_column": 24577,
            "start_byte": 24108,
            "end_byte": 4
          },
          {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 801,
            "start_column": 26154,
            "end_line": 4,
            "end_column": 26171,
            "start_byte": 26154,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "Scratch Pad for Analyzing the Problem:\n\n1. Analyze User Instructions:\n1.1 What issue is the user describing?\n- The user is describing an issue with pytest where the file paths are displayed as relative to the new directory (after it was changed in a fixture) instead of the original directory during test failures.\n\n1.2 How was this issue caused?\n- The issue is caused by changing the working directory during test execution, making the paths relative to the new directory, leading to a mismatch in expected vs displayed paths.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result is that even after changing the working directory, the paths displayed in the error messages should remain relative to the original directory.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- The expectation is that the test framework should handle directory changes gracefully and keep displaying paths as relative to the initial directory.\n\n1.5 How should the issue be fixed to meet the expectation?\n- The issue can be fixed by ensuring that the path calculation logic always uses the original directory as the base rather than the current working directory.\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each lines in the <symbol> and <symbol> tags.\n2.2. Match the symbol/code/pattern with the key elements, functions, variables, or patterns identified in the reported issue.\n- Focus on the path calculation logic and directory handling within the pytest code, particularly related to failures and path reporting.\n2.3. Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n- Determine if the symbols are involved in directory resolution and path reporting.\n2.4. make the decision how many symbols need to be change to resolve the issue.\n2.5. if you need more file content or symbol information, you can ask the user for more information.\n2.6. relative symbol means, He might be the root cause of the problem, or he could contribute to reproducing the issue.",
        "symbols": [
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "reason": "The function `_node_location_to_relpath` in the `Session` class is responsible for translating node paths to relative paths using a cache. It likely needs adjustment to ensure it uses the original execution directory rather than the changed working directory."
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "reason": "The `__init__` method initializes the `Session` class, including setting the `startdir` and the `_bestrelpathcache`. Modifications might be necessary to ensure these are set to the original directory only, regardless of any runtime directory changes."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "Analyzing _pytest.main._bestrelpath_cache:\n- This class is involved in path caching. Specifically, it attempts to find the best relative path using the `bestrelpath` method. It can affect how paths are resolved in the framework when directories change.\n\nAnalyzing _pytest.main._bestrelpath_cache.path:\n- The `path` attribute holds a directory that is used for relative path calculations. This needs to be set based on the initial directory context.\n\nAnalyzing _pytest.main._bestrelpath_cache.__missing__:\n- The `__missing__` method looks like it caches results of the `bestrelpath` function call to avoid recalculating relative paths. The calculation needs to use the original directory.\n\nAnalyzing _pytest.main.Session:\n- The Session class likely handles test sessions, maintaining the context in which tests are run, including directory paths.\n\nAnalyzing _pytest.main.Session.Interrupted, Failed, _setupstate, _fixturemanager, exitstatus:\n- These attributes may not be directly relevant as they handle session state and termination details, not path matters.\n\nAnalyzing _pytest.main.Session.__init__ :\n - This is where the session is set up, including directory handling. It might need to modify how directories are set/cached initially.",
          " - This might need adjustments."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:35:41.054715",
        "usage": "5.45191764831543 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.fixtures.FixtureRequest.fspath",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def fspath(self) -> py.path.local:\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore",
              "start_line": 432,
              "start_column": 16222,
              "end_line": 4,
              "end_column": 16481,
              "start_byte": 16222,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raise pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
              "start_line": 482,
              "start_column": 18125,
              "end_line": 4,
              "end_column": 18655,
              "start_byte": 18125,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
              "start_line": 624,
              "start_column": 24177,
              "end_line": 4,
              "end_column": 24816,
              "start_byte": 24177,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
              "start_line": 1273,
              "start_column": 48023,
              "end_line": 4,
              "end_column": 48743,
              "start_byte": 48023,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.RE_IMPORT_ERROR_NAME",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "RE_IMPORT_ERROR_NAME = re.compile(r\"^No module named (.*)$\")",
              "start_line": 12,
              "start_column": 251,
              "end_line": 0,
              "end_column": 311,
              "start_byte": 251,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.monkeypatch",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "@fixture\ndef monkeypatch():\n    \"\"\"The returned ``monkeypatch`` fixture provides these\n    helper methods to modify objects, dictionaries or os.environ::\n\n        monkeypatch.setattr(obj, name, value, raising=True)\n        monkeypatch.delattr(obj, name, raising=True)\n        monkeypatch.setitem(mapping, name, value)\n        monkeypatch.delitem(obj, name, raising=True)\n        monkeypatch.setenv(name, value, prepend=False)\n        monkeypatch.delenv(name, raising=True)\n        monkeypatch.syspath_prepend(path)\n        monkeypatch.chdir(path)\n\n    All modifications will be undone after the requesting\n    test function or fixture has finished. The ``raising``\n    parameter determines if a KeyError or AttributeError\n    will be raised if the set/deletion operation has no target.\n    \"\"\"\n    mpatch = MonkeyPatch()\n    yield mpatch\n    mpatch.undo()",
              "start_line": 15,
              "start_column": 314,
              "end_line": 0,
              "end_column": 1169,
              "start_byte": 314,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.resolve",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def resolve(name):\n    # simplified from zope.dottedname\n    parts = name.split(\".\")\n\n    used = parts.pop(0)\n    found = __import__(used)\n    for part in parts:\n        used += \".\" + part\n        try:\n            found = getattr(found, part)\n        except AttributeError:\n            pass\n        else:\n            continue\n        # we use explicit un-nesting of the handling block in order\n        # to avoid nested exceptions on python 3\n        try:\n            __import__(used)\n        except ImportError as ex:\n            # str is used for py2 vs py3\n            expected = str(ex).split()[-1]\n            if expected == used:\n                raise\n            else:\n                raise ImportError(\"import error in {}: {}\".format(used, ex))\n        found = annotated_getattr(found, part, used)\n    return found",
              "start_line": 39,
              "start_column": 1172,
              "end_line": 0,
              "end_column": 1994,
              "start_byte": 1172,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.annotated_getattr",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def annotated_getattr(obj, name, ann):\n    try:\n        obj = getattr(obj, name)\n    except AttributeError:\n        raise AttributeError(\n            \"{!r} object at {} has no attribute {!r}\".format(\n                type(obj).__name__, ann, name\n            )\n        )\n    return obj",
              "start_line": 68,
              "start_column": 1997,
              "end_line": 0,
              "end_column": 2281,
              "start_byte": 1997,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.derive_importpath",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def derive_importpath(import_path, raising):\n    if not isinstance(import_path, str) or \".\" not in import_path:\n        raise TypeError(\n            \"must be absolute import path string, not {!r}\".format(import_path)\n        )\n    module, attr = import_path.rsplit(\".\", 1)\n    target = resolve(module)\n    if raising:\n        annotated_getattr(target, attr, ann=module)\n    return attr, target",
              "start_line": 80,
              "start_column": 2284,
              "end_line": 0,
              "end_column": 2677,
              "start_byte": 2284,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.Notset",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "class Notset:\n    def __repr__(self):\n        return \"<notset>\"",
              "start_line": 92,
              "start_column": 2680,
              "end_line": 0,
              "end_column": 2743,
              "start_byte": 2680,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.Notset.__repr__",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def __repr__(self):\n        return \"<notset>\"",
              "start_line": 93,
              "start_column": 2698,
              "end_line": 4,
              "end_column": 2743,
              "start_byte": 2698,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.notset",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "notset = Notset()",
              "start_line": 97,
              "start_column": 2746,
              "end_line": 0,
              "end_column": 2763,
              "start_byte": 2746,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "class MonkeyPatch:\n    \"\"\" Object returned by the ``monkeypatch`` fixture keeping a record of setattr/item/env/syspath changes.\n    \"\"\"\n\n    def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None\n\n    @contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()\n\n    def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)\n\n    def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)\n\n    def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value\n\n    def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]\n\n    def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)\n\n    def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)\n\n    def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()\n\n    def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)\n\n    def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
              "start_line": 100,
              "start_column": 2766,
              "end_line": 0,
              "end_column": 11401,
              "start_byte": 2766,
              "end_byte": 0
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.__init__",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None",
              "start_line": 104,
              "start_column": 2907,
              "end_line": 4,
              "end_column": 3038,
              "start_byte": 2907,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.context",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "@contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()",
              "start_line": 110,
              "start_column": 3044,
              "end_line": 4,
              "end_column": 3875,
              "start_byte": 3044,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.setattr",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)",
              "start_line": 135,
              "start_column": 3881,
              "end_line": 4,
              "end_column": 5427,
              "start_byte": 3881,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.delattr",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)",
              "start_line": 172,
              "start_column": 5433,
              "end_line": 4,
              "end_column": 6739,
              "start_byte": 5433,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.setitem",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value",
              "start_line": 206,
              "start_column": 6745,
              "end_line": 4,
              "end_column": 6928,
              "start_byte": 6745,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.delitem",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]",
              "start_line": 211,
              "start_column": 6934,
              "end_line": 4,
              "end_column": 7362,
              "start_byte": 6934,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.setenv",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)",
              "start_line": 224,
              "start_column": 7368,
              "end_line": 4,
              "end_column": 8244,
              "start_byte": 7368,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.delenv",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)",
              "start_line": 243,
              "start_column": 8250,
              "end_line": 4,
              "end_column": 8567,
              "start_byte": 8250,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.syspath_prepend",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()",
              "start_line": 252,
              "start_column": 8573,
              "end_line": 4,
              "end_column": 9520,
              "start_byte": 8573,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.chdir",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)",
              "start_line": 274,
              "start_column": 9526,
              "end_line": 4,
              "end_column": 9989,
              "start_byte": 9526,
              "end_byte": 4
            },
            {
              "name": "_pytest.monkeypatch.MonkeyPatch.undo",
              "file_path": "src/_pytest/monkeypatch.py",
              "file_content": "def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
              "start_line": 288,
              "start_column": 9995,
              "end_line": 4,
              "end_column": 11401,
              "start_byte": 9995,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.WarningReport.get_location",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def get_location(self, config):\n        \"\"\"\n        Returns the more user-friendly information about the location\n        of a warning, or None.\n        \"\"\"\n        if self.nodeid:\n            return self.nodeid\n        if self.fslocation:\n            if isinstance(self.fslocation, tuple) and len(self.fslocation) >= 2:\n                filename, linenum = self.fslocation[:2]\n                relpath = py.path.local(filename).relto(config.invocation_dir)\n                if not relpath:\n                    relpath = str(filename)\n                return \"{}:{}\".format(relpath, linenum)\n            else:\n                return str(self.fslocation)\n        return None",
              "start_line": 242,
              "start_column": 6791,
              "end_line": 4,
              "end_column": 7460,
              "start_byte": 6791,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "class TerminalReporter:\n    def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]\n\n    @property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw\n\n    @writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)\n\n    def flush(self) -> None:\n        self._tw.flush()\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()\n\n    @property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected\n\n    def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})\n\n    def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line\n\n    def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]\n\n    def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)\n\n    def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)\n\n    def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)\n\n    def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types\n\n    def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color\n\n    def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))\n\n    def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
              "start_line": 261,
              "start_column": 7463,
              "end_line": 0,
              "end_column": 40474,
              "start_byte": 7463,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.TerminalReporter.__init__",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]",
              "start_line": 262,
              "start_column": 7491,
              "end_line": 4,
              "end_column": 8496,
              "start_byte": 7491,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.writer",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw",
              "start_line": 286,
              "start_column": 8502,
              "end_line": 4,
              "end_column": 8634,
              "start_byte": 8502,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.writer",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value",
              "start_line": 291,
              "start_column": 8640,
              "end_line": 4,
              "end_column": 8783,
              "start_byte": 8640,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
              "start_line": 296,
              "start_column": 8789,
              "end_line": 4,
              "end_column": 9372,
              "start_byte": 8789,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.verbosity",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
              "start_line": 309,
              "start_column": 9378,
              "end_line": 4,
              "end_column": 9454,
              "start_byte": 9378,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showheader",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
              "start_line": 313,
              "start_column": 9460,
              "end_line": 4,
              "end_column": 9530,
              "start_byte": 9460,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showfspath",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath",
              "start_line": 317,
              "start_column": 9536,
              "end_line": 4,
              "end_column": 9679,
              "start_byte": 9536,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showfspath",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
              "start_line": 323,
              "start_column": 9685,
              "end_line": 4,
              "end_column": 9769,
              "start_byte": 9685,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
              "start_line": 327,
              "start_column": 9775,
              "end_line": 4,
              "end_column": 9850,
              "start_byte": 9775,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.hasopt",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
              "start_line": 331,
              "start_column": 9856,
              "end_line": 4,
              "end_column": 9983,
              "start_byte": 9856,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)",
              "start_line": 335,
              "start_column": 9989,
              "end_line": 4,
              "end_column": 10686,
              "start_byte": 9989,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
              "start_line": 348,
              "start_column": 10692,
              "end_line": 4,
              "end_column": 10992,
              "start_byte": 10692,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.ensure_newline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
              "start_line": 357,
              "start_column": 10998,
              "end_line": 4,
              "end_column": 11120,
              "start_byte": 10998,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)",
              "start_line": 362,
              "start_column": 11126,
              "end_line": 4,
              "end_column": 11259,
              "start_byte": 11126,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.flush",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def flush(self) -> None:\n        self._tw.flush()",
              "start_line": 365,
              "start_column": 11265,
              "end_line": 4,
              "end_column": 11314,
              "start_byte": 11265,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
              "start_line": 368,
              "start_column": 11320,
              "end_line": 4,
              "end_column": 11510,
              "start_byte": 11320,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.rewrite",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
              "start_line": 374,
              "start_column": 11516,
              "end_line": 4,
              "end_column": 12134,
              "start_byte": 11516,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_sep",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
              "start_line": 392,
              "start_column": 12140,
              "end_line": 4,
              "end_column": 12260,
              "start_byte": 12140,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.section",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
              "start_line": 396,
              "start_column": 12266,
              "end_line": 4,
              "end_column": 12345,
              "start_byte": 12266,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
              "start_line": 399,
              "start_column": 12351,
              "end_line": 4,
              "end_column": 12410,
              "start_byte": 12351,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._add_stats",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()",
              "start_line": 402,
              "start_column": 12416,
              "end_line": 4,
              "end_column": 12648,
              "start_byte": 12416,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
              "start_line": 408,
              "start_column": 12654,
              "end_line": 4,
              "end_column": 12811,
              "start_byte": 12654,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])",
              "start_line": 413,
              "start_column": 12817,
              "end_line": 4,
              "end_column": 13350,
              "start_byte": 12817,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
              "start_line": 426,
              "start_column": 13356,
              "end_line": 4,
              "end_column": 13731,
              "start_byte": 13356,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)",
              "start_line": 434,
              "start_column": 13737,
              "end_line": 4,
              "end_column": 13817,
              "start_byte": 13737,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()",
              "start_line": 437,
              "start_column": 13823,
              "end_line": 4,
              "end_column": 14241,
              "start_byte": 13823,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()",
              "start_line": 448,
              "start_column": 14247,
              "end_line": 4,
              "end_column": 16159,
              "start_byte": 14247,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._is_last_item",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected",
              "start_line": 497,
              "start_column": 16165,
              "end_line": 4,
              "end_column": 16287,
              "start_byte": 16165,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})",
              "start_line": 501,
              "start_column": 16293,
              "end_line": 4,
              "end_column": 17210,
              "start_byte": 16293,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"",
              "start_line": 522,
              "start_column": 17216,
              "end_line": 4,
              "end_column": 17957,
              "start_byte": 17216,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})",
              "start_line": 539,
              "start_column": 17963,
              "end_line": 4,
              "end_column": 18259,
              "start_byte": 17963,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line",
              "start_line": 546,
              "start_column": 18265,
              "end_line": 4,
              "end_column": 18465,
              "start_byte": 18265,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)",
              "start_line": 551,
              "start_column": 18471,
              "end_line": 4,
              "end_column": 18821,
              "start_byte": 18471,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
              "start_line": 559,
              "start_column": 18827,
              "end_line": 4,
              "end_column": 19212,
              "start_byte": 18827,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.report_collect",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
              "start_line": 569,
              "start_column": 19218,
              "end_line": 4,
              "end_column": 20633,
              "start_byte": 19218,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
              "start_line": 609,
              "start_column": 20639,
              "end_line": 4,
              "end_column": 21805,
              "start_byte": 20639,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
              "start_line": 637,
              "start_column": 21811,
              "end_line": 4,
              "end_column": 21954,
              "start_byte": 21811,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
              "start_line": 642,
              "start_column": 21960,
              "end_line": 4,
              "end_column": 22615,
              "start_byte": 21960,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)",
              "start_line": 659,
              "start_column": 22621,
              "end_line": 4,
              "end_column": 23336,
              "start_byte": 22621,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))",
              "start_line": 679,
              "start_column": 23342,
              "end_line": 4,
              "end_column": 25064,
              "start_byte": 23342,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()",
              "start_line": 719,
              "start_column": 25070,
              "end_line": 4,
              "end_column": 26017,
              "start_byte": 25070,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
              "start_line": 744,
              "start_column": 26023,
              "end_line": 4,
              "end_column": 26366,
              "start_byte": 26023,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
              "start_line": 755,
              "start_column": 26372,
              "end_line": 4,
              "end_column": 26487,
              "start_byte": 26372,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
              "start_line": 758,
              "start_column": 26493,
              "end_line": 4,
              "end_column": 26620,
              "start_byte": 26493,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
              "start_line": 762,
              "start_column": 26626,
              "end_line": 4,
              "end_column": 27154,
              "start_byte": 26626,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._locationline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
              "start_line": 776,
              "start_column": 27160,
              "end_line": 4,
              "end_column": 27982,
              "start_byte": 27160,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
              "start_line": 798,
              "start_column": 27988,
              "end_line": 4,
              "end_column": 28146,
              "start_byte": 27988,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._getcrashline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
              "start_line": 804,
              "start_column": 28152,
              "end_line": 4,
              "end_column": 28396,
              "start_byte": 28152,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.getreports",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
              "start_line": 816,
              "start_column": 28448,
              "end_line": 4,
              "end_column": 28637,
              "start_byte": 28448,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_warnings",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
              "start_line": 823,
              "start_column": 28643,
              "end_line": 4,
              "end_column": 31098,
              "start_byte": 28643,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_passes",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
              "start_line": 880,
              "start_column": 31104,
              "end_line": 4,
              "end_column": 31684,
              "start_byte": 31104,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._get_teardown_reports",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]",
              "start_line": 894,
              "start_column": 31690,
              "end_line": 4,
              "end_column": 31916,
              "start_byte": 31690,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._handle_teardown_sections",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)",
              "start_line": 901,
              "start_column": 31922,
              "end_line": 4,
              "end_column": 32086,
              "start_byte": 31922,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
              "start_line": 905,
              "start_column": 32092,
              "end_line": 4,
              "end_column": 32598,
              "start_byte": 32092,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_failures",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
              "start_line": 918,
              "start_column": 32604,
              "end_line": 4,
              "end_column": 33288,
              "start_byte": 32604,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_errors",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
              "start_line": 935,
              "start_column": 33294,
              "end_line": 4,
              "end_column": 33890,
              "start_byte": 33294,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._outrep_summary",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
              "start_line": 950,
              "start_column": 33896,
              "end_line": 4,
              "end_column": 34353,
              "start_byte": 33896,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_stats",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)",
              "start_line": 963,
              "start_column": 34359,
              "end_line": 4,
              "end_column": 35728,
              "start_byte": 34359,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.short_test_summary",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
              "start_line": 1000,
              "start_column": 35734,
              "end_line": 4,
              "end_column": 38473,
              "start_byte": 35734,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._get_main_color",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types",
              "start_line": 1069,
              "start_column": 38479,
              "end_line": 4,
              "end_column": 38777,
              "start_byte": 38479,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._determine_main_color",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color",
              "start_line": 1076,
              "start_column": 38783,
              "end_line": 4,
              "end_column": 39231,
              "start_byte": 38783,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._set_main_color",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))",
              "start_line": 1088,
              "start_column": 39237,
              "end_line": 4,
              "end_column": 39722,
              "start_byte": 39237,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.build_summary_stats_line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
              "start_line": 1097,
              "start_column": 39728,
              "end_line": 4,
              "end_column": 40474,
              "start_byte": 39728,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.main._bestrelpath_cache",
              "file_path": "src/_pytest/main.py",
              "file_content": "@attr.s\nclass _bestrelpath_cache(dict):\n    path = attr.ib(type=py.path.local)\n\n    def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
              "start_line": 357,
              "start_column": 11180,
              "end_line": 0,
              "end_column": 11407,
              "start_byte": 11180,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._bestrelpath_cache.path",
              "file_path": "src/_pytest/main.py",
              "file_content": "path = attr.ib(type=py.path.local)",
              "start_line": 359,
              "start_column": 11224,
              "end_line": 4,
              "end_column": 11258,
              "start_byte": 11224,
              "end_byte": 4
            },
            {
              "name": "_pytest.main._bestrelpath_cache.__missing__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
              "start_line": 361,
              "start_column": 11264,
              "end_line": 4,
              "end_column": 11407,
              "start_byte": 11264,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session",
              "file_path": "src/_pytest/main.py",
              "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
              "start_line": 367,
              "start_column": 11410,
              "end_line": 0,
              "end_column": 24577,
              "start_byte": 11410,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.Interrupted",
              "file_path": "src/_pytest/main.py",
              "file_content": "Interrupted = Interrupted",
              "start_line": 368,
              "start_column": 11448,
              "end_line": 4,
              "end_column": 11473,
              "start_byte": 11448,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.Failed",
              "file_path": "src/_pytest/main.py",
              "file_content": "Failed = Failed",
              "start_line": 369,
              "start_column": 11478,
              "end_line": 4,
              "end_column": 11493,
              "start_byte": 11478,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._setupstate",
              "file_path": "src/_pytest/main.py",
              "file_content": "_setupstate = None",
              "start_line": 371,
              "start_column": 11554,
              "end_line": 4,
              "end_column": 11572,
              "start_byte": 11554,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._fixturemanager",
              "file_path": "src/_pytest/main.py",
              "file_content": "_fixturemanager = None",
              "start_line": 373,
              "start_column": 11655,
              "end_line": 4,
              "end_column": 11677,
              "start_byte": 11655,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.exitstatus",
              "file_path": "src/_pytest/main.py",
              "file_content": "exitstatus = None",
              "start_line": 374,
              "start_column": 11706,
              "end_line": 4,
              "end_column": 11723,
              "start_byte": 11706,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__init__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
              "start_line": 376,
              "start_column": 11759,
              "end_line": 4,
              "end_column": 13037,
              "start_byte": 11759,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.from_config",
              "file_path": "src/_pytest/main.py",
              "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
              "start_line": 408,
              "start_column": 13043,
              "end_line": 4,
              "end_column": 13124,
              "start_byte": 13043,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__repr__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
              "start_line": 412,
              "start_column": 13130,
              "end_line": 4,
              "end_column": 13410,
              "start_byte": 13130,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._node_location_to_relpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
              "start_line": 421,
              "start_column": 13416,
              "end_line": 4,
              "end_column": 13581,
              "start_byte": 13416,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectstart",
              "file_path": "src/_pytest/main.py",
              "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
              "start_line": 425,
              "start_column": 13587,
              "end_line": 4,
              "end_column": 13801,
              "start_byte": 13587,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_runtest_logreport",
              "file_path": "src/_pytest/main.py",
              "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
              "start_line": 432,
              "start_column": 13807,
              "end_line": 4,
              "end_column": 14169,
              "start_byte": 13807,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectreport",
              "file_path": "src/_pytest/main.py",
              "file_content": "pytest_collectreport = pytest_runtest_logreport",
              "start_line": 440,
              "start_column": 14175,
              "end_line": 4,
              "end_column": 14222,
              "start_byte": 14175,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.isinitpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
              "start_line": 442,
              "start_column": 14228,
              "end_line": 4,
              "end_column": 14297,
              "start_byte": 14228,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/main.py",
              "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
              "start_line": 445,
              "start_column": 14303,
              "end_line": 4,
              "end_column": 14394,
              "start_byte": 14303,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
              "start_line": 448,
              "start_column": 14400,
              "end_line": 4,
              "end_column": 14868,
              "start_byte": 14400,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
              "start_line": 461,
              "start_column": 14874,
              "end_line": 4,
              "end_column": 16108,
              "start_byte": 14874,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
              "start_line": 492,
              "start_column": 16114,
              "end_line": 4,
              "end_column": 16849,
              "start_byte": 16114,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
              "start_line": 510,
              "start_column": 16855,
              "end_line": 4,
              "end_column": 20651,
              "start_byte": 16855,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._visit_filter",
              "file_path": "src/_pytest/main.py",
              "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
              "start_line": 589,
              "start_column": 20657,
              "end_line": 4,
              "end_column": 20727,
              "start_byte": 20657,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._tryconvertpyarg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
              "start_line": 593,
              "start_column": 20733,
              "end_line": 4,
              "end_column": 21337,
              "start_byte": 20733,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._parsearg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
              "start_line": 609,
              "start_column": 21343,
              "end_line": 4,
              "end_column": 22028,
              "start_byte": 21343,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.matchnodes",
              "file_path": "src/_pytest/main.py",
              "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
              "start_line": 625,
              "start_column": 22034,
              "end_line": 4,
              "end_column": 22418,
              "start_byte": 22034,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._matchnodes",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
              "start_line": 636,
              "start_column": 22424,
              "end_line": 4,
              "end_column": 24102,
              "start_byte": 22424,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.genitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
              "start_line": 673,
              "start_column": 24108,
              "end_line": 4,
              "end_column": 24577,
              "start_byte": 24108,
              "end_byte": 4
            },
            {
              "name": "_pytest.pytester.Testdir.Session",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 801,
              "start_column": 26154,
              "end_line": 4,
              "end_column": 26171,
              "start_byte": 26154,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Scratch Pad for Analyzing the Problem:\n\n1. Analyze User Instructions:\n1.1 What issue is the user describing?\n- The user is describing an issue with pytest where the file paths are displayed as relative to the new directory (after it was changed in a fixture) instead of the original directory during test failures.\n\n1.2 How was this issue caused?\n- The issue is caused by changing the working directory during test execution, making the paths relative to the new directory, leading to a mismatch in expected vs displayed paths.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result is that even after changing the working directory, the paths displayed in the error messages should remain relative to the original directory.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- The expectation is that the test framework should handle directory changes gracefully and keep displaying paths as relative to the initial directory.\n\n1.5 How should the issue be fixed to meet the expectation?\n- The issue can be fixed by ensuring that the path calculation logic always uses the original directory as the base rather than the current working directory.\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each lines in the <symbol> and <symbol> tags.\n2.2. Match the symbol/code/pattern with the key elements, functions, variables, or patterns identified in the reported issue.\n- Focus on the path calculation logic and directory handling within the pytest code, particularly related to failures and path reporting.\n2.3. Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n- Determine if the symbols are involved in directory resolution and path reporting.\n2.4. make the decision how many symbols need to be change to resolve the issue.\n2.5. if you need more file content or symbol information, you can ask the user for more information.\n2.6. relative symbol means, He might be the root cause of the problem, or he could contribute to reproducing the issue.",
          "symbols": [
            {
              "name": "_pytest.main.Session._node_location_to_relpath",
              "file_path": "src/_pytest/main.py",
              "reason": "The function `_node_location_to_relpath` in the `Session` class is responsible for translating node paths to relative paths using a cache. It likely needs adjustment to ensure it uses the original execution directory rather than the changed working directory."
            },
            {
              "name": "_pytest.main.Session.__init__",
              "file_path": "src/_pytest/main.py",
              "reason": "The `__init__` method initializes the `Session` class, including setting the `startdir` and the `_bestrelpathcache`. Modifications might be necessary to ensure these are set to the original directory only, regardless of any runtime directory changes."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "Analyzing _pytest.main._bestrelpath_cache:\n- This class is involved in path caching. Specifically, it attempts to find the best relative path using the `bestrelpath` method. It can affect how paths are resolved in the framework when directories change.\n\nAnalyzing _pytest.main._bestrelpath_cache.path:\n- The `path` attribute holds a directory that is used for relative path calculations. This needs to be set based on the initial directory context.\n\nAnalyzing _pytest.main._bestrelpath_cache.__missing__:\n- The `__missing__` method looks like it caches results of the `bestrelpath` function call to avoid recalculating relative paths. The calculation needs to use the original directory.\n\nAnalyzing _pytest.main.Session:\n- The Session class likely handles test sessions, maintaining the context in which tests are run, including directory paths.\n\nAnalyzing _pytest.main.Session.Interrupted, Failed, _setupstate, _fixturemanager, exitstatus:\n- These attributes may not be directly relevant as they handle session state and termination details, not path matters.\n\nAnalyzing _pytest.main.Session.__init__ :\n - This is where the session is set up, including directory handling. It might need to modify how directories are set/cached initially.",
            " - This might need adjustments."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/main.py"
        ],
        "symbols": [
          "_pytest.main.Session._node_location_to_relpath",
          "_pytest.main.Session.__init__"
        ],
        "code_spans": {
          "_pytest.fixtures.FixtureRequest.fspath": {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self) -> py.path.local:\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore",
            "start_line": 432,
            "start_column": 16222,
            "end_line": 4,
            "end_column": 16481,
            "start_byte": 16222,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.getfixturevalue": {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raise pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 482,
            "start_column": 18125,
            "end_line": 4,
            "end_column": 18655,
            "start_byte": 18125,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._getscopeitem": {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 624,
            "start_column": 24177,
            "end_line": 4,
            "end_column": 24816,
            "start_byte": 24177,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureinfo": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1273,
            "start_column": 48023,
            "end_line": 4,
            "end_column": 48743,
            "start_byte": 48023,
            "end_byte": 4
          },
          "_pytest.monkeypatch.RE_IMPORT_ERROR_NAME": {
            "name": "_pytest.monkeypatch.RE_IMPORT_ERROR_NAME",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "RE_IMPORT_ERROR_NAME = re.compile(r\"^No module named (.*)$\")",
            "start_line": 12,
            "start_column": 251,
            "end_line": 0,
            "end_column": 311,
            "start_byte": 251,
            "end_byte": 0
          },
          "_pytest.monkeypatch.monkeypatch": {
            "name": "_pytest.monkeypatch.monkeypatch",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "@fixture\ndef monkeypatch():\n    \"\"\"The returned ``monkeypatch`` fixture provides these\n    helper methods to modify objects, dictionaries or os.environ::\n\n        monkeypatch.setattr(obj, name, value, raising=True)\n        monkeypatch.delattr(obj, name, raising=True)\n        monkeypatch.setitem(mapping, name, value)\n        monkeypatch.delitem(obj, name, raising=True)\n        monkeypatch.setenv(name, value, prepend=False)\n        monkeypatch.delenv(name, raising=True)\n        monkeypatch.syspath_prepend(path)\n        monkeypatch.chdir(path)\n\n    All modifications will be undone after the requesting\n    test function or fixture has finished. The ``raising``\n    parameter determines if a KeyError or AttributeError\n    will be raised if the set/deletion operation has no target.\n    \"\"\"\n    mpatch = MonkeyPatch()\n    yield mpatch\n    mpatch.undo()",
            "start_line": 15,
            "start_column": 314,
            "end_line": 0,
            "end_column": 1169,
            "start_byte": 314,
            "end_byte": 0
          },
          "_pytest.monkeypatch.resolve": {
            "name": "_pytest.monkeypatch.resolve",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def resolve(name):\n    # simplified from zope.dottedname\n    parts = name.split(\".\")\n\n    used = parts.pop(0)\n    found = __import__(used)\n    for part in parts:\n        used += \".\" + part\n        try:\n            found = getattr(found, part)\n        except AttributeError:\n            pass\n        else:\n            continue\n        # we use explicit un-nesting of the handling block in order\n        # to avoid nested exceptions on python 3\n        try:\n            __import__(used)\n        except ImportError as ex:\n            # str is used for py2 vs py3\n            expected = str(ex).split()[-1]\n            if expected == used:\n                raise\n            else:\n                raise ImportError(\"import error in {}: {}\".format(used, ex))\n        found = annotated_getattr(found, part, used)\n    return found",
            "start_line": 39,
            "start_column": 1172,
            "end_line": 0,
            "end_column": 1994,
            "start_byte": 1172,
            "end_byte": 0
          },
          "_pytest.monkeypatch.annotated_getattr": {
            "name": "_pytest.monkeypatch.annotated_getattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def annotated_getattr(obj, name, ann):\n    try:\n        obj = getattr(obj, name)\n    except AttributeError:\n        raise AttributeError(\n            \"{!r} object at {} has no attribute {!r}\".format(\n                type(obj).__name__, ann, name\n            )\n        )\n    return obj",
            "start_line": 68,
            "start_column": 1997,
            "end_line": 0,
            "end_column": 2281,
            "start_byte": 1997,
            "end_byte": 0
          },
          "_pytest.monkeypatch.derive_importpath": {
            "name": "_pytest.monkeypatch.derive_importpath",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def derive_importpath(import_path, raising):\n    if not isinstance(import_path, str) or \".\" not in import_path:\n        raise TypeError(\n            \"must be absolute import path string, not {!r}\".format(import_path)\n        )\n    module, attr = import_path.rsplit(\".\", 1)\n    target = resolve(module)\n    if raising:\n        annotated_getattr(target, attr, ann=module)\n    return attr, target",
            "start_line": 80,
            "start_column": 2284,
            "end_line": 0,
            "end_column": 2677,
            "start_byte": 2284,
            "end_byte": 0
          },
          "_pytest.monkeypatch.Notset": {
            "name": "_pytest.monkeypatch.Notset",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "class Notset:\n    def __repr__(self):\n        return \"<notset>\"",
            "start_line": 92,
            "start_column": 2680,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2680,
            "end_byte": 0
          },
          "_pytest.monkeypatch.Notset.__repr__": {
            "name": "_pytest.monkeypatch.Notset.__repr__",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def __repr__(self):\n        return \"<notset>\"",
            "start_line": 93,
            "start_column": 2698,
            "end_line": 4,
            "end_column": 2743,
            "start_byte": 2698,
            "end_byte": 4
          },
          "_pytest.monkeypatch.notset": {
            "name": "_pytest.monkeypatch.notset",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "notset = Notset()",
            "start_line": 97,
            "start_column": 2746,
            "end_line": 0,
            "end_column": 2763,
            "start_byte": 2746,
            "end_byte": 0
          },
          "_pytest.monkeypatch.MonkeyPatch": {
            "name": "_pytest.monkeypatch.MonkeyPatch",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "class MonkeyPatch:\n    \"\"\" Object returned by the ``monkeypatch`` fixture keeping a record of setattr/item/env/syspath changes.\n    \"\"\"\n\n    def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None\n\n    @contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()\n\n    def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)\n\n    def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)\n\n    def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value\n\n    def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]\n\n    def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)\n\n    def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)\n\n    def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()\n\n    def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)\n\n    def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 100,
            "start_column": 2766,
            "end_line": 0,
            "end_column": 11401,
            "start_byte": 2766,
            "end_byte": 0
          },
          "_pytest.monkeypatch.MonkeyPatch.__init__": {
            "name": "_pytest.monkeypatch.MonkeyPatch.__init__",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None",
            "start_line": 104,
            "start_column": 2907,
            "end_line": 4,
            "end_column": 3038,
            "start_byte": 2907,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.context": {
            "name": "_pytest.monkeypatch.MonkeyPatch.context",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "@contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()",
            "start_line": 110,
            "start_column": 3044,
            "end_line": 4,
            "end_column": 3875,
            "start_byte": 3044,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.setattr": {
            "name": "_pytest.monkeypatch.MonkeyPatch.setattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)",
            "start_line": 135,
            "start_column": 3881,
            "end_line": 4,
            "end_column": 5427,
            "start_byte": 3881,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.delattr": {
            "name": "_pytest.monkeypatch.MonkeyPatch.delattr",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)",
            "start_line": 172,
            "start_column": 5433,
            "end_line": 4,
            "end_column": 6739,
            "start_byte": 5433,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.setitem": {
            "name": "_pytest.monkeypatch.MonkeyPatch.setitem",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value",
            "start_line": 206,
            "start_column": 6745,
            "end_line": 4,
            "end_column": 6928,
            "start_byte": 6745,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.delitem": {
            "name": "_pytest.monkeypatch.MonkeyPatch.delitem",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]",
            "start_line": 211,
            "start_column": 6934,
            "end_line": 4,
            "end_column": 7362,
            "start_byte": 6934,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.setenv": {
            "name": "_pytest.monkeypatch.MonkeyPatch.setenv",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)",
            "start_line": 224,
            "start_column": 7368,
            "end_line": 4,
            "end_column": 8244,
            "start_byte": 7368,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.delenv": {
            "name": "_pytest.monkeypatch.MonkeyPatch.delenv",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)",
            "start_line": 243,
            "start_column": 8250,
            "end_line": 4,
            "end_column": 8567,
            "start_byte": 8250,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.syspath_prepend": {
            "name": "_pytest.monkeypatch.MonkeyPatch.syspath_prepend",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()",
            "start_line": 252,
            "start_column": 8573,
            "end_line": 4,
            "end_column": 9520,
            "start_byte": 8573,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.chdir": {
            "name": "_pytest.monkeypatch.MonkeyPatch.chdir",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)",
            "start_line": 274,
            "start_column": 9526,
            "end_line": 4,
            "end_column": 9989,
            "start_byte": 9526,
            "end_byte": 4
          },
          "_pytest.monkeypatch.MonkeyPatch.undo": {
            "name": "_pytest.monkeypatch.MonkeyPatch.undo",
            "file_path": "src/_pytest/monkeypatch.py",
            "file_content": "def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None",
            "start_line": 288,
            "start_column": 9995,
            "end_line": 4,
            "end_column": 11401,
            "start_byte": 9995,
            "end_byte": 4
          },
          "_pytest.terminal.WarningReport.get_location": {
            "name": "_pytest.terminal.WarningReport.get_location",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def get_location(self, config):\n        \"\"\"\n        Returns the more user-friendly information about the location\n        of a warning, or None.\n        \"\"\"\n        if self.nodeid:\n            return self.nodeid\n        if self.fslocation:\n            if isinstance(self.fslocation, tuple) and len(self.fslocation) >= 2:\n                filename, linenum = self.fslocation[:2]\n                relpath = py.path.local(filename).relto(config.invocation_dir)\n                if not relpath:\n                    relpath = str(filename)\n                return \"{}:{}\".format(relpath, linenum)\n            else:\n                return str(self.fslocation)\n        return None",
            "start_line": 242,
            "start_column": 6791,
            "end_line": 4,
            "end_column": 7460,
            "start_byte": 6791,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter": {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]\n\n    @property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw\n\n    @writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)\n\n    def flush(self) -> None:\n        self._tw.flush()\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()\n\n    @property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected\n\n    def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})\n\n    def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line\n\n    def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]\n\n    def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)\n\n    def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)\n\n    def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)\n\n    def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types\n\n    def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color\n\n    def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))\n\n    def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 261,
            "start_column": 7463,
            "end_line": 0,
            "end_column": 40474,
            "start_byte": 7463,
            "end_byte": 0
          },
          "_pytest.terminal.TerminalReporter.__init__": {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]",
            "start_line": 262,
            "start_column": 7491,
            "end_line": 4,
            "end_column": 8496,
            "start_byte": 7491,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.writer": {
            "name": "_pytest.terminal.TerminalReporter.writer",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value",
            "start_line": 291,
            "start_column": 8640,
            "end_line": 4,
            "end_column": 8783,
            "start_byte": 8640,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._determine_show_progress_info": {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 296,
            "start_column": 8789,
            "end_line": 4,
            "end_column": 9372,
            "start_byte": 8789,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.verbosity": {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 309,
            "start_column": 9378,
            "end_line": 4,
            "end_column": 9454,
            "start_byte": 9378,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.showheader": {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 313,
            "start_column": 9460,
            "end_line": 4,
            "end_column": 9530,
            "start_byte": 9460,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.showfspath": {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 323,
            "start_column": 9685,
            "end_line": 4,
            "end_column": 9769,
            "start_byte": 9685,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.showlongtestinfo": {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 327,
            "start_column": 9775,
            "end_line": 4,
            "end_column": 9850,
            "start_byte": 9775,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.hasopt": {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 331,
            "start_column": 9856,
            "end_line": 4,
            "end_column": 9983,
            "start_byte": 9856,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_fspath_result": {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)",
            "start_line": 335,
            "start_column": 9989,
            "end_line": 4,
            "end_column": 10686,
            "start_byte": 9989,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_ensure_prefix": {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 348,
            "start_column": 10692,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10692,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.ensure_newline": {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 357,
            "start_column": 10998,
            "end_line": 4,
            "end_column": 11120,
            "start_byte": 10998,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write": {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)",
            "start_line": 362,
            "start_column": 11126,
            "end_line": 4,
            "end_column": 11259,
            "start_byte": 11126,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.flush": {
            "name": "_pytest.terminal.TerminalReporter.flush",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def flush(self) -> None:\n        self._tw.flush()",
            "start_line": 365,
            "start_column": 11265,
            "end_line": 4,
            "end_column": 11314,
            "start_byte": 11265,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_line": {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 368,
            "start_column": 11320,
            "end_line": 4,
            "end_column": 11510,
            "start_byte": 11320,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.rewrite": {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 374,
            "start_column": 11516,
            "end_line": 4,
            "end_column": 12134,
            "start_byte": 11516,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_sep": {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 392,
            "start_column": 12140,
            "end_line": 4,
            "end_column": 12260,
            "start_byte": 12140,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.section": {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 396,
            "start_column": 12266,
            "end_line": 4,
            "end_column": 12345,
            "start_byte": 12266,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.line": {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 399,
            "start_column": 12351,
            "end_line": 4,
            "end_column": 12410,
            "start_byte": 12351,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._add_stats": {
            "name": "_pytest.terminal.TerminalReporter._add_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()",
            "start_line": 402,
            "start_column": 12416,
            "end_line": 4,
            "end_column": 12648,
            "start_byte": 12416,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_internalerror": {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 408,
            "start_column": 12654,
            "end_line": 4,
            "end_column": 12811,
            "start_byte": 12654,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_warning_captured": {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])",
            "start_line": 413,
            "start_column": 12817,
            "end_line": 4,
            "end_column": 13350,
            "start_byte": 12817,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_plugin_registered": {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 426,
            "start_column": 13356,
            "end_line": 4,
            "end_column": 13731,
            "start_byte": 13356,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_deselected": {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)",
            "start_line": 434,
            "start_column": 13737,
            "end_line": 4,
            "end_column": 13817,
            "start_byte": 13737,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_runtest_logstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            self.write_fspath_result(nodeid, \"\")\n            self.flush()",
            "start_line": 437,
            "start_column": 13823,
            "end_line": 4,
            "end_column": 14241,
            "start_byte": 13823,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_runtest_logreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()",
            "start_line": 448,
            "start_column": 14247,
            "end_line": 4,
            "end_column": 16159,
            "start_byte": 14247,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._is_last_item": {
            "name": "_pytest.terminal.TerminalReporter._is_last_item",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected",
            "start_line": 497,
            "start_column": 16165,
            "end_line": 4,
            "end_column": 16287,
            "start_byte": 16165,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})",
            "start_line": 501,
            "start_column": 16293,
            "end_line": 4,
            "end_column": 17210,
            "start_byte": 16293,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._get_progress_information_message": {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"",
            "start_line": 522,
            "start_column": 17216,
            "end_line": 4,
            "end_column": 17957,
            "start_byte": 17216,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._write_progress_information_filling_space": {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})",
            "start_line": 539,
            "start_column": 17963,
            "end_line": 4,
            "end_column": 18259,
            "start_byte": 17963,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._width_of_current_line": {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line",
            "start_line": 546,
            "start_column": 18265,
            "end_line": 4,
            "end_column": 18465,
            "start_byte": 18265,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)",
            "start_line": 551,
            "start_column": 18471,
            "end_line": 4,
            "end_column": 18821,
            "start_byte": 18471,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collectreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 559,
            "start_column": 18827,
            "end_line": 4,
            "end_column": 19212,
            "start_byte": 18827,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.report_collect": {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 569,
            "start_column": 19218,
            "end_line": 4,
            "end_column": 20633,
            "start_byte": 19218,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_sessionstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 609,
            "start_column": 20639,
            "end_line": 4,
            "end_column": 21805,
            "start_byte": 20639,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks": {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 637,
            "start_column": 21811,
            "end_line": 4,
            "end_column": 21954,
            "start_byte": 21811,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_report_header": {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 642,
            "start_column": 21960,
            "end_line": 4,
            "end_column": 22615,
            "start_byte": 21960,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection_finish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if session.items:\n                if self.config.option.verbose > -1:\n                    self._tw.line(\"\")\n                self._printcollecteditems(session.items)\n\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)",
            "start_line": 659,
            "start_column": 22621,
            "end_line": 4,
            "end_column": 23336,
            "start_byte": 22621,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._printcollecteditems": {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))",
            "start_line": 679,
            "start_column": 23342,
            "end_line": 4,
            "end_column": 25064,
            "start_byte": 23342,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_sessionfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()",
            "start_line": 719,
            "start_column": 25070,
            "end_line": 4,
            "end_column": 26017,
            "start_byte": 25070,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_terminal_summary": {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 744,
            "start_column": 26023,
            "end_line": 4,
            "end_column": 26366,
            "start_byte": 26023,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt": {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 755,
            "start_column": 26372,
            "end_line": 4,
            "end_column": 26487,
            "start_byte": 26372,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_unconfigure": {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 758,
            "start_column": 26493,
            "end_line": 4,
            "end_column": 26620,
            "start_byte": 26493,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._report_keyboardinterrupt": {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 762,
            "start_column": 26626,
            "end_line": 4,
            "end_column": 27154,
            "start_byte": 26626,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._locationline": {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 776,
            "start_column": 27160,
            "end_line": 4,
            "end_column": 27982,
            "start_byte": 27160,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._getfailureheadline": {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 798,
            "start_column": 27988,
            "end_line": 4,
            "end_column": 28146,
            "start_byte": 27988,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._getcrashline": {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 804,
            "start_column": 28152,
            "end_line": 4,
            "end_column": 28396,
            "start_byte": 28152,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.getreports": {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 816,
            "start_column": 28448,
            "end_line": 4,
            "end_column": 28637,
            "start_byte": 28448,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_warnings": {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 823,
            "start_column": 28643,
            "end_line": 4,
            "end_column": 31098,
            "start_byte": 28643,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_passes": {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 880,
            "start_column": 31104,
            "end_line": 4,
            "end_column": 31684,
            "start_byte": 31104,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._get_teardown_reports": {
            "name": "_pytest.terminal.TerminalReporter._get_teardown_reports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]",
            "start_line": 894,
            "start_column": 31690,
            "end_line": 4,
            "end_column": 31916,
            "start_byte": 31690,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._handle_teardown_sections": {
            "name": "_pytest.terminal.TerminalReporter._handle_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)",
            "start_line": 901,
            "start_column": 31922,
            "end_line": 4,
            "end_column": 32086,
            "start_byte": 31922,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.print_teardown_sections": {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 905,
            "start_column": 32092,
            "end_line": 4,
            "end_column": 32598,
            "start_byte": 32092,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_failures": {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)",
            "start_line": 918,
            "start_column": 32604,
            "end_line": 4,
            "end_column": 33288,
            "start_byte": 32604,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_errors": {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 935,
            "start_column": 33294,
            "end_line": 4,
            "end_column": 33890,
            "start_byte": 33294,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._outrep_summary": {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 950,
            "start_column": 33896,
            "end_line": 4,
            "end_column": 34353,
            "start_byte": 33896,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_stats": {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)",
            "start_line": 963,
            "start_column": 34359,
            "end_line": 4,
            "end_column": 35728,
            "start_byte": 34359,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.short_test_summary": {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 1000,
            "start_column": 35734,
            "end_line": 4,
            "end_column": 38473,
            "start_byte": 35734,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._get_main_color": {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types",
            "start_line": 1069,
            "start_column": 38479,
            "end_line": 4,
            "end_column": 38777,
            "start_byte": 38479,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._determine_main_color": {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color",
            "start_line": 1076,
            "start_column": 38783,
            "end_line": 4,
            "end_column": 39231,
            "start_byte": 38783,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._set_main_color": {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))",
            "start_line": 1088,
            "start_column": 39237,
            "end_line": 4,
            "end_column": 39722,
            "start_byte": 39237,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.build_summary_stats_line": {
            "name": "_pytest.terminal.TerminalReporter.build_summary_stats_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color",
            "start_line": 1097,
            "start_column": 39728,
            "end_line": 4,
            "end_column": 40474,
            "start_byte": 39728,
            "end_byte": 4
          },
          "_pytest.main._bestrelpath_cache": {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/main.py",
            "file_content": "@attr.s\nclass _bestrelpath_cache(dict):\n    path = attr.ib(type=py.path.local)\n\n    def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
            "start_line": 357,
            "start_column": 11180,
            "end_line": 0,
            "end_column": 11407,
            "start_byte": 11180,
            "end_byte": 0
          },
          "_pytest.main._bestrelpath_cache.path": {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/main.py",
            "file_content": "path = attr.ib(type=py.path.local)",
            "start_line": 359,
            "start_column": 11224,
            "end_line": 4,
            "end_column": 11258,
            "start_byte": 11224,
            "end_byte": 4
          },
          "_pytest.main._bestrelpath_cache.__missing__": {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r",
            "start_line": 361,
            "start_column": 11264,
            "end_line": 4,
            "end_column": 11407,
            "start_byte": 11264,
            "end_byte": 4
          },
          "_pytest.main.Session": {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11410,
            "end_line": 0,
            "end_column": 24577,
            "start_byte": 11410,
            "end_byte": 0
          },
          "_pytest.main.Session.Interrupted": {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11448,
            "end_line": 4,
            "end_column": 11473,
            "start_byte": 11448,
            "end_byte": 4
          },
          "_pytest.main.Session.Failed": {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11478,
            "end_line": 4,
            "end_column": 11493,
            "start_byte": 11478,
            "end_byte": 4
          },
          "_pytest.main.Session._setupstate": {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11554,
            "end_line": 4,
            "end_column": 11572,
            "start_byte": 11554,
            "end_byte": 4
          },
          "_pytest.main.Session._fixturemanager": {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11655,
            "end_line": 4,
            "end_column": 11677,
            "start_byte": 11655,
            "end_byte": 4
          },
          "_pytest.main.Session.exitstatus": {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11706,
            "end_line": 4,
            "end_column": 11723,
            "start_byte": 11706,
            "end_byte": 4
          },
          "_pytest.main.Session.__init__": {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11759,
            "end_line": 4,
            "end_column": 13037,
            "start_byte": 11759,
            "end_byte": 4
          },
          "_pytest.main.Session.from_config": {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13043,
            "end_line": 4,
            "end_column": 13124,
            "start_byte": 13043,
            "end_byte": 4
          },
          "_pytest.main.Session.__repr__": {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13130,
            "end_line": 4,
            "end_column": 13410,
            "start_byte": 13130,
            "end_byte": 4
          },
          "_pytest.main.Session._node_location_to_relpath": {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13416,
            "end_line": 4,
            "end_column": 13581,
            "start_byte": 13416,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectstart": {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13587,
            "end_line": 4,
            "end_column": 13801,
            "start_byte": 13587,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_runtest_logreport": {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13807,
            "end_line": 4,
            "end_column": 14169,
            "start_byte": 13807,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectreport": {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14175,
            "end_line": 4,
            "end_column": 14222,
            "start_byte": 14175,
            "end_byte": 4
          },
          "_pytest.main.Session.isinitpath": {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14228,
            "end_line": 4,
            "end_column": 14297,
            "start_byte": 14228,
            "end_byte": 4
          },
          "_pytest.main.Session.gethookproxy": {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14303,
            "end_line": 4,
            "end_column": 14394,
            "start_byte": 14303,
            "end_byte": 4
          },
          "_pytest.main.Session.perform_collect": {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14400,
            "end_line": 4,
            "end_column": 14868,
            "start_byte": 14400,
            "end_byte": 4
          },
          "_pytest.main.Session._perform_collect": {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14874,
            "end_line": 4,
            "end_column": 16108,
            "start_byte": 14874,
            "end_byte": 4
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16114,
            "end_line": 4,
            "end_column": 16849,
            "start_byte": 16114,
            "end_byte": 4
          },
          "_pytest.main.Session._collect": {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16855,
            "end_line": 4,
            "end_column": 20651,
            "start_byte": 16855,
            "end_byte": 4
          },
          "_pytest.main.Session._visit_filter": {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20657,
            "end_line": 4,
            "end_column": 20727,
            "start_byte": 20657,
            "end_byte": 4
          },
          "_pytest.main.Session._tryconvertpyarg": {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20733,
            "end_line": 4,
            "end_column": 21337,
            "start_byte": 20733,
            "end_byte": 4
          },
          "_pytest.main.Session._parsearg": {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21343,
            "end_line": 4,
            "end_column": 22028,
            "start_byte": 21343,
            "end_byte": 4
          },
          "_pytest.main.Session.matchnodes": {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22034,
            "end_line": 4,
            "end_column": 22418,
            "start_byte": 22034,
            "end_byte": 4
          },
          "_pytest.main.Session._matchnodes": {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22424,
            "end_line": 4,
            "end_column": 24102,
            "start_byte": 22424,
            "end_byte": 4
          },
          "_pytest.main.Session.genitems": {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24108,
            "end_line": 4,
            "end_column": 24577,
            "start_byte": 24108,
            "end_byte": 4
          },
          "_pytest.pytester.Testdir.Session": {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 801,
            "start_column": 26154,
            "end_line": 4,
            "end_column": 26171,
            "start_byte": 26154,
            "end_byte": 4
          }
        }
      }
    }
  ]
}