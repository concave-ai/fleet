{
    "file_paths": [
        "src/_pytest/main.py"
    ],
    "symbols": [
        "_pytest.main.search_pypath",
        "_pytest.main.resolve_collection_argument",
        "_pytest.logging.pytest_addoption"
    ],
    "code_spans": {
        "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "test._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption",
            "start_line": 21,
            "start_column": 592,
            "end_line": 0,
            "end_column": 1385,
            "start_byte": 592,
            "end_byte": 0
        },
        "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path_ = path if isinstance(path, Path) else Path(path)\n        return path_ in self._initialpaths\n\n    def gethookproxy(self, fspath: \"os.PathLike[str]\"):\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path = fspath if isinstance(fspath, Path) else Path(fspath)\n        pm = self.config.pluginmanager\n        # Check if we have the common case of running\n        # hooks with all conftest.py files.\n        my_conftestmodules = pm._getconftestmodules(\n            path,\n            self.config.getoption(\"importmode\"),\n            rootpath=self.config.rootpath,\n        )\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # One or more conftests are not in use at this fspath.\n            from .config.compat import PathAwareHookProxy\n\n            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))\n        else:\n            # All plugins are active for this fspath.\n            proxy = self.config.hook\n        return proxy\n\n    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        fspath = Path(direntry.path)\n        ihook = self.gethookproxy(fspath.parent)\n        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n            return False\n        return True\n\n    def _collectf",
            "start_line": 453,
            "start_column": 16621,
            "end_line": 0,
            "end_column": 18400,
            "start_byte": 16621,
            "end_byte": 0
        },
        "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n ",
            "start_line": 42,
            "start_column": 1108,
            "end_line": 0,
            "end_column": 1587,
            "start_byte": 1108,
            "end_byte": 0
        },
        "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "_pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[",
            "start_line": 43,
            "start_column": 1224,
            "end_line": 0,
            "end_column": 1946,
            "start_byte": 1224,
            "end_byte": 0
        },
        "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --s",
            "start_line": 68,
            "start_column": 1950,
            "end_line": 0,
            "end_column": 3384,
            "start_byte": 1950,
            "end_byte": 0
        },
        "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfr",
            "start_line": 16,
            "start_column": 326,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 326,
            "end_byte": 0
        },
        "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1371,
            "start_column": 53324,
            "end_line": 0,
            "end_column": 53528,
            "start_byte": 53324,
            "end_byte": 0
        },
        "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encoun",
            "start_line": 43,
            "start_column": 1340,
            "end_line": 0,
            "end_column": 2976,
            "start_byte": 1340,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another",
            "start_line": 80,
            "start_column": 2567,
            "end_line": 0,
            "end_column": 4122,
            "start_byte": 2567,
            "end_byte": 0
        },
        "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "self, pm: PytestPluginManager, remove_mods) -> None:\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"\n\n    __module__ = \"builtins\"  # For py3.\n\n\nclass Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n\n\n@dataclasses.dataclass\nclass _bestrelpath_cache(Dict[Path, str]):\n    __slots__ = (\"path\",)\n\n    path: Path\n\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n\n\n@final\nclass Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager: FixtureManager\n    exitstatus: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        super().__init__(\n            path=config.rootpath,\n            fspath=None,\n            parent=None,\n            config=config,\n            session=self,\n            nodeid=\"\",\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop: Union[bool, s",
            "start_line": 381,
            "start_column": 13650,
            "end_line": 0,
            "end_column": 15025,
            "start_byte": 13650,
            "end_byte": 0
        },
        "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n            else:\n                if isinstance(excinfo.value, SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        os.chdir(session.startpath)\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:\n    return wrap_session(config, _main)\n\n\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\"Default command line protocol for initialization, session,\n    running tests and reporting.\"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    session.perform_collect()\n\n\ndef pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path: Path) -> bool:\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script.\"\"\"\n    bindir = path.joinpath(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    try:\n        i",
            "start_line": 237,
            "start_column": 8743,
            "end_line": 0,
            "end_column": 11544,
            "start_byte": 8743,
            "end_byte": 0
        },
        "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )",
            "start_line": 49,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 6649,
            "start_byte": 1365,
            "end_byte": 0
        },
        "_pytest.main.search_pypath": {
            "name": "_pytest.main.search_pypath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def search_pypath(module_name: str) -> str:\n    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n    try:\n        spec = importlib.util.find_spec(module_name)\n    # AttributeError: looks like package module, but actually filename\n    # ImportError: module does not exist\n    # ValueError: not a module name\n    except (AttributeError, ImportError, ValueError):\n        return module_name\n    if spec is None or spec.origin is None or spec.origin == \"namespace\":\n        return module_name\n    elif spec.submodule_search_locations:\n        return os.path.dirname(spec.origin)\n    else:\n        return spec.origin",
            "start_line": 842,
            "start_column": 29973,
            "end_line": 0,
            "end_column": 30626,
            "start_byte": 29973,
            "end_byte": 0
        },
        "_pytest.main.resolve_collection_argument": {
            "name": "_pytest.main.resolve_collection_argument",
            "file_path": "src/_pytest/main.py",
            "file_content": "def resolve_collection_argument(\n    invocation_path: Path, arg: str, *, as_pypath: bool = False\n) -> Tuple[Path, List[str]]:\n    \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n\n    Command-line arguments can point to files and/or directories, and optionally contain\n    parts for specific tests selection, for example:\n\n        \"pkg/tests/test_foo.py::TestClass::test_foo\"\n\n    This function ensures the path exists, and returns a tuple:\n\n        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n\n    When as_pypath is True, expects that the command-line argument actually contains\n    module paths instead of file-system paths:\n\n        \"pkg.tests.test_foo::TestClass::test_foo\"\n\n    In which case we search sys.path for a matching module, and then return the *path* to the\n    found module.\n\n    If the path doesn't exist, raise UsageError.\n    If the path is a directory and selection parts are present, raise UsageError.\n    \"\"\"\n    base, squacket, rest = str(arg).partition(\"[\")\n    strpath, *parts = base.split(\"::\")\n    if parts:\n        parts[-1] = f\"{parts[-1]}{squacket}{rest}\"\n    if as_pypath:\n        strpath = search_pypath(strpath)\n    fspath = invocation_path / strpath\n    fspath = absolutepath(fspath)\n    if not fspath.exists():\n        msg = (\n            \"module or package not found: {arg} (missing __init__.py?)\"\n            if as_pypath\n            else \"file or directory not found: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    if parts and fspath.is_dir():\n        msg = (\n            \"package argument cannot contain :: selection parts: {arg}\"\n            if as_pypath\n            else \"directory argument cannot contain :: selection parts: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    return fspath, parts",
            "start_line": 859,
            "start_column": 30629,
            "end_line": 0,
            "end_column": 32474,
            "start_byte": 30629,
            "end_byte": 0
        },
        "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "neral\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to l",
            "start_line": 69,
            "start_column": 1986,
            "end_line": 0,
            "end_column": 3604,
            "start_byte": 1986,
            "end_byte": 0
        },
        "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "yping import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hooki",
            "start_line": 17,
            "start_column": 429,
            "end_line": 0,
            "end_column": 772,
            "start_byte": 429,
            "end_byte": 0
        },
        "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addop",
            "start_line": 84,
            "start_column": 2254,
            "end_line": 0,
            "end_column": 2881,
            "start_byte": 2254,
            "end_byte": 0
        },
        "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_",
            "start_line": 91,
            "start_column": 2951,
            "end_line": 0,
            "end_column": 4390,
            "start_byte": 2951,
            "end_byte": 0
        },
        "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "xtensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n",
            "start_line": 49,
            "start_column": 1338,
            "end_line": 0,
            "end_column": 1908,
            "start_byte": 1338,
            "end_byte": 0
        },
        "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom ",
            "start_line": 14,
            "start_column": 368,
            "end_line": 0,
            "end_column": 781,
            "start_byte": 368,
            "end_byte": 0
        },
        "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " typing import final\nfrom typing import FrozenSet\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nf",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 557,
            "start_byte": 265,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import ",
            "start_line": 25,
            "start_column": 670,
            "end_line": 0,
            "end_column": 1166,
            "start_byte": 670,
            "end_byte": 0
        },
        "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcome",
            "start_line": 17,
            "start_column": 381,
            "end_line": 0,
            "end_column": 970,
            "start_byte": 381,
            "end_byte": 0
        },
        "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "icit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n\n\ndef validate_basetemp(path: str) -> str:\n    # GH 7119\n    msg = \"basetemp must not be empty, the current working directory or any parent directory of it\"\n\n    # empty path\n    if not path:\n        raise argparse.ArgumentTypeError(msg)\n\n    def is_ancestor(base: Path, query: Path) -> bool:\n        \"\"\"Return whether query is an ancestor of base.\"\"\"\n        if base == query:\n            return True\n        return query in base.parents\n\n    # check if path is an ancestor of cwd\n    if is_ancestor(Path.cwd(), Path(path).absolute()):\n        raise argparse.ArgumentT",
            "start_line": 135,
            "start_column": 3636,
            "end_line": 0,
            "end_column": 7219,
            "start_byte": 3636,
            "end_byte": 0
        },
        "_pytest.tmpdir.pytest_addoption": {
            "name": "_pytest.tmpdir.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "nterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(f\"{excinfo.typename}: {excinfo.value.msg}\\n\")\n            config.hook.py",
            "start_line": 222,
            "start_column": 8101,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8101,
            "end_byte": 0
        },
        "_pytest.python_path.pytest_addoption": {
            "name": "_pytest.python_path.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "mport argparse\nimport dataclasses\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom pathlib import Path\nfrom",
            "start_line": 7,
            "start_column": 80,
            "end_line": 0,
            "end_column": 213,
            "start_byte": 80,
            "end_byte": 0
        }
    }
}