{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-11148",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:33:50.000773",
        "usage": "1724.3578433990479 ms"
      },
      "request": {
        "repo_tokens": [
          "summary_passes",
          "Cache",
          "summary_failures",
          "visit_Name",
          "fixturenames",
          "push_format_context",
          "islink",
          "extract_suffixes",
          "extraline",
          "processoption",
          "fnmatch_lines",
          "reprfileloc",
          "purebasename",
          "_fixturemanager",
          "LogCaptureHandler",
          "append_collect_error",
          "_read_pyc",
          "getpluginversioninfo",
          "typename",
          "from_user",
          "STRICT_OPTION",
          "__fspath__",
          "cacheprovider",
          "summary_errors",
          "_plugin_nameversions",
          "ids",
          "append_collect_skipped",
          "TESTPATHS",
          "exit",
          "traceback",
          "_consider_importhook",
          "_validate_args",
          "delattr",
          "filter_traceback_for_conftest_import_failure",
          "CallInfo",
          "write_fspath_result",
          "CLOSE_STDIN",
          "mkdir",
          "cwd_relative_nodeid",
          "getpathnode",
          "obj",
          "_parse_ini_config",
          "stash",
          "_import_plugin_specs",
          "plugins",
          "_given_basetemp",
          "IdMaker",
          "addSkip",
          "add_global_property",
          "store_mark",
          "OutcomeException",
          "parseconfig",
          "isimportable",
          "_ensure_basetemp",
          "_surrounding_parens_on_own_lines",
          "runpytest",
          "matches",
          "builtin_plugins",
          "__lt__",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "_getnextfixturedef",
          "_get_allow_unicode_flag",
          "ImportMismatchError",
          "HOOK_LEGACY_PATH_ARG",
          "check_interactive_exception",
          "id",
          "PytestRemovedIn8Warning",
          "ARGUMENT_PERCENT_DEFAULT",
          "reprtraceback",
          "getitems",
          "pastebin",
          "_check_path",
          "capsys",
          "Stat",
          "evaluate_skip_marks",
          "NFPlugin",
          "approx",
          "__post_init__",
          "startpath",
          "deselect_by_keyword",
          "LegacyTestdirPlugin",
          "_early_rewrite_bailout",
          "_get_increasing_order",
          "truncate",
          "safeformat",
          "_determine_show_progress_info",
          "pytest_sessionstart",
          "writeorg",
          "_translate_non_printable",
          "rootpath",
          "cleanup_numbered_dir",
          "is_rewrite_disabled",
          "_no_match_line",
          "_get_plugin_specs_as_list",
          "_rewrite_test",
          "_assertion_supported",
          "consider_module",
          "chmod",
          "Failed",
          "_get_raw_skip_reason",
          "V",
          "_ensure_supporting_files",
          "pathlib",
          "terminal",
          "PytestPluginManager",
          "_gethomedir",
          "buffer",
          "pytest_runtest_call",
          "TEST_OUTCOME",
          "suspend_global_capture",
          "SysCaptureBinary",
          "prepend",
          "get_lines_after",
          "pytest_internalerror",
          "pytestPDB",
          "write_text",
          "runtest",
          "getrawcode",
          "__str__",
          "Exit",
          "getlocation",
          "UsageError",
          "SetupState",
          "indices",
          "RE_IMPORT_ERROR_NAME",
          "match",
          "cleanup_dead_symlinks",
          "Xfail",
          "write_ensure_prefix",
          "from_parent",
          "seekable",
          "_check_scope",
          "pytester",
          "_inject_setup_method_fixture",
          "Cache_makedir",
          "PytestUnraisableExceptionWarning",
          "_is_capturing",
          "Scope",
          "Session",
          "PathAwareHookProxy",
          "inipath",
          "_write_pyc_fp",
          "activate_fixture",
          "stream",
          "setenv",
          "_F",
          "IGNORE_PAM",
          "_esctable",
          "pytest_report_collectionfinish",
          "ensure",
          "classnamefilter",
          "args",
          "validate_basetemp",
          "reason",
          "assign",
          "get_plugin_manager",
          "MultipleDoctestFailures",
          "showlongtestinfo",
          "ReprLocals",
          "get_location",
          "_bestrelpath_cache",
          "_ALL_SCOPES",
          "expr",
          "NOTSET",
          "resolve_package_path",
          "_ET",
          "excinfo",
          "_ensure_relative_to_basetemp",
          "UnitTestCase",
          "_SCOPE_INDICES",
          "fnmatch_lines_random",
          "NOSE_SUPPORT",
          "LsofFdLeakChecker",
          "CallSpec2",
          "_iter_rewritable_modules",
          "raises",
          "_write_progress_information_filling_space",
          "addFailure",
          "cut",
          "readlines",
          "records",
          "pytest_assertrepr_compare",
          "is_async_function",
          "writable",
          "pytest_enter_pdb",
          "collect_one_node",
          "Module",
          "consider_conftest",
          "Config_inifile",
          "compile",
          "_try_repr_or_str",
          "running_on_ci",
          "reprcrash",
          "_config_for_test",
          "notset",
          "runpython_c",
          "_CACHE_PREFIX_VALUES",
          "pytest_pycollect_makeitem",
          "from_item",
          "frame",
          "group",
          "getargs",
          "pytest_collectstart",
          "_checkversion",
          "set_when",
          "FDCapture",
          "_force_symlink",
          "countoutcomes",
          "scope",
          "CaptureIO",
          "__test__",
          "_LiveLoggingStreamHandler",
          "xfailed_key",
          "_init_runner_class",
          "LFPluginCollWrapper",
          "ApproxBase",
          "_reprcompare",
          "pytest_warning_recorded",
          "_validate_usepdb_cls",
          "get_stderr_fileno",
          "_validate_config_options",
          "pytest_collection_modifyitems",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_is_last_item",
          "getfixturevalue",
          "_make_xunit_fixture",
          "isdatacls",
          "_get_main_color",
          "ExceptionRepr",
          "_getconftestmodules",
          "nofuncargs",
          "HOOK_LEGACY_MARKING",
          "re_match_lines_random",
          "_matches_prefix_or_glob_option",
          "get_common_ancestor",
          "pop_format_context",
          "_color_for_type",
          "pytest_report_teststatus",
          "ReprFailDoctest",
          "PytestCollectionWarning",
          "_write_entry_lines",
          "NodeMeta",
          "search_pypath",
          "_collectfile",
          "_dump_lines",
          "fix_cache_order",
          "CollectErrorRepr",
          "_for_parametrize",
          "_try_load_conftest",
          "move",
          "SysModulesSnapshot",
          "listdir",
          "ApproxSequenceLike",
          "SubRequest",
          "_report_to_json",
          "pluralize",
          "HelpAction",
          "INSTANCE_COLLECTOR",
          "Config_rootdir",
          "type",
          "pytest_fixture_post_finalizer",
          "python",
          "stop_global_capturing",
          "ImportPathMismatchError",
          "build_summary_stats_line",
          "visit_Starred",
          "reports",
          "_IGNORED_WINERRORS",
          "extract_from",
          "mktemp",
          "Expression",
          "getreports",
          "initialnames",
          "fileno",
          "families",
          "_format_assertmsg",
          "DEFAULT_RELATIVE_TOLERANCE",
          "isdict",
          "LogCaptureFixture",
          "fail",
          "_warn_already_imported",
          "WARNING_CMDLINE_PREPARSE_HOOK",
          "context",
          "explanation_param",
          "mkpydir",
          "from_function",
          "AssertionRewritingHook",
          "getoption",
          "from_call",
          "MoreQuietAction",
          "find_prefixed",
          "_PytestWrapper",
          "IDENT",
          "listextrakeywords",
          "getstatement",
          "template",
          "_AnyPurePath",
          "get_records",
          "maybe_delete_a_numbered_dir",
          "_call_assertion_pass",
          "popen",
          "pytest_collect_file",
          "conftest_options",
          "getfixtureclosure",
          "make_unique_parameterset_ids",
          "evaluate_xfail_marks",
          "readline",
          "link",
          "Interrupted",
          "_has_param_ids",
          "_color_for_type_default",
          "TracebackEntry",
          "lines",
          "pytest_runtest_protocol",
          "record_tuples",
          "_assert_state",
          "FDCaptureBase",
          "summary_warnings",
          "__gt__",
          "write_captured_output",
          "location",
          "_R",
          "_cachedir",
          "_resolve_arg_value_types",
          "done",
          "post_mortem",
          "pytest_deselected",
          "_NodeType",
          "__version__",
          "_approx_scalar",
          "NodeKeywords",
          "__setitem__",
          "skip",
          "_add_simple",
          "_is_marked_for_rewrite",
          "for_later",
          "_update_current_test_var",
          "record_xml_attribute",
          "NotSetType",
          "SysCapture",
          "resolve_from_str",
          "PytestAssertRewriteWarning",
          "print_teardown_sections",
          "name2pseudofixturedef_key",
          "append_error",
          "_truncate_explanation",
          "writelines",
          "_folded_skips",
          "statement",
          "USAGE_ERROR",
          "Skip",
          "start_capturing",
          "list",
          "common",
          "_report_kwargs_from_json",
          "pytest_plugin_registered",
          "line",
          "helpconfig",
          "TResult",
          "re_match_lines",
          "_write_content",
          "_ALLOW_MARKERS",
          "fault_handler_originally_enabled_key",
          "close",
          "PytestConfigWarning",
          "format",
          "_do_configure",
          "get_open_files",
          "call_runtest_hook",
          "node_reporter",
          "pytest_generate_tests",
          "compat",
          "_getentrysource",
          "doctest",
          "remove",
          "TerminalReporter_startdir",
          "rex_outcome",
          "_tmppath_factory",
          "Function",
          "get_parametrized_fixture_keys",
          "tmpdir_factory",
          "exec_module",
          "PyobjMixin",
          "ReprExceptionInfo",
          "_getcrashline",
          "determine_setup",
          "caplog",
          "UNARY_MAP",
          "visit_Assert",
          "pytest_make_collect_report",
          "pytest_keyboard_interrupt",
          "patchsysdict",
          "syspathinsert",
          "sysexec",
          "Checkers",
          "get_user",
          "iswin32",
          "parse_setoption",
          "BaseReport",
          "warning_record_to_str",
          "_getvaluepath",
          "_main",
          "simple",
          "File",
          "CwdSnapshot",
          "visit_BinOp",
          "HookRecorder",
          "pytest_collection",
          "LineMatcher",
          "console_main",
          "pytest_runtestloop",
          "isfile",
          "_show_fixtures_per_test",
          "repr_instance",
          "apply_warning_filters",
          "show_test_item",
          "get_source",
          "getsource",
          "parse_known_and_unknown_args",
          "function",
          "_get_runner",
          "cleanup_candidates",
          "makefile",
          "setitem",
          "ApproxScalar",
          "FixtureValue",
          "start",
          "_handle_teardown_sections",
          "capture",
          "add_funcarg_pseudo_fixture_def",
          "importlib",
          "_get_verbose_word",
          "_create_formatter",
          "set_session",
          "get_lock_path",
          "STEPWISE_CACHE_DIR",
          "eval",
          "_version",
          "_start",
          "_typ_map",
          "_ensure_unconfigure",
          "__version_tuple__",
          "read_binary",
          "chdir",
          "Config_invocation_dir",
          "_node_location_to_relpath",
          "runner",
          "readouterr",
          "_postmortem_traceback",
          "threadexception",
          "node",
          "_initini",
          "teardown_exact",
          "get_default_arg_names",
          "format_session_duration",
          "junitxml",
          "StashKey",
          "cls",
          "xml_key",
          "repr_args",
          "spawn",
          "ReprEntry",
          "__dir__",
          "ReprEntryNative",
          "Config__getini_unknown_type",
          "keywords",
          "_idval_from_argname",
          "STRING_TYPES",
          "_report_unserialization_failure",
          "_decide_args",
          "_outrep_summary",
          "dir",
          "_recursive_debug",
          "module",
          "ReprTraceback",
          "read_text",
          "NOT",
          "source",
          "_check_if_assertion_pass_impl",
          "resolve_fixture_function",
          "_get_teardown_reports",
          "reprlocals",
          "pytest_report_from_serializable",
          "pop_outerr_to_orig",
          "_log",
          "_showfixtures_main",
          "Class",
          "has_default_eq",
          "async_warn_and_skip",
          "reject",
          "wrap_function_to_error_out_if_called_directly",
          "imply_paths_hooks",
          "DEFAULT_MAX_LINES",
          "_getini_unknown_type",
          "LEVELNAME_FMT_REGEX",
          "consider_preparse",
          "traverse_node",
          "to_xml",
          "_pytest",
          "PytestExperimentalApiWarning",
          "__call__",
          "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
          "handler",
          "_assertion_pass",
          "_truncate_recursive_traceback",
          "update",
          "_width_of_current_line",
          "ensure_deletable",
          "applymarker",
          "_find_spec",
          "_PLUGGY_DIR",
          "_resolve_warning_category",
          "_pyfuncitem",
          "USAGE_MSG",
          "python_api",
          "func_name",
          "LegacyTmpdirPlugin",
          "_import_pdb_cls",
          "TempdirFactory",
          "formatrepr",
          "_idval_from_hook",
          "assert_contains",
          "XFailed",
          "summary_stats",
          "head_line",
          "_inject_setup_class_fixture",
          "_ANSI_ESCAPE_SEQ",
          "_getindent",
          "iter_markers_with_node",
          "NeverRaised",
          "dirpath",
          "display",
          "isnamedtuple",
          "EOF",
          "Node",
          "_printcollecteditems",
          "pytest_runtest_logstart",
          "_get_unknown_ini_keys",
          "add_property",
          "MarkDecorator",
          "maybe_wrap_pytest_function_for_tracing",
          "showlocals",
          "set_fixture",
          "_sys_snapshot",
          "register_assert_rewrite",
          "warning_types",
          "faulthandler",
          "_get_assertion_exprs",
          "directory_arg",
          "Package",
          "consider_env",
          "CHECKER_CLASS",
          "get_fslocation_from_item",
          "_strtobool",
          "rewrite",
          "showheader",
          "_get_override_ini_value",
          "__repr__",
          "getini",
          "_inject_setup_function_fixture",
          "helper",
          "unset_fixture",
          "istestfunction",
          "deactivate_fixture",
          "bestrelpath",
          "parse",
          "ext",
          "_basetemp",
          "FastFilesCompleter",
          "showversion",
          "gethookproxy",
          "indent",
          "__getitem__",
          "get_empty_parameterset_mark",
          "EncodedFile",
          "outcome",
          "ihook",
          "prune_dependency_tree",
          "_sortlist",
          "_importtestmodule",
          "no_header",
          "_get_checker",
          "_match_lines_random",
          "get_optionflags",
          "LogXML",
          "Skipped",
          "_set_main_color",
          "_compare_eq_set",
          "_is_skipped",
          "Pytester",
          "_should_repr_global_name",
          "pytest_exception_interact",
          "TestReport",
          "_init_pdb",
          "MultiCapture",
          "yield_fixture",
          "kwargs",
          "nodeid",
          "TestCaseFunction",
          "get_exconly",
          "word",
          "_imply_path",
          "get_last_failed_paths",
          "_preparse",
          "_mark_plugins_for_rewrite",
          "TokenType",
          "UnformattedWarning",
          "visit_Compare",
          "getfslineno",
          "reorder_items",
          "message",
          "__init__",
          "visit_UnaryOp",
          "_is_numpy_array",
          "values",
          "_evaluate",
          "InstanceDummy",
          "normalize_mark_list",
          "CFG_PYTEST_SECTION",
          "when",
          "_yield_comparisons",
          "isatty",
          "catch_warnings_for_item",
          "OK",
          "params",
          "_check_type",
          "ApproxMapping",
          "Source",
          "unraisable_exception_runtest_hook",
          "pytest_addoption",
          "parse_args",
          "pytest",
          "listchain",
          "get",
          "NoCapture",
          "_prepare_content",
          "YIELD_FIXTURE",
          "timing",
          "_validate_plugins",
          "__all__",
          "listnames",
          "_resolve_msg_to_reason",
          "_finalize",
          "copytree",
          "duration",
          "PYC_TAIL",
          "append",
          "hasopt",
          "getstatementrange_ast",
          "is_fs_root",
          "assert_contains_lines",
          "IGNORED_ATTRIBUTES",
          "fill_unfilled",
          "_set_opt_strings",
          "is_started",
          "pytest_pycollect_makemodule",
          "_genfunctions",
          "_format",
          "Config",
          "issue_config_time_warning",
          "_scope",
          "from_current",
          "bin_xml_escape",
          "tmp_path_factory",
          "clear_cache",
          "_getpytestargs",
          "get_closest_marker",
          "gen",
          "_warn_or_fail_if_strict",
          "NO_TESTS_COLLECTED",
          "longrepr",
          "REPORT_COLLECTING_RESOLUTION",
          "__delitem__",
          "get_real_func",
          "SysPathsSnapshot",
          "_write_pyc",
          "_is_mocked",
          "try_makedirs",
          "T",
          "funcargs",
          "get_log_level_for_setting",
          "RaisesContext",
          "_setupstate",
          "matchreport",
          "essential_plugins",
          "parsefactories",
          "_should_rewrite",
          "ImportMode",
          "prog",
          "update_testcase_duration",
          "thread_exception_runtest_hook",
          "DEFAULT_LOG_DATE_FORMAT",
          "linecomp",
          "pytest_collectreport",
          "mark_rewrite",
          "unittest",
          "FILE_OR_DIR",
          "_pformat_dispatch",
          "_getparser",
          "_call_with_optional_argument",
          "generic_visit",
          "_get_auto_indent",
          "ParseError",
          "_getfailureheadline",
          "size",
          "copystat",
          "skipped",
          "reprentries",
          "flush",
          "capfdbinary",
          "_retention_count",
          "abspath",
          "register_cleanup_lock_removal",
          "find_spec",
          "EMPTY_BUFFER",
          "rm_rf",
          "LPAREN",
          "load",
          "next_lower",
          "ensure_dir",
          "DOCTEST_REPORT_CHOICES",
          "addSuccess",
          "old_mark_config_key",
          "istext",
          "safe_getattr",
          "get_scope_node",
          "addError",
          "AssertionState",
          "raiseerror",
          "pytester_assertions",
          "assertoutcome",
          "pytest_pyfunc_call",
          "ishidden",
          "_show_fixture_action",
          "getmodulecol",
          "_get_reports_to_display",
          "getreportopt",
          "_ignore_error",
          "DummyRewriteHook",
          "_check_all_skipped",
          "cacheshow",
          "from_exception",
          "Exception",
          "pytest_configure",
          "copy_example",
          "_check_initialpaths_for_relpath",
          "_recurse",
          "WarningsRecorder",
          "xfail",
          "_getini",
          "_runtest_for",
          "symlink_or_skip",
          "logging",
          "legacypath",
          "_highlight",
          "warn",
          "run",
          "R",
          "hookspec",
          "_winerrnomap",
          "Item",
          "report_collect",
          "spawn_pytest",
          "messages",
          "_FixtureCachedResult",
          "resolve_collection_argument",
          "name2fixturedefs",
          "fslocation",
          "_state",
          "ExitCode",
          "astcache",
          "test_tmproot",
          "_FixtureFunc",
          "addoption",
          "reportinfo",
          "wrap_write",
          "finish_recording",
          "repr",
          "ReprTracebackNative",
          "inline_runsource",
          "get_user_id",
          "fromdictargs",
          "_get_direct_parametrize_args",
          "cmdline",
          "annotated_getattr",
          "get_unpacked_marks",
          "runpytest_inprocess",
          "capstdout",
          "_resume",
          "getfixturedefs",
          "__array_ufunc__",
          "setupplan",
          "strip",
          "makepyprojecttoml",
          "start_global_capturing",
          "SysCaptureBase",
          "pytest_leave_pdb",
          "getparent",
          "formatTime",
          "_idval",
          "unraisableexception",
          "E",
          "ARGS",
          "catch_threading_exception",
          "_with_exception",
          "Traceback",
          "issequence",
          "add_color_level",
          "LFPluginCollSkipfiles",
          "safe_isclass",
          "deselect_by_mark",
          "get_scope_package",
          "fnmatch",
          "TerminalWriter",
          "MarkGenerator",
          "pastebinfile_key",
          "visit_NamedExpr",
          "ExceptionChainRepr",
          "_TracebackStyle",
          "exconly",
          "MARKED_FIXTURE",
          "pytest_terminal_summary",
          "wrap_session",
          "as_cwd",
          "LOGLEVEL_COLOROPTS",
          "delenv",
          "finish",
          "_in_venv",
          "collect_by_name",
          "repr_traceback",
          "getplugin",
          "showfixtures",
          "config",
          "WARNS_NONE_ARG",
          "getinicfg",
          "_get_pdb_wrapper_class",
          "add_cleanup",
          "assert_outcomes",
          "_colorama_workaround",
          "cached_result",
          "builtin",
          "warns",
          "addExpectedFailure",
          "_truncate_by_char_count",
          "record_property",
          "TimeoutExpired",
          "__enter__",
          "_format_repr_exception",
          "newinstance",
          "firstlineno",
          "getparam",
          "_PluggyPlugin",
          "PrintHelp",
          "_makepath",
          "rewrite_asserts",
          "_disable_loggers",
          "commonpath",
          "copymode",
          "INTERRUPTED",
          "marks",
          "visit_Call",
          "DoctestTextfile",
          "no_re_match_line",
          "showfspath",
          "_getbyspec",
          "saferepr_unlimited",
          "recursionindex",
          "_get_number_flag",
          "_CACHE_PREFIX_DIRS",
          "consider_pluginarg",
          "_parse_parametrize_parameters",
          "make_numbered_dir",
          "deprecated_call",
          "filter",
          "_saferepr",
          "_inject_setup_teardown_fixtures",
          "copychunked",
          "version_tuple",
          "toterminal",
          "global_and_fixture_disabled",
          "repr_excinfo",
          "execute",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "create_module",
          "evaluate_condition",
          "getfirstlinesource",
          "DEFAULT_MAX_CHARS",
          "inline_genitems",
          "_WithException",
          "tmppath_result_key",
          "_get_node_id_with_markup",
          "DontReadFromInput",
          "write",
          "BINOP_MAP",
          "FixtureFunction",
          "addsection",
          "pytest_unconfigure",
          "_Key",
          "__add__",
          "_check_item_and_collector_diamond_inheritance",
          "FixtureRequest",
          "findsource",
          "runpytest_subprocess",
          "delitem",
          "param",
          "_getlines",
          "getnode",
          "with_args",
          "parametersets",
          "truncate_locals",
          "make_hook_recorder",
          "_factorytraceback",
          "PdbInvoke",
          "_fastjoin",
          "_rget_with_confmod",
          "ensure_extended_length_path",
          "RunResult",
          "FixtureLookupError",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "TeeCaptureIO",
          "visit_Attribute",
          "_bytes_to_ascii",
          "markname",
          "_getautousenames",
          "InvocationParams",
          "skipping",
          "is_globally_capturing",
          "_non_printable_ascii_translate_table",
          "get_timeout_config_value",
          "PYTEST_TAG",
          "isnosetest",
          "no_summary",
          "find_suffixes",
          "copy",
          "pytest_addhooks",
          "_FileHandler",
          "make_properties_node",
          "CaptureFixture",
          "ARGUMENT_TYPE_STR_CHOICE",
          "_code",
          "visit",
          "create_cleanup_lock",
          "no_fnmatch_line",
          "getuserid",
          "write_line",
          "pytest_cmdline_main",
          "LOCK_TIMEOUT",
          "get_extended_length_path_str",
          "DEFAULT_REPR_MAX_SIZE",
          "_result",
          "_compare_eq_cls",
          "KNOWN_TYPES",
          "sections",
          "assertstate_key",
          "repr_traceback_entry",
          "readable",
          "_write_report_lines_from_hooks",
          "isinitpath",
          "PytestRemovedIn9Warning",
          "fspath",
          "sysfind",
          "_fail",
          "_patternchars",
          "set_level",
          "PytestArg",
          "collect",
          "_validate_if_using_arg_names",
          "is_generator",
          "_names",
          "PyCollector",
          "ReprFileLocation",
          "filename_arg",
          "evaluate",
          "SEP",
          "getfuncargnames",
          "call_optional",
          "get_statement_startend2",
          "_idval_from_value_required",
          "get_option_ini",
          "is_capturing",
          "PRIVATE",
          "from_item_and_call",
          "_striptext",
          "addUnexpectedSuccess",
          "resolve",
          "pytest_report_to_serializable",
          "and_expr",
          "wrap_pytest_function_for_tracing",
          "f_globals",
          "lstat",
          "pytest_runtest_setup",
          "isset",
          "rex_session_duration",
          "getrepr",
          "PytestUnhandledCoroutineWarning",
          "open",
          "map_as_list",
          "version",
          "reprfuncargs",
          "_getobj",
          "FixtureManager",
          "on_rm_rf_error",
          "PytestCacheWarning",
          "_compare_eq_sequence",
          "_retention_policy",
          "_NodeReporter",
          "finalize",
          "_is_main_py",
          "runpython",
          "setuponly",
          "pyimport",
          "deprecated",
          "_init_checker_class",
          "Visitor",
          "resume_global_capture",
          "ensure_newline",
          "__take_sys_modules_snapshot",
          "import_plugin",
          "getcalls",
          "makeini",
          "setup",
          "load_config_dict_from_file",
          "strict",
          "code",
          "getfixturemarker",
          "_parse_expression",
          "_argcomplete",
          "pytest_runtest_logfinish",
          "tmp_path",
          "RecordedHookCall",
          "addinivalue_line",
          "parse_summary_nouns",
          "new",
          "addfinalizer",
          "_find_parametrized_scope",
          "_ellipsize",
          "MARK_GEN",
          "_disable_output_capturing_for_darwin",
          "encoding",
          "__hash__",
          "create_terminal_writer",
          "_iter_all_modules",
          "getvalueorskip",
          "Token",
          "TYPE_CHECKING",
          "filter_traceback",
          "getfailedcollections",
          "Frame",
          "get_cache_dir",
          "for_config",
          "resume_fixture",
          "_wrapped_pdb_cls",
          "DEFAULT_LOG_FORMAT",
          "parametrize",
          "ReprFuncArgs",
          "_compare_eq_dict",
          "teardown",
          "__ne__",
          "listoutcomes",
          "_get_report_choice",
          "_locationline",
          "passed",
          "MonkeyPatch",
          "register",
          "_EmptyClass",
          "exitstatus",
          "FuncFixtureInfo",
          "AssertionRewriter",
          "tbfilter",
          "install_importhook",
          "parseconfigure",
          "_addexcinfo",
          "__array_priority__",
          "FixtureRequest_fspath",
          "saferepr",
          "getmodpath",
          "stopTest",
          "read",
          "__next__",
          "_traceback_filter",
          "showhelp",
          "caplog_handler_key",
          "computehash",
          "runitem",
          "pytest_ignore_collect",
          "gethookrecorder",
          "verbosity",
          "wcswidth",
          "_get_directory",
          "longreprtext",
          "mode",
          "append_pass",
          "perform_collect",
          "FixtureFunctionMarker",
          "_notin_text",
          "_split_lines",
          "__contains__",
          "_prepareconfig",
          "try_cleanup",
          "mangle_test_address",
          "_as_numpy_array",
          "_geterrnoclass",
          "_format_boolop",
          "PytestDeprecationWarning",
          "not_expr",
          "pytest_cmdline_parse",
          "_assert_start_repr",
          "monkeypatch",
          "_format_action_invocation",
          "set_trace",
          "argnames",
          "_log_text",
          "CollectReport",
          "_params_converter",
          "WarningReport",
          "getimfunc",
          "add_stats",
          "FunctionDefinition",
          "_warn_about_missing_assertion",
          "genitems",
          "getworkerinfoline",
          "stop_capturing",
          "pytest_markeval_namespace",
          "_is_in_confcutdir",
          "reorder_items_atscope",
          "section",
          "autouse",
          "_excinfo",
          "_param_ids_from",
          "from_exc_info",
          "parseoutcomes",
          "_get_first_non_fixture_func",
          "relline",
          "pytest_sessionfinish",
          "Mark",
          "import_path",
          "_diff_text",
          "parse_num",
          "_should_truncate_item",
          "_eval_scope_callable",
          "main",
          "setdefault",
          "NOSE_SUPPORT_METHOD",
          "_recursive_sequence_map",
          "fail_marker",
          "read_global_capture",
          "FDCaptureBinary",
          "get_terminal_writer",
          "check_ispytest",
          "handleError",
          "get_sections",
          "hasplugin",
          "_processopt",
          "names_closure",
          "addDuration",
          "_parse_parametrize_args",
          "ApproxNumpy",
          "truncate_if_required",
          "__bool__",
          "expression",
          "_idval_from_function",
          "style",
          "_build_normal_summary_stats_line",
          "MatcherAdapter",
          "_hook",
          "write_sep",
          "repr_locals",
          "Markable",
          "notify_exception",
          "DOCTEST_REPORT_CHOICE_NONE",
          "recwarn",
          "path",
          "_get_continue_on_failure",
          "__eq__",
          "HIGH_SCOPES",
          "catch_unraisable_exception",
          "_W",
          "resume_capturing",
          "nextitem",
          "parse_warning_filter",
          "_traceback",
          "parts",
          "insert_missing_modules",
          "INTERNAL_ERROR",
          "add_report_section",
          "getcall",
          "set_log_path",
          "README_CONTENT",
          "OR",
          "fail_fixturefunc",
          "pop",
          "_validate_ids",
          "lineno",
          "item_capture",
          "_teardown_yield_fixture",
          "isiterable",
          "Testdir",
          "_get_legacy_hook_marks",
          "names",
          "_get_active_fixturedef",
          "__len__",
          "call_fixture_func",
          "_get_multicapture",
          "KEYWORD_MSG_ARG",
          "addini",
          "pytest_report_header",
          "dotfile",
          "_get_maxsize_for_saferepr",
          "fault_handler_stderr_fd_key",
          "DoctestModule",
          "rename",
          "TestShortLogReport",
          "mtime",
          "name",
          "getgroup",
          "__truediv__",
          "tell",
          "_get_allow_bytes_flag",
          "_compare_approx",
          "make_numbered_dir_with_cleanup",
          "local",
          "Node_fspath_set",
          "mark",
          "CaptureManager",
          "startTest",
          "suspend_fixture",
          "_HandlerType",
          "RPAREN",
          "get_temproot",
          "suspend_capturing",
          "get_data",
          "add_marker",
          "_format_lines",
          "_addoption",
          "popcall",
          "_warn_incompatibility_with_xunit2",
          "dirname",
          "PYC_EXT",
          "tmpdir",
          "__div__",
          "isdir",
          "getgroupid",
          "nose",
          "tb",
          "FixtureDef",
          "write_docstring",
          "istestclass",
          "session",
          "PdbTrace",
          "_check_non_top_pytest_plugins",
          "_makefile",
          "_io",
          "_compute_fixture_value",
          "_pluginmanager",
          "_build_collect_only_summary_stats_line",
          "_importconftest",
          "debugging",
          "DropShorterLongHelpFormatter",
          "append_failure",
          "testdir",
          "importorskip",
          "_create",
          "module_name_from_path",
          "_resolve_parameter_set_ids",
          "setmulti",
          "_CaptureMethod",
          "scandir",
          "deindent",
          "pytest_collection_finish",
          "funcnamefilter",
          "markup",
          "pytest_load_initial_conftests",
          "ArgsSource",
          "undo",
          "SafeRepr",
          "pytest_cmdline_preparse",
          "stat",
          "_get_progress_information_message",
          "getstatementrange",
          "request",
          "repr_failure",
          "CaptureBase",
          "default_plugins",
          "python_path",
          "_remove_ansi_escape_sequences",
          "from_config",
          "_schedule_finalizers",
          "setattr",
          "hasinit",
          "_getconftest_pathlist",
          "hookimpl",
          "nodes",
          "_initrequest",
          "assert_never",
          "_ensuresyspath",
          "FixtureLookupErrorRepr",
          "Stash",
          "legacy_path",
          "parse_hookimpl_opts",
          "_S",
          "flow_marker",
          "_idlist",
          "tracebackcutdir",
          "owner",
          "OptionGroup",
          "reset",
          "basename",
          "_testcase",
          "FSCollector",
          "LFPlugin",
          "pytest_assertion_pass",
          "MarkMatcher",
          "_repr_failure_py",
          "hasnew",
          "_resolve_ids",
          "atime",
          "format_explanation",
          "_determine_main_color",
          "visit_BoolOp",
          "_statcache",
          "NODE_CTOR_FSPATH_ARG",
          "getitem",
          "cache_dir_from_config",
          "capstderr",
          "get_dirs_from_args",
          "_set_initial_conftests",
          "with_repr_style",
          "_split_explanation",
          "_suspend",
          "iter_markers",
          "LEGACY_PATH",
          "pos",
          "write_binary",
          "cache_key",
          "_LiveLoggingNullHandler",
          "_get_fixturestack",
          "disabled",
          "chain",
          "_write_source",
          "capsysbinary",
          "syspath_prepend",
          "getfailures",
          "inline_run",
          "f_locals",
          "_report_keyboardinterrupt",
          "_compare_eq_any",
          "TerminalRepr",
          "path_matches_patterns",
          "PytestUnhandledThreadExceptionWarning",
          "snap",
          "_mk_tmp",
          "FormattedExcinfo",
          "record_testreport",
          "PseudoFixtureDef",
          "warnings",
          "matching_platform",
          "pytest_itemcollected",
          "stepwise",
          "record_testsuite_property",
          "TerminalReporter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "dump",
          "ArgumentError",
          "call_and_report",
          "_addoption_instance",
          "LocalPath",
          "Node_fspath",
          "freeze_support",
          "_REPORTCHARS_DEFAULT",
          "_errno2class",
          "_config",
          "_get_line_with_reprcrash_message",
          "_inject_setup_module_fixture",
          "fnmatch_ex",
          "D",
          "variable",
          "get_real_method",
          "CollectError",
          "Code",
          "_to_json",
          "LoggingPlugin",
          "ColoredLevelFormatter",
          "lex",
          "join",
          "Collector",
          "merge_family",
          "get_terminal_width",
          "pypkgpath",
          "suspend",
          "PercentStyleMultiline",
          "restore",
          "_opentestcase",
          "KeywordMatcher",
          "doctest_namespace",
          "check",
          "sep",
          "append_skipped",
          "Scanner",
          "WarningsChecker",
          "StepwisePlugin",
          "mkdtemp",
          "_setup_fixtures",
          "setmtime",
          "pytest_runtest_makereport",
          "get_public_names",
          "get_config",
          "_ensuredirs",
          "LineMatcher_fixture",
          "ParameterSet",
          "_arg2scope",
          "_warn_about_skipped_plugins",
          "IDENT_PREFIX",
          "DoctestItem",
          "next_higher",
          "locals",
          "caplog_records_key",
          "instance",
          "_log_cli_enabled",
          "catching_logs",
          "CACHEDIR_TAG_CONTENT",
          "FNMatcher",
          "fullwidth",
          "_get_flag_lookup",
          "ARGUMENT_TYPE_STR",
          "resume",
          "tolerance",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "__iter__",
          "__getattr__",
          "_enter_pdb",
          "__exit__",
          "ErrorMaker",
          "Metafunc",
          "PytestUnknownMarkWarning",
          "set",
          "entrysep",
          "errisinstance",
          "_patch_unwrap_mock_aware",
          "accept",
          "_depend_on_existence",
          "_getreprcrash",
          "_stat",
          "result",
          "pytest_runtest_logreport",
          "Parser",
          "istestfunc",
          "K",
          "outcomes",
          "iscoroutinefunction",
          "combined_with",
          "fixtures",
          "samefile",
          "fullsource",
          "_from_json",
          "_pretty_fixture_path",
          "LineComp",
          "at_level",
          "__slots__",
          "PytestReturnNotNoneWarning",
          "assertrepr_compare",
          "pytest_plugins",
          "show_fixtures_per_test",
          "failed",
          "EMPTY_PARAMETERSET_OPTION",
          "_call_reprcompare",
          "RetentionType",
          "_force_enable_logging",
          "absolutepath",
          "MyOptionParser",
          "TempPathFactory",
          "getbasetemp",
          "clear",
          "__module__",
          "should_do_markup",
          "Session_stardir",
          "_add_stats",
          "value",
          "error",
          "pytest_make_parametrize_id",
          "DatetimeFormatter",
          "ApproxDecimal",
          "_ascii_escaped_by_config",
          "ExceptionInfo",
          "INCOVATION_DIR",
          "emit",
          "RUNNER_CLASS",
          "pytest_fixture_setup",
          "_match_lines",
          "_py",
          "realpath",
          "count_towards_summary",
          "letter",
          "isattrs",
          "checked_call",
          "Notset",
          "token",
          "maketxtfile",
          "wcwidth",
          "parse_known_args",
          "_windowsconsoleio_workaround",
          "makeconftest",
          "derive_importpath",
          "str",
          "_PYTEST_DIR",
          "num_mock_patch_args",
          "relto",
          "stop",
          "exists",
          "runtestprotocol",
          "category",
          "pytestconfig",
          "_fillfixtures",
          "fixture",
          "check_testcase_implements_trial_reporter",
          "ascii_escaped",
          "add_attribute",
          "TESTS_FAILED",
          "_T",
          "_idval_from_value",
          "getvalue",
          "endswith",
          "_get_global_properties_node",
          "width_of_current_line",
          "FSHookProxy",
          "_is_setup_py",
          "_matchfactories",
          "warn_explicit_for",
          "freeze_includes",
          "file",
          "own_mark_names",
          "create_new_paste",
          "text",
          "pytest_runtest_teardown",
          "AND",
          "parse_hookspec_opts",
          "basestarts",
          "_error_maker",
          "PytestWarning",
          "_trace",
          "__missing__",
          "short_test_summary",
          "_ensure_immutable_ids",
          "ConftestImportFailure",
          "locate_config",
          "get_direct_param_fixture_func",
          "_saved",
          "Argument",
          "capfd",
          "_param_ids_generated",
          "_non_numeric_type_error",
          "cache",
          "_ensure_removed_sysmodule",
          "_format_trimmed",
          "getfixtureinfo",
          "iterparentnodeids",
          "_IGNORED_ERRORS",
          "seek",
          "_check_record_param_type",
          "_in_suspended",
          "idfn",
          "assertion",
          "AlwaysDispatchingPrettyPrinter",
          "attrs",
          "_repr_compare",
          "_is_doctest",
          "_is_started",
          "_compare_eq_iterable",
          "_ispytest",
          "makepyfile",
          "Error"
        ]
      },
      "response": {
        "keywords": [
          "Logger",
          "store",
          "sys.modules",
          "core.initialize",
          "importlib",
          "logging",
          "test_commands",
          "tests.unit.test_commands",
          "pkg_resources",
          "class"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:33:51.725150",
        "usage": "357.15317726135254 ms"
      },
      "request": {
        "tokens": [
          "Logger",
          "store",
          "sys.modules",
          "core.initialize",
          "importlib",
          "logging",
          "test_commands",
          "tests.unit.test_commands",
          "pkg_resources",
          "class"
        ]
      },
      "response": {
        "results": {
          "class": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_py/path.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/_py/error.py",
            "src/_pytest/pytester.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/main.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/skipping.py",
            "src/_pytest/scope.py",
            "src/_pytest/stash.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/compat.py",
            "src/_pytest/stepwise.py"
          ],
          "sys.modules": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/unittest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/pytester.py",
            "src/_pytest/compat.py",
            "src/_pytest/_py/path.py",
            "src/py.py"
          ],
          "store": [
            "src/_pytest/main.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stash.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pastebin.py"
          ],
          "logging": [
            "src/_pytest/junitxml.py",
            "src/_pytest/reports.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/pytest/__init__.py",
            "src/_pytest/compat.py"
          ],
          "importlib": [
            "src/_pytest/main.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/pytester.py",
            "src/_pytest/_py/path.py"
          ],
          "Logger": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py"
          ],
          "pkg_resources": [
            "src/_pytest/monkeypatch.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:33:52.082315",
        "usage": "5605.509996414185 ms"
      },
      "request": {
        "keyword_search_results": {
          "class": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_py/path.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/_py/error.py",
            "src/_pytest/pytester.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/main.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/skipping.py",
            "src/_pytest/scope.py",
            "src/_pytest/stash.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/compat.py",
            "src/_pytest/stepwise.py"
          ],
          "sys.modules": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/unittest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/debugging.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/pytester.py",
            "src/_pytest/compat.py",
            "src/_pytest/_py/path.py",
            "src/py.py"
          ],
          "store": [
            "src/_pytest/main.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stash.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pastebin.py"
          ],
          "logging": [
            "src/_pytest/junitxml.py",
            "src/_pytest/reports.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/pytest/__init__.py",
            "src/_pytest/compat.py"
          ],
          "importlib": [
            "src/_pytest/main.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/pytester.py",
            "src/_pytest/_py/path.py"
          ],
          "Logger": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py"
          ],
          "pkg_resources": [
            "src/_pytest/monkeypatch.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "To address the issue, we need to focus on the reported problem regarding module import using 'importlib' and check for the presence of two versions of a module. The relevant keywords from the issue are:\n\n1. `importlib`: Indicates the change in import strategy.\n2. `sys.modules`: Mentioned in the context of identifying two loaded versions of `pmxbot.logging`.\n3. `logging`: Since the error involves `logging.Logger.store`, this keyword will point us to files involving logging issues.\n\nHere's how each of these relate to the files in the codebase:\n\n- `importlib`: The files mentioning `importlib` might help us in understanding the import strategy or how imports are handled.\n  - `src/_pytest/config/__init__.py`\n  - `src/_pytest/main.py`\n\n- `sys.modules`: Files related to `sys.modules` might give insights on how modules are tracked or manipulated, related to the duplication.\n  - There's no direct file labeled for `sys.modules` in the keyword search, perhaps encoded in other related parts.\n\n- `logging`: Since `pmxbot.logging` is directly related to the error reported, this keyword and its files are crucial.\n  - `src/_pytest/logging.py`\n\nTherefore, the most relevant files are those related to `importlib` and `logging`. The use of `sys.modules` and its impact might be more deeply embedded in logic not plainly associated with just `sys.modules`. Selecting files that are likely setting up, manipulating, or troubleshooting imports and logging is critical.",
        "file_paths": [
          "src/_pytest/logging.py",
          "src/_pytest/main.py",
          "src/_pytest/config/__init__.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:33:57.687871",
        "usage": "10037.528038024902 ms"
      },
      "request": {
        "file_path": "src/_pytest/logging.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue relates to `pmxbot` being improperly imported in tests, causing failures when `core.initialize()` should set a class variable `pmxbot.logging.Logger.store`, but doesn't seem to do so.\n1.2 The reproduction steps involve running tests using pytest and observing if the variables are correctly set, but the setting fails as two versions of `pmxbot.logging` exist.\n1.3 The issue is likely caused by `importlib` import-mode leading to duplicated module paths in `sys.modules`, possibly due to incorrect test setup or imports.\n1.4 The user expects the tests to pass by correctly setting the `store` attribute in `Logger` as a result of `core.initialize()`.\n1.6 To solve it, ensure only one package is loaded into `sys.modules` and remove any sub-package/module path inconsistencies.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/logging.py` is primarily dealing with logging setup and handlers in pytest.\n2.2 There's no explicit mention of `pmxbot` or `importlib` in this file, indicating this isn't the root cause.\n2.3 Symbols like `LogCaptureHandler` and `LoggingPlugin` relate to logging behavior, which is tangential but not directly causing the issue.\n2.4 No indications of altering Python's import system (like modifying `sys.modules` directly for `pmxbot`). \n2.5 This suggests the issue might instead relate to how tests or the pmxbot files themselves are structured/loaded (i.e., namespace issues in the test files or main package files).",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "pmxbot/__init__.py",
          "tests/unit/test_commands.py",
          "pmxbot/logging.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:07.725415",
        "usage": "8386.37900352478 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing User Instructions:\n1.1 The user describes an issue where a module is imported twice when using importlib mode. Specifically, pmxbot.logging is imported twice: once in sys.modules and once under tests.unit.test_commands.logging.\n1.2 The user doesn't provide specific reproduction steps but mentions the context of running tests where the core.initialize() call does not have the expected effect as it sets Logger.store only within one instance of the pmxbot.logging module.\n1.3 The issue is likely caused by using importlib as the import mode, which might not handle namespaces and module path collisions as expected, leading to distinct versions of what should be the same module.\n1.4 The user's expectation is for the module to be singularly imported, maintaining its state consistently across the test suite.\n1.6 Solutions might involve ensuring namespace packages and imports are correctly aligned to prevent multiple instances of the same module.\n\n3. Based on the file content analysis:\nThe `_pytest/main.py` file is mainly involved in configuring and executing pytest sessions, including handling import modes.\nThe function `pytest_addoption` adds import-mode as an option.\nThe function `search_pypath` might be relevant to the issue as it uses importlib to resolve module paths.\nThe function `resolve_collection_argument` deals with path manipulations and can impact how pytest sees paths during testing.\n\nThe issue might be related to improper handling of import paths or configurations in test execution, with an emphasis on how pytest manages namespace modules when using importlib.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/pmxbot/core.py",
          "src/pmxbot/logging.py"
        ],
        "relevant_symbols": [
          "pytest_addoption",
          "search_pypath",
          "resolve_collection_argument"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:16.111817",
        "usage": "7046.792984008789 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user reports that the `pmxbot` package is imported twice due to switching the import style to PEP 420 namespace packages through `importlib`. This dual import leads to issues where the `core.initialize()` method doesn't work as expected, particularly with setting a class variable `pmxbot.logging.Logger.store`.\n1.2 The user notices that `pmxbot.logging` is present in `sys.modules`, but another version is found in `tests.unit.test_commands.logging`, which indicates a potential multiple import scenario.\n1.3 This scenario may be caused by how the new import mechanism (importlib) handles imported modules versus how the tests are set up, perhaps leading to the same module being imported under different paths or contexts.\n1.4 The user expects `core.initialize()` to consistently set `Logger.store`, but due to dual imports, this class variable doesn't get set as intended, leading to an `AttributeError` when it's accessed.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/config/__init__.py` is mostly concerned with pytest's internal configurations, command-line parsing, and plugin management.\n2.4 The file discusses import behaviors, especially around conftest files, but there are no direct references to the importlib's package handling or import customization related to the user's issue.\n2.5 The file does not seem to directly manage or manipulate `importlib` in a manner that could lead to the described double-import issue.\n2.6 This file seems to not be related to the root cause, which is specific to import behavior possibly highlighted in test setup or initialization code in the user's setup.\n\nOverall, this file appears to deal with pytest configurations and does not directly contribute to the PEP 420 import behavior or issue described by the user. As such, it is not directly relevant.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pathlib.py",
          "src/_pytest/assertion/rewrite.py",
          "path/to/pmxbot/core.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:34:23.158697",
        "usage": "96.9541072845459 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/logging.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "pytest_addoption",
              "search_pypath",
              "resolve_collection_argument"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "test._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption",
            "start_line": 21,
            "start_column": 592,
            "end_line": 0,
            "end_column": 1385,
            "start_byte": 592,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path_ = path if isinstance(path, Path) else Path(path)\n        return path_ in self._initialpaths\n\n    def gethookproxy(self, fspath: \"os.PathLike[str]\"):\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path = fspath if isinstance(fspath, Path) else Path(fspath)\n        pm = self.config.pluginmanager\n        # Check if we have the common case of running\n        # hooks with all conftest.py files.\n        my_conftestmodules = pm._getconftestmodules(\n            path,\n            self.config.getoption(\"importmode\"),\n            rootpath=self.config.rootpath,\n        )\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # One or more conftests are not in use at this fspath.\n            from .config.compat import PathAwareHookProxy\n\n            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))\n        else:\n            # All plugins are active for this fspath.\n            proxy = self.config.hook\n        return proxy\n\n    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        fspath = Path(direntry.path)\n        ihook = self.gethookproxy(fspath.parent)\n        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n            return False\n        return True\n\n    def _collectf",
            "start_line": 453,
            "start_column": 16621,
            "end_line": 0,
            "end_column": 18400,
            "start_byte": 16621,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n ",
            "start_line": 42,
            "start_column": 1108,
            "end_line": 0,
            "end_column": 1587,
            "start_byte": 1108,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "_pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[",
            "start_line": 43,
            "start_column": 1224,
            "end_line": 0,
            "end_column": 1946,
            "start_byte": 1224,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --s",
            "start_line": 68,
            "start_column": 1950,
            "end_line": 0,
            "end_column": 3384,
            "start_byte": 1950,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfr",
            "start_line": 16,
            "start_column": 326,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 326,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1371,
            "start_column": 53324,
            "end_line": 0,
            "end_column": 53528,
            "start_byte": 53324,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encoun",
            "start_line": 43,
            "start_column": 1340,
            "end_line": 0,
            "end_column": 2976,
            "start_byte": 1340,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another",
            "start_line": 80,
            "start_column": 2567,
            "end_line": 0,
            "end_column": 4122,
            "start_byte": 2567,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "self, pm: PytestPluginManager, remove_mods) -> None:\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"\n\n    __module__ = \"builtins\"  # For py3.\n\n\nclass Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n\n\n@dataclasses.dataclass\nclass _bestrelpath_cache(Dict[Path, str]):\n    __slots__ = (\"path\",)\n\n    path: Path\n\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n\n\n@final\nclass Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager: FixtureManager\n    exitstatus: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        super().__init__(\n            path=config.rootpath,\n            fspath=None,\n            parent=None,\n            config=config,\n            session=self,\n            nodeid=\"\",\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop: Union[bool, s",
            "start_line": 381,
            "start_column": 13650,
            "end_line": 0,
            "end_column": 15025,
            "start_byte": 13650,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n            else:\n                if isinstance(excinfo.value, SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        os.chdir(session.startpath)\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:\n    return wrap_session(config, _main)\n\n\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\"Default command line protocol for initialization, session,\n    running tests and reporting.\"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    session.perform_collect()\n\n\ndef pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path: Path) -> bool:\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script.\"\"\"\n    bindir = path.joinpath(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    try:\n        i",
            "start_line": 237,
            "start_column": 8743,
            "end_line": 0,
            "end_column": 11544,
            "start_byte": 8743,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )",
            "start_line": 49,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 6649,
            "start_byte": 1365,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.search_pypath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def search_pypath(module_name: str) -> str:\n    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n    try:\n        spec = importlib.util.find_spec(module_name)\n    # AttributeError: looks like package module, but actually filename\n    # ImportError: module does not exist\n    # ValueError: not a module name\n    except (AttributeError, ImportError, ValueError):\n        return module_name\n    if spec is None or spec.origin is None or spec.origin == \"namespace\":\n        return module_name\n    elif spec.submodule_search_locations:\n        return os.path.dirname(spec.origin)\n    else:\n        return spec.origin",
            "start_line": 842,
            "start_column": 29973,
            "end_line": 0,
            "end_column": 30626,
            "start_byte": 29973,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.resolve_collection_argument",
            "file_path": "src/_pytest/main.py",
            "file_content": "def resolve_collection_argument(\n    invocation_path: Path, arg: str, *, as_pypath: bool = False\n) -> Tuple[Path, List[str]]:\n    \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n\n    Command-line arguments can point to files and/or directories, and optionally contain\n    parts for specific tests selection, for example:\n\n        \"pkg/tests/test_foo.py::TestClass::test_foo\"\n\n    This function ensures the path exists, and returns a tuple:\n\n        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n\n    When as_pypath is True, expects that the command-line argument actually contains\n    module paths instead of file-system paths:\n\n        \"pkg.tests.test_foo::TestClass::test_foo\"\n\n    In which case we search sys.path for a matching module, and then return the *path* to the\n    found module.\n\n    If the path doesn't exist, raise UsageError.\n    If the path is a directory and selection parts are present, raise UsageError.\n    \"\"\"\n    base, squacket, rest = str(arg).partition(\"[\")\n    strpath, *parts = base.split(\"::\")\n    if parts:\n        parts[-1] = f\"{parts[-1]}{squacket}{rest}\"\n    if as_pypath:\n        strpath = search_pypath(strpath)\n    fspath = invocation_path / strpath\n    fspath = absolutepath(fspath)\n    if not fspath.exists():\n        msg = (\n            \"module or package not found: {arg} (missing __init__.py?)\"\n            if as_pypath\n            else \"file or directory not found: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    if parts and fspath.is_dir():\n        msg = (\n            \"package argument cannot contain :: selection parts: {arg}\"\n            if as_pypath\n            else \"directory argument cannot contain :: selection parts: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    return fspath, parts",
            "start_line": 859,
            "start_column": 30629,
            "end_line": 0,
            "end_column": 32474,
            "start_byte": 30629,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "neral\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to l",
            "start_line": 69,
            "start_column": 1986,
            "end_line": 0,
            "end_column": 3604,
            "start_byte": 1986,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "yping import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hooki",
            "start_line": 17,
            "start_column": 429,
            "end_line": 0,
            "end_column": 772,
            "start_byte": 429,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addop",
            "start_line": 84,
            "start_column": 2254,
            "end_line": 0,
            "end_column": 2881,
            "start_byte": 2254,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_",
            "start_line": 91,
            "start_column": 2951,
            "end_line": 0,
            "end_column": 4390,
            "start_byte": 2951,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "xtensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n",
            "start_line": 49,
            "start_column": 1338,
            "end_line": 0,
            "end_column": 1908,
            "start_byte": 1338,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom ",
            "start_line": 14,
            "start_column": 368,
            "end_line": 0,
            "end_column": 781,
            "start_byte": 368,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " typing import final\nfrom typing import FrozenSet\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nf",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 557,
            "start_byte": 265,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import ",
            "start_line": 25,
            "start_column": 670,
            "end_line": 0,
            "end_column": 1166,
            "start_byte": 670,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcome",
            "start_line": 17,
            "start_column": 381,
            "end_line": 0,
            "end_column": 970,
            "start_byte": 381,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "icit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n\n\ndef validate_basetemp(path: str) -> str:\n    # GH 7119\n    msg = \"basetemp must not be empty, the current working directory or any parent directory of it\"\n\n    # empty path\n    if not path:\n        raise argparse.ArgumentTypeError(msg)\n\n    def is_ancestor(base: Path, query: Path) -> bool:\n        \"\"\"Return whether query is an ancestor of base.\"\"\"\n        if base == query:\n            return True\n        return query in base.parents\n\n    # check if path is an ancestor of cwd\n    if is_ancestor(Path.cwd(), Path(path).absolute()):\n        raise argparse.ArgumentT",
            "start_line": 135,
            "start_column": 3636,
            "end_line": 0,
            "end_column": 7219,
            "start_byte": 3636,
            "end_byte": 0
          },
          {
            "name": "_pytest.tmpdir.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "nterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(f\"{excinfo.typename}: {excinfo.value.msg}\\n\")\n            config.hook.py",
            "start_line": 222,
            "start_column": 8101,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8101,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_path.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "mport argparse\nimport dataclasses\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom pathlib import Path\nfrom",
            "start_line": 7,
            "start_column": 80,
            "end_line": 0,
            "end_column": 213,
            "start_byte": 80,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": []
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:23.255659",
        "usage": "15981.27293586731 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "test._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption",
            "start_line": 21,
            "start_column": 592,
            "end_line": 0,
            "end_column": 1385,
            "start_byte": 592,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path_ = path if isinstance(path, Path) else Path(path)\n        return path_ in self._initialpaths\n\n    def gethookproxy(self, fspath: \"os.PathLike[str]\"):\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path = fspath if isinstance(fspath, Path) else Path(fspath)\n        pm = self.config.pluginmanager\n        # Check if we have the common case of running\n        # hooks with all conftest.py files.\n        my_conftestmodules = pm._getconftestmodules(\n            path,\n            self.config.getoption(\"importmode\"),\n            rootpath=self.config.rootpath,\n        )\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # One or more conftests are not in use at this fspath.\n            from .config.compat import PathAwareHookProxy\n\n            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))\n        else:\n            # All plugins are active for this fspath.\n            proxy = self.config.hook\n        return proxy\n\n    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        fspath = Path(direntry.path)\n        ihook = self.gethookproxy(fspath.parent)\n        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n            return False\n        return True\n\n    def _collectf",
            "start_line": 453,
            "start_column": 16621,
            "end_line": 0,
            "end_column": 18400,
            "start_byte": 16621,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n ",
            "start_line": 42,
            "start_column": 1108,
            "end_line": 0,
            "end_column": 1587,
            "start_byte": 1108,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "_pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[",
            "start_line": 43,
            "start_column": 1224,
            "end_line": 0,
            "end_column": 1946,
            "start_byte": 1224,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --s",
            "start_line": 68,
            "start_column": 1950,
            "end_line": 0,
            "end_column": 3384,
            "start_byte": 1950,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfr",
            "start_line": 16,
            "start_column": 326,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 326,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1371,
            "start_column": 53324,
            "end_line": 0,
            "end_column": 53528,
            "start_byte": 53324,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encoun",
            "start_line": 43,
            "start_column": 1340,
            "end_line": 0,
            "end_column": 2976,
            "start_byte": 1340,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another",
            "start_line": 80,
            "start_column": 2567,
            "end_line": 0,
            "end_column": 4122,
            "start_byte": 2567,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "self, pm: PytestPluginManager, remove_mods) -> None:\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"\n\n    __module__ = \"builtins\"  # For py3.\n\n\nclass Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n\n\n@dataclasses.dataclass\nclass _bestrelpath_cache(Dict[Path, str]):\n    __slots__ = (\"path\",)\n\n    path: Path\n\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n\n\n@final\nclass Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager: FixtureManager\n    exitstatus: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        super().__init__(\n            path=config.rootpath,\n            fspath=None,\n            parent=None,\n            config=config,\n            session=self,\n            nodeid=\"\",\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop: Union[bool, s",
            "start_line": 381,
            "start_column": 13650,
            "end_line": 0,
            "end_column": 15025,
            "start_byte": 13650,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n            else:\n                if isinstance(excinfo.value, SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        os.chdir(session.startpath)\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:\n    return wrap_session(config, _main)\n\n\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\"Default command line protocol for initialization, session,\n    running tests and reporting.\"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    session.perform_collect()\n\n\ndef pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path: Path) -> bool:\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script.\"\"\"\n    bindir = path.joinpath(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    try:\n        i",
            "start_line": 237,
            "start_column": 8743,
            "end_line": 0,
            "end_column": 11544,
            "start_byte": 8743,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )",
            "start_line": 49,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 6649,
            "start_byte": 1365,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.search_pypath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def search_pypath(module_name: str) -> str:\n    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n    try:\n        spec = importlib.util.find_spec(module_name)\n    # AttributeError: looks like package module, but actually filename\n    # ImportError: module does not exist\n    # ValueError: not a module name\n    except (AttributeError, ImportError, ValueError):\n        return module_name\n    if spec is None or spec.origin is None or spec.origin == \"namespace\":\n        return module_name\n    elif spec.submodule_search_locations:\n        return os.path.dirname(spec.origin)\n    else:\n        return spec.origin",
            "start_line": 842,
            "start_column": 29973,
            "end_line": 0,
            "end_column": 30626,
            "start_byte": 29973,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.resolve_collection_argument",
            "file_path": "src/_pytest/main.py",
            "file_content": "def resolve_collection_argument(\n    invocation_path: Path, arg: str, *, as_pypath: bool = False\n) -> Tuple[Path, List[str]]:\n    \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n\n    Command-line arguments can point to files and/or directories, and optionally contain\n    parts for specific tests selection, for example:\n\n        \"pkg/tests/test_foo.py::TestClass::test_foo\"\n\n    This function ensures the path exists, and returns a tuple:\n\n        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n\n    When as_pypath is True, expects that the command-line argument actually contains\n    module paths instead of file-system paths:\n\n        \"pkg.tests.test_foo::TestClass::test_foo\"\n\n    In which case we search sys.path for a matching module, and then return the *path* to the\n    found module.\n\n    If the path doesn't exist, raise UsageError.\n    If the path is a directory and selection parts are present, raise UsageError.\n    \"\"\"\n    base, squacket, rest = str(arg).partition(\"[\")\n    strpath, *parts = base.split(\"::\")\n    if parts:\n        parts[-1] = f\"{parts[-1]}{squacket}{rest}\"\n    if as_pypath:\n        strpath = search_pypath(strpath)\n    fspath = invocation_path / strpath\n    fspath = absolutepath(fspath)\n    if not fspath.exists():\n        msg = (\n            \"module or package not found: {arg} (missing __init__.py?)\"\n            if as_pypath\n            else \"file or directory not found: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    if parts and fspath.is_dir():\n        msg = (\n            \"package argument cannot contain :: selection parts: {arg}\"\n            if as_pypath\n            else \"directory argument cannot contain :: selection parts: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    return fspath, parts",
            "start_line": 859,
            "start_column": 30629,
            "end_line": 0,
            "end_column": 32474,
            "start_byte": 30629,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "neral\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to l",
            "start_line": 69,
            "start_column": 1986,
            "end_line": 0,
            "end_column": 3604,
            "start_byte": 1986,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "yping import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hooki",
            "start_line": 17,
            "start_column": 429,
            "end_line": 0,
            "end_column": 772,
            "start_byte": 429,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addop",
            "start_line": 84,
            "start_column": 2254,
            "end_line": 0,
            "end_column": 2881,
            "start_byte": 2254,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_",
            "start_line": 91,
            "start_column": 2951,
            "end_line": 0,
            "end_column": 4390,
            "start_byte": 2951,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "xtensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n",
            "start_line": 49,
            "start_column": 1338,
            "end_line": 0,
            "end_column": 1908,
            "start_byte": 1338,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom ",
            "start_line": 14,
            "start_column": 368,
            "end_line": 0,
            "end_column": 781,
            "start_byte": 368,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " typing import final\nfrom typing import FrozenSet\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nf",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 557,
            "start_byte": 265,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import ",
            "start_line": 25,
            "start_column": 670,
            "end_line": 0,
            "end_column": 1166,
            "start_byte": 670,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcome",
            "start_line": 17,
            "start_column": 381,
            "end_line": 0,
            "end_column": 970,
            "start_byte": 381,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "icit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n\n\ndef validate_basetemp(path: str) -> str:\n    # GH 7119\n    msg = \"basetemp must not be empty, the current working directory or any parent directory of it\"\n\n    # empty path\n    if not path:\n        raise argparse.ArgumentTypeError(msg)\n\n    def is_ancestor(base: Path, query: Path) -> bool:\n        \"\"\"Return whether query is an ancestor of base.\"\"\"\n        if base == query:\n            return True\n        return query in base.parents\n\n    # check if path is an ancestor of cwd\n    if is_ancestor(Path.cwd(), Path(path).absolute()):\n        raise argparse.ArgumentT",
            "start_line": 135,
            "start_column": 3636,
            "end_line": 0,
            "end_column": 7219,
            "start_byte": 3636,
            "end_byte": 0
          },
          {
            "name": "_pytest.tmpdir.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "nterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(f\"{excinfo.typename}: {excinfo.value.msg}\\n\")\n            config.hook.py",
            "start_line": 222,
            "start_column": 8101,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8101,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_path.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "mport argparse\nimport dataclasses\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom pathlib import Path\nfrom",
            "start_line": 7,
            "start_column": 80,
            "end_line": 0,
            "end_column": 213,
            "start_byte": 80,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": []
      },
      "response": {
        "scratch_pad": "## Step 1: Analyze User Instructions\n\n1.1 **Issue Described**: The user is experiencing an issue where `core.initialize()` does not seem to have an effect due to two different versions of `pmxbot.logging` being present. One module is in `sys.modules` and another in `tests.unit.test_commands.logging`. This results in an attribute error when accessing `logging.Logger.store`.\n\n1.2 **Cause of the Issue**: This could be due to using `importlib` style importing which may lead to a module being loaded twice if `sys.path` settings or the way imports are handled across different paths are not consistent. It is likely related to the change from `pkg_resources` to `PEP 420` namespace packages which could be causing the conflict in module presence.\n\n1.3 **Expected Result**: The `pmxbot.logging.Logger.store` should be correctly initialized and accessible through `core.initialize()`, reflecting that only one consistent module is loaded.\n\n1.4 **Expectation if Not Provided**: Ensure there is only one version of the `pmxbot.logging` module present. Ensure consistent usage in tests and application runtime.\n\n1.5 **Solution Approach**: Investigate how modules are loaded. Ensure `importlib` mode is correctly handling namespace packages. Adjust pytest or import configurations to prevent dual loading.\n\n\\#\n\n## Step 2: Make the Evaluation\n\nI will look for symbols related to module import management, particularly those that could affect how a module is imported and managed in pytest.\n\n2.1+2.2 **Analyze Symbols**: Examine provided symbols to identify potential `import-mode` management or interactions with `sys.modules`.\n\n2.3 **Evaluate Relevance**: Focus on any `importlib`, `pytest` importing methods, configuration options, or sys.path handling which are pertinent to module loading.\n\n2.4 **Decision on Changes**: Determine symbols to be altered for preventing dual module loading.\n\n2.5 **Need More Information**: Determine if additional symbols or context from configuration files are necessary to conclude the initial investigation.",
        "symbols": [
          {
            "name": "_pytest.main.search_pypath",
            "file_path": "src/_pytest/main.py",
            "reason": "This function explicitly deals with searching sys.path for a module name. It could be causing multiple module loads if not correctly implemented with importlib and PEP 420 namespaces."
          },
          {
            "name": "_pytest.main.resolve_collection_argument",
            "file_path": "src/_pytest/main.py",
            "reason": "This method handles command line arguments and potentially module paths when collecting tests. Incorrect handling here might cause duplicate imports in different contexts or import-modes."
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "reason": "This may include options that manage the pytest configuration or how modules are included in tests, potentially affecting how duplicate modules appear."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "The function `search_pypath` searches `sys.path` for a module. If this search is incorrect or does not conform to PEP 420, it might cause multiple instances of a module to be loaded separately. Given the issue described, we should ensure this method handles importlib use properly and does not augment sys.path in a way that leads to separate module loads.",
          "The `resolve_collection_argument` manages modules indicated in command-line paths, resolving them, which could affect how modules are recognized in the test and runtime environments. Improper handling might allow the same module to be fetched differently in disparate parts of the system, leading to dual loading.",
          "This requires investigation for any configuration adjustments that may relate to module importing behavior, particularly when using importlib or related import settings in pytest."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:34:39.237010",
        "usage": "2.5708675384521484 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "test._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption",
              "start_line": 21,
              "start_column": 592,
              "end_line": 0,
              "end_column": 1385,
              "start_byte": 592,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "   maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path_ = path if isinstance(path, Path) else Path(path)\n        return path_ in self._initialpaths\n\n    def gethookproxy(self, fspath: \"os.PathLike[str]\"):\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path = fspath if isinstance(fspath, Path) else Path(fspath)\n        pm = self.config.pluginmanager\n        # Check if we have the common case of running\n        # hooks with all conftest.py files.\n        my_conftestmodules = pm._getconftestmodules(\n            path,\n            self.config.getoption(\"importmode\"),\n            rootpath=self.config.rootpath,\n        )\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # One or more conftests are not in use at this fspath.\n            from .config.compat import PathAwareHookProxy\n\n            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))\n        else:\n            # All plugins are active for this fspath.\n            proxy = self.config.hook\n        return proxy\n\n    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        fspath = Path(direntry.path)\n        ihook = self.gethookproxy(fspath.parent)\n        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n            return False\n        return True\n\n    def _collectf",
              "start_line": 453,
              "start_column": 16621,
              "end_line": 0,
              "end_column": 18400,
              "start_byte": 16621,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": " _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n ",
              "start_line": 42,
              "start_column": 1108,
              "end_line": 0,
              "end_column": 1587,
              "start_byte": 1108,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "_pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[",
              "start_line": 43,
              "start_column": 1224,
              "end_line": 0,
              "end_column": 1946,
              "start_byte": 1224,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "   )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --s",
              "start_line": 68,
              "start_column": 1950,
              "end_line": 0,
              "end_column": 3384,
              "start_byte": 1950,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": " import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfr",
              "start_line": 16,
              "start_column": 326,
              "end_line": 0,
              "end_column": 558,
              "start_byte": 326,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1371,
              "start_column": 53324,
              "end_line": 0,
              "end_column": 53528,
              "start_byte": 53324,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encoun",
              "start_line": 43,
              "start_column": 1340,
              "end_line": 0,
              "end_column": 2976,
              "start_byte": 1340,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "   \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another",
              "start_line": 80,
              "start_column": 2567,
              "end_line": 0,
              "end_column": 4122,
              "start_byte": 2567,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "self, pm: PytestPluginManager, remove_mods) -> None:\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"\n\n    __module__ = \"builtins\"  # For py3.\n\n\nclass Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n\n\n@dataclasses.dataclass\nclass _bestrelpath_cache(Dict[Path, str]):\n    __slots__ = (\"path\",)\n\n    path: Path\n\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n\n\n@final\nclass Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager: FixtureManager\n    exitstatus: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        super().__init__(\n            path=config.rootpath,\n            fspath=None,\n            parent=None,\n            config=config,\n            session=self,\n            nodeid=\"\",\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop: Union[bool, s",
              "start_line": 381,
              "start_column": 13650,
              "end_line": 0,
              "end_column": 15025,
              "start_byte": 13650,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n            else:\n                if isinstance(excinfo.value, SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        os.chdir(session.startpath)\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:\n    return wrap_session(config, _main)\n\n\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\"Default command line protocol for initialization, session,\n    running tests and reporting.\"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    session.perform_collect()\n\n\ndef pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path: Path) -> bool:\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script.\"\"\"\n    bindir = path.joinpath(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    try:\n        i",
              "start_line": 237,
              "start_column": 8743,
              "end_line": 0,
              "end_column": 11544,
              "start_byte": 8743,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )",
              "start_line": 49,
              "start_column": 1365,
              "end_line": 0,
              "end_column": 6649,
              "start_byte": 1365,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.search_pypath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def search_pypath(module_name: str) -> str:\n    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n    try:\n        spec = importlib.util.find_spec(module_name)\n    # AttributeError: looks like package module, but actually filename\n    # ImportError: module does not exist\n    # ValueError: not a module name\n    except (AttributeError, ImportError, ValueError):\n        return module_name\n    if spec is None or spec.origin is None or spec.origin == \"namespace\":\n        return module_name\n    elif spec.submodule_search_locations:\n        return os.path.dirname(spec.origin)\n    else:\n        return spec.origin",
              "start_line": 842,
              "start_column": 29973,
              "end_line": 0,
              "end_column": 30626,
              "start_byte": 29973,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.resolve_collection_argument",
              "file_path": "src/_pytest/main.py",
              "file_content": "def resolve_collection_argument(\n    invocation_path: Path, arg: str, *, as_pypath: bool = False\n) -> Tuple[Path, List[str]]:\n    \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n\n    Command-line arguments can point to files and/or directories, and optionally contain\n    parts for specific tests selection, for example:\n\n        \"pkg/tests/test_foo.py::TestClass::test_foo\"\n\n    This function ensures the path exists, and returns a tuple:\n\n        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n\n    When as_pypath is True, expects that the command-line argument actually contains\n    module paths instead of file-system paths:\n\n        \"pkg.tests.test_foo::TestClass::test_foo\"\n\n    In which case we search sys.path for a matching module, and then return the *path* to the\n    found module.\n\n    If the path doesn't exist, raise UsageError.\n    If the path is a directory and selection parts are present, raise UsageError.\n    \"\"\"\n    base, squacket, rest = str(arg).partition(\"[\")\n    strpath, *parts = base.split(\"::\")\n    if parts:\n        parts[-1] = f\"{parts[-1]}{squacket}{rest}\"\n    if as_pypath:\n        strpath = search_pypath(strpath)\n    fspath = invocation_path / strpath\n    fspath = absolutepath(fspath)\n    if not fspath.exists():\n        msg = (\n            \"module or package not found: {arg} (missing __init__.py?)\"\n            if as_pypath\n            else \"file or directory not found: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    if parts and fspath.is_dir():\n        msg = (\n            \"package argument cannot contain :: selection parts: {arg}\"\n            if as_pypath\n            else \"directory argument cannot contain :: selection parts: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    return fspath, parts",
              "start_line": 859,
              "start_column": 30629,
              "end_line": 0,
              "end_column": 32474,
              "start_byte": 30629,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "neral\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to l",
              "start_line": 69,
              "start_column": 1986,
              "end_line": 0,
              "end_column": 3604,
              "start_byte": 1986,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "yping import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hooki",
              "start_line": 17,
              "start_column": 429,
              "end_line": 0,
              "end_column": 772,
              "start_byte": 429,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addop",
              "start_line": 84,
              "start_column": 2254,
              "end_line": 0,
              "end_column": 2881,
              "start_byte": 2254,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_",
              "start_line": 91,
              "start_column": 2951,
              "end_line": 0,
              "end_column": 4390,
              "start_byte": 2951,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "xtensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n",
              "start_line": 49,
              "start_column": 1338,
              "end_line": 0,
              "end_column": 1908,
              "start_byte": 1338,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "rom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom ",
              "start_line": 14,
              "start_column": 368,
              "end_line": 0,
              "end_column": 781,
              "start_byte": 368,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": " typing import final\nfrom typing import FrozenSet\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nf",
              "start_line": 11,
              "start_column": 265,
              "end_line": 0,
              "end_column": 557,
              "start_byte": 265,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import ",
              "start_line": 25,
              "start_column": 670,
              "end_line": 0,
              "end_column": 1166,
              "start_byte": 670,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "port Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcome",
              "start_line": 17,
              "start_column": 381,
              "end_line": 0,
              "end_column": 970,
              "start_byte": 381,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "icit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n\n\ndef validate_basetemp(path: str) -> str:\n    # GH 7119\n    msg = \"basetemp must not be empty, the current working directory or any parent directory of it\"\n\n    # empty path\n    if not path:\n        raise argparse.ArgumentTypeError(msg)\n\n    def is_ancestor(base: Path, query: Path) -> bool:\n        \"\"\"Return whether query is an ancestor of base.\"\"\"\n        if base == query:\n            return True\n        return query in base.parents\n\n    # check if path is an ancestor of cwd\n    if is_ancestor(Path.cwd(), Path(path).absolute()):\n        raise argparse.ArgumentT",
              "start_line": 135,
              "start_column": 3636,
              "end_line": 0,
              "end_column": 7219,
              "start_byte": 3636,
              "end_byte": 0
            },
            {
              "name": "_pytest.tmpdir.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "nterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(f\"{excinfo.typename}: {excinfo.value.msg}\\n\")\n            config.hook.py",
              "start_line": 222,
              "start_column": 8101,
              "end_line": 0,
              "end_column": 8577,
              "start_byte": 8101,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_path.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "mport argparse\nimport dataclasses\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom pathlib import Path\nfrom",
              "start_line": 7,
              "start_column": 80,
              "end_line": 0,
              "end_column": 213,
              "start_byte": 80,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": []
        },
        "symbols_evaluate": {
          "scratch_pad": "## Step 1: Analyze User Instructions\n\n1.1 **Issue Described**: The user is experiencing an issue where `core.initialize()` does not seem to have an effect due to two different versions of `pmxbot.logging` being present. One module is in `sys.modules` and another in `tests.unit.test_commands.logging`. This results in an attribute error when accessing `logging.Logger.store`.\n\n1.2 **Cause of the Issue**: This could be due to using `importlib` style importing which may lead to a module being loaded twice if `sys.path` settings or the way imports are handled across different paths are not consistent. It is likely related to the change from `pkg_resources` to `PEP 420` namespace packages which could be causing the conflict in module presence.\n\n1.3 **Expected Result**: The `pmxbot.logging.Logger.store` should be correctly initialized and accessible through `core.initialize()`, reflecting that only one consistent module is loaded.\n\n1.4 **Expectation if Not Provided**: Ensure there is only one version of the `pmxbot.logging` module present. Ensure consistent usage in tests and application runtime.\n\n1.5 **Solution Approach**: Investigate how modules are loaded. Ensure `importlib` mode is correctly handling namespace packages. Adjust pytest or import configurations to prevent dual loading.\n\n\\#\n\n## Step 2: Make the Evaluation\n\nI will look for symbols related to module import management, particularly those that could affect how a module is imported and managed in pytest.\n\n2.1+2.2 **Analyze Symbols**: Examine provided symbols to identify potential `import-mode` management or interactions with `sys.modules`.\n\n2.3 **Evaluate Relevance**: Focus on any `importlib`, `pytest` importing methods, configuration options, or sys.path handling which are pertinent to module loading.\n\n2.4 **Decision on Changes**: Determine symbols to be altered for preventing dual module loading.\n\n2.5 **Need More Information**: Determine if additional symbols or context from configuration files are necessary to conclude the initial investigation.",
          "symbols": [
            {
              "name": "_pytest.main.search_pypath",
              "file_path": "src/_pytest/main.py",
              "reason": "This function explicitly deals with searching sys.path for a module name. It could be causing multiple module loads if not correctly implemented with importlib and PEP 420 namespaces."
            },
            {
              "name": "_pytest.main.resolve_collection_argument",
              "file_path": "src/_pytest/main.py",
              "reason": "This method handles command line arguments and potentially module paths when collecting tests. Incorrect handling here might cause duplicate imports in different contexts or import-modes."
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "reason": "This may include options that manage the pytest configuration or how modules are included in tests, potentially affecting how duplicate modules appear."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "The function `search_pypath` searches `sys.path` for a module. If this search is incorrect or does not conform to PEP 420, it might cause multiple instances of a module to be loaded separately. Given the issue described, we should ensure this method handles importlib use properly and does not augment sys.path in a way that leads to separate module loads.",
            "The `resolve_collection_argument` manages modules indicated in command-line paths, resolving them, which could affect how modules are recognized in the test and runtime environments. Improper handling might allow the same module to be fetched differently in disparate parts of the system, leading to dual loading.",
            "This requires investigation for any configuration adjustments that may relate to module importing behavior, particularly when using importlib or related import settings in pytest."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/main.py"
        ],
        "symbols": [
          "_pytest.main.search_pypath",
          "_pytest.main.resolve_collection_argument",
          "_pytest.logging.pytest_addoption"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "test._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption",
            "start_line": 21,
            "start_column": 592,
            "end_line": 0,
            "end_column": 1385,
            "start_byte": 592,
            "end_byte": 0
          },
          "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path_ = path if isinstance(path, Path) else Path(path)\n        return path_ in self._initialpaths\n\n    def gethookproxy(self, fspath: \"os.PathLike[str]\"):\n        # Optimization: Path(Path(...)) is much slower than isinstance.\n        path = fspath if isinstance(fspath, Path) else Path(fspath)\n        pm = self.config.pluginmanager\n        # Check if we have the common case of running\n        # hooks with all conftest.py files.\n        my_conftestmodules = pm._getconftestmodules(\n            path,\n            self.config.getoption(\"importmode\"),\n            rootpath=self.config.rootpath,\n        )\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # One or more conftests are not in use at this fspath.\n            from .config.compat import PathAwareHookProxy\n\n            proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))\n        else:\n            # All plugins are active for this fspath.\n            proxy = self.config.hook\n        return proxy\n\n    def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        fspath = Path(direntry.path)\n        ihook = self.gethookproxy(fspath.parent)\n        if ihook.pytest_ignore_collect(collection_path=fspath, config=self.config):\n            return False\n        return True\n\n    def _collectf",
            "start_line": 453,
            "start_column": 16621,
            "end_line": 0,
            "end_column": 18400,
            "start_byte": 16621,
            "end_byte": 0
          },
          "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " _pytest.pathlib import visit\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n ",
            "start_line": 42,
            "start_column": 1108,
            "end_line": 0,
            "end_column": 1587,
            "start_byte": 1108,
            "end_byte": 0
          },
          "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "_pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[",
            "start_line": 43,
            "start_column": 1224,
            "end_line": 0,
            "end_column": 1946,
            "start_byte": 1224,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --s",
            "start_line": 68,
            "start_column": 1950,
            "end_line": 0,
            "end_column": 3384,
            "start_byte": 1950,
            "end_byte": 0
          },
          "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfr",
            "start_line": 16,
            "start_column": 326,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 326,
            "end_byte": 0
          },
          "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1371,
            "start_column": 53324,
            "end_line": 0,
            "end_column": 53528,
            "start_byte": 53324,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encoun",
            "start_line": 43,
            "start_column": 1340,
            "end_line": 0,
            "end_column": 2976,
            "start_byte": 1340,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another",
            "start_line": 80,
            "start_column": 2567,
            "end_line": 0,
            "end_column": 4122,
            "start_byte": 2567,
            "end_byte": 0
          },
          "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "self, pm: PytestPluginManager, remove_mods) -> None:\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\"Signals that the test run was interrupted.\"\"\"\n\n    __module__ = \"builtins\"  # For py3.\n\n\nclass Failed(Exception):\n    \"\"\"Signals a stop as failed test run.\"\"\"\n\n\n@dataclasses.dataclass\nclass _bestrelpath_cache(Dict[Path, str]):\n    __slots__ = (\"path\",)\n\n    path: Path\n\n    def __missing__(self, path: Path) -> str:\n        r = bestrelpath(self.path, path)\n        self[path] = r\n        return r\n\n\n@final\nclass Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager: FixtureManager\n    exitstatus: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        super().__init__(\n            path=config.rootpath,\n            fspath=None,\n            parent=None,\n            config=config,\n            session=self,\n            nodeid=\"\",\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop: Union[bool, s",
            "start_line": 381,
            "start_column": 13650,
            "end_line": 0,
            "end_column": 15025,
            "start_byte": 13650,
            "end_byte": 0
          },
          "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n            else:\n                if isinstance(excinfo.value, SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        os.chdir(session.startpath)\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(f\"{type(exc).__name__}: {exc}\\n\")\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:\n    return wrap_session(config, _main)\n\n\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\"Default command line protocol for initialization, session,\n    running tests and reporting.\"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    session.perform_collect()\n\n\ndef pytest_runtestloop(session: \"Session\") -> bool:\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path: Path) -> bool:\n    \"\"\"Attempt to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script.\"\"\"\n    bindir = path.joinpath(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    try:\n        i",
            "start_line": 237,
            "start_column": 8743,
            "end_line": 0,
            "end_column": 11544,
            "start_byte": 8743,
            "end_byte": 0
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )",
            "start_line": 49,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 6649,
            "start_byte": 1365,
            "end_byte": 0
          },
          "_pytest.main.search_pypath": {
            "name": "_pytest.main.search_pypath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def search_pypath(module_name: str) -> str:\n    \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n    try:\n        spec = importlib.util.find_spec(module_name)\n    # AttributeError: looks like package module, but actually filename\n    # ImportError: module does not exist\n    # ValueError: not a module name\n    except (AttributeError, ImportError, ValueError):\n        return module_name\n    if spec is None or spec.origin is None or spec.origin == \"namespace\":\n        return module_name\n    elif spec.submodule_search_locations:\n        return os.path.dirname(spec.origin)\n    else:\n        return spec.origin",
            "start_line": 842,
            "start_column": 29973,
            "end_line": 0,
            "end_column": 30626,
            "start_byte": 29973,
            "end_byte": 0
          },
          "_pytest.main.resolve_collection_argument": {
            "name": "_pytest.main.resolve_collection_argument",
            "file_path": "src/_pytest/main.py",
            "file_content": "def resolve_collection_argument(\n    invocation_path: Path, arg: str, *, as_pypath: bool = False\n) -> Tuple[Path, List[str]]:\n    \"\"\"Parse path arguments optionally containing selection parts and return (fspath, names).\n\n    Command-line arguments can point to files and/or directories, and optionally contain\n    parts for specific tests selection, for example:\n\n        \"pkg/tests/test_foo.py::TestClass::test_foo\"\n\n    This function ensures the path exists, and returns a tuple:\n\n        (Path(\"/full/path/to/pkg/tests/test_foo.py\"), [\"TestClass\", \"test_foo\"])\n\n    When as_pypath is True, expects that the command-line argument actually contains\n    module paths instead of file-system paths:\n\n        \"pkg.tests.test_foo::TestClass::test_foo\"\n\n    In which case we search sys.path for a matching module, and then return the *path* to the\n    found module.\n\n    If the path doesn't exist, raise UsageError.\n    If the path is a directory and selection parts are present, raise UsageError.\n    \"\"\"\n    base, squacket, rest = str(arg).partition(\"[\")\n    strpath, *parts = base.split(\"::\")\n    if parts:\n        parts[-1] = f\"{parts[-1]}{squacket}{rest}\"\n    if as_pypath:\n        strpath = search_pypath(strpath)\n    fspath = invocation_path / strpath\n    fspath = absolutepath(fspath)\n    if not fspath.exists():\n        msg = (\n            \"module or package not found: {arg} (missing __init__.py?)\"\n            if as_pypath\n            else \"file or directory not found: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    if parts and fspath.is_dir():\n        msg = (\n            \"package argument cannot contain :: selection parts: {arg}\"\n            if as_pypath\n            else \"directory argument cannot contain :: selection parts: {arg}\"\n        )\n        raise UsageError(msg.format(arg=arg))\n    return fspath, parts",
            "start_line": 859,
            "start_column": 30629,
            "end_line": 0,
            "end_column": 32474,
            "start_byte": 30629,
            "end_byte": 0
          },
          "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "neral\", \"Running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"Exit instantly on first error or failed test\",\n    )\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addoption(\n        \"--strict-config\",\n        action=\"store_true\",\n        help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to l",
            "start_line": 69,
            "start_column": 1986,
            "end_line": 0,
            "end_column": 3604,
            "start_byte": 1986,
            "end_byte": 0
          },
          "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "yping import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hooki",
            "start_line": 17,
            "start_column": 429,
            "end_line": 0,
            "end_column": 772,
            "start_byte": 429,
            "end_byte": 0
          },
          "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"Set which warnings to report, see -W option of Python itself\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"Exit after first num failures or errors\",\n    )\n    group._addop",
            "start_line": 84,
            "start_column": 2254,
            "end_line": 0,
            "end_column": 2881,
            "start_byte": 2254,
            "end_byte": 0
          },
          "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "help=\"Any warnings encountered while parsing the `pytest` section of the \"\n        \"configuration file raise errors\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        action=\"store_true\",\n        help=\"Markers not registered in the `markers` section of the configuration \"\n        \"file raise errors\",\n    )\n    group._addoption(\n        \"--strict\",\n        action=\"store_true\",\n        help=\"(Deprecated) alias to --strict-markers\",\n    )\n    group._addoption(\n        \"-c\",\n        \"--config-file\",\n        metavar=\"FILE\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"Load configuration from `FILE` instead of trying to locate one of the \"\n        \"implicit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_",
            "start_line": 91,
            "start_column": 2951,
            "end_line": 0,
            "end_column": 4390,
            "start_byte": 2951,
            "end_byte": 0
          },
          "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "xtensions import Literal\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    parser.addini(\n        \"norecursedirs\",\n        \"Directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\n            \"*.egg\",\n            \".*\",\n            \"_darcs\",\n            \"build\",\n            \"CVS\",\n            \"dist\",\n            \"node_modules\",\n            \"venv\",\n            \"{arch}\",\n        ],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"Directories to search for tests when no files or directories are given on the \"\n        \"command line\",\n",
            "start_line": 49,
            "start_column": 1338,
            "end_line": 0,
            "end_column": 1908,
            "start_byte": 1338,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom ",
            "start_line": 14,
            "start_column": 368,
            "end_line": 0,
            "end_column": 781,
            "start_byte": 368,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " typing import final\nfrom typing import FrozenSet\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nf",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 557,
            "start_byte": 265,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.pathlib import absolutepath\nfrom _pytest.pathlib import bestrelpath\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import visit\nfrom _pytest.reports import ",
            "start_line": 25,
            "start_column": 670,
            "end_line": 0,
            "end_column": 1166,
            "start_byte": 670,
            "end_byte": 0
          },
          "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port Optional\nfrom typing import overload\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcome",
            "start_line": 17,
            "start_column": 381,
            "end_line": 0,
            "end_column": 970,
            "start_byte": 381,
            "end_byte": 0
          },
          "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "icit configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"Only collect tests, don't execute them\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"Try to interpret all arguments as Python packages\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"Ignore path pattern during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"Deselect item (via node id prefix) during collection (multi-allowed)\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"Only load conftest.py's relative to specified dir\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\", \"importlib\"],\n        dest=\"importmode\",\n        help=\"Prepend/append to sys.path when importing test modules and conftest \"\n        \"files. Default: prepend.\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        type=validate_basetemp,\n        metavar=\"dir\",\n        help=(\n            \"Base temporary directory for this test run. \"\n            \"(Warning: this directory is removed if it exists.)\"\n        ),\n    )\n\n\ndef validate_basetemp(path: str) -> str:\n    # GH 7119\n    msg = \"basetemp must not be empty, the current working directory or any parent directory of it\"\n\n    # empty path\n    if not path:\n        raise argparse.ArgumentTypeError(msg)\n\n    def is_ancestor(base: Path, query: Path) -> bool:\n        \"\"\"Return whether query is an ancestor of base.\"\"\"\n        if base == query:\n            return True\n        return query in base.parents\n\n    # check if path is an ancestor of cwd\n    if is_ancestor(Path.cwd(), Path(path).absolute()):\n        raise argparse.ArgumentT",
            "start_line": 135,
            "start_column": 3636,
            "end_line": 0,
            "end_column": 7219,
            "start_byte": 3636,
            "end_byte": 0
          },
          "_pytest.tmpdir.pytest_addoption": {
            "name": "_pytest.tmpdir.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "nterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(f\"{excinfo.typename}: {excinfo.value.msg}\\n\")\n            config.hook.py",
            "start_line": 222,
            "start_column": 8101,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8101,
            "end_byte": 0
          },
          "_pytest.python_path.pytest_addoption": {
            "name": "_pytest.python_path.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "mport argparse\nimport dataclasses\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom pathlib import Path\nfrom",
            "start_line": 7,
            "start_column": 80,
            "end_line": 0,
            "end_column": 213,
            "start_byte": 80,
            "end_byte": 0
          }
        }
      }
    }
  ]
}