{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5495",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:33:50.791325",
        "usage": "1675.485372543335 ms"
      },
      "request": {
        "repo_tokens": [
          "summary_passes",
          "Cache",
          "summary_failures",
          "visit_Name",
          "fixturenames",
          "push_format_context",
          "extract_suffixes",
          "processoption",
          "fnmatch_lines",
          "LogCaptureHandler",
          "append_collect_error",
          "_read_pyc",
          "getpluginversioninfo",
          "typename",
          "cacheprovider",
          "find",
          "summary_errors",
          "_plugin_nameversions",
          "ids",
          "append_collect_skipped",
          "exit",
          "traceback",
          "_consider_importhook",
          "_validate_args",
          "delattr",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "CallInfo",
          "write_fspath_result",
          "CLOSE_STDIN",
          "cwd_relative_nodeid",
          "mkdir",
          "getpathnode",
          "obj",
          "pytest_warning_captured",
          "FunctionMixin",
          "_import_plugin_specs",
          "_given_basetemp",
          "YIELD_TESTS",
          "addSkip",
          "last_failed_paths",
          "add_global_property",
          "store_mark",
          "resultlog",
          "OutcomeException",
          "parseconfig",
          "_format_args",
          "_ensure_basetemp",
          "runpytest",
          "builtin_plugins",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "getlocals",
          "_getnextfixturedef",
          "_get_allow_unicode_flag",
          "check_interactive_exception",
          "id",
          "getitems",
          "pastebin",
          "capsys",
          "NFPlugin",
          "approx",
          "deselect_by_keyword",
          "_early_rewrite_bailout",
          "_get_increasing_order",
          "_collect",
          "safeformat",
          "_determine_show_progress_info",
          "pytest_sessionstart",
          "writeorg",
          "_translate_non_printable",
          "cleanup_numbered_dir",
          "is_rewrite_disabled",
          "_get_plugin_specs_as_list",
          "_rewrite_test",
          "_assertion_supported",
          "consider_module",
          "Failed",
          "_ensure_supporting_files",
          "pathlib",
          "terminal",
          "PytestPluginManager",
          "buffer",
          "pytest_runtest_call",
          "TEST_OUTCOME",
          "_compilecounter",
          "suspend_global_capture",
          "SysCaptureBinary",
          "get_lines_after",
          "pytest_internalerror",
          "pytestPDB",
          "runtest",
          "getrawcode",
          "__str__",
          "Exit",
          "getlocation",
          "UsageError",
          "SetupState",
          "_ensure_only_one_capture_fixture",
          "RE_IMPORT_ERROR_NAME",
          "match",
          "write_ensure_prefix",
          "_check_scope",
          "pytester",
          "_inject_setup_method_fixture",
          "_is_capturing",
          "Session",
          "activate_fixture",
          "setenv",
          "IGNORE_PAM",
          "getexplanation",
          "_call_and_format_exception",
          "pytest_report_collectionfinish",
          "classnamefilter",
          "args",
          "assign",
          "get_plugin_manager",
          "MultipleDoctestFailures",
          "showlongtestinfo",
          "ReprLocals",
          "_matchnodes",
          "get_location",
          "_bestrelpath_cache",
          "NOTSET",
          "excinfo",
          "UnitTestCase",
          "fnmatch_lines_random",
          "LsofFdLeakChecker",
          "CallSpec2",
          "_iter_rewritable_modules",
          "raises",
          "_write_progress_information_filling_space",
          "addFailure",
          "cut",
          "readlines",
          "records",
          "pytest_assertrepr_compare",
          "getcrashentry",
          "_runtest_for_main",
          "pytest_enter_pdb",
          "collect_one_node",
          "Module",
          "consider_conftest",
          "compile",
          "_config_for_test",
          "notset",
          "runpython_c",
          "pytest_pycollect_makeitem",
          "from_item",
          "frame",
          "getargs",
          "pytest_collectstart",
          "_checkversion",
          "set_when",
          "FDCapture",
          "_force_symlink",
          "countoutcomes",
          "scope",
          "CaptureIO",
          "__test__",
          "compile_",
          "_LiveLoggingStreamHandler",
          "_init_runner_class",
          "ApproxBase",
          "_reprcompare",
          "_validate_usepdb_cls",
          "pytest_collection_modifyitems",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "getfixturevalue",
          "_make_xunit_fixture",
          "isdatacls",
          "pytest_collect_directory",
          "ExceptionRepr",
          "_getconftestmodules",
          "nofuncargs",
          "re_match_lines_random",
          "_matches_prefix_or_glob_option",
          "get_common_ancestor",
          "pop_format_context",
          "scope2index",
          "pytest_report_teststatus",
          "ReprFailDoctest",
          "PytestCollectionWarning",
          "NodeMarkers",
          "_collectfile",
          "_dump_lines",
          "fix_cache_order",
          "CollectErrorRepr",
          "_for_parametrize",
          "_try_load_conftest",
          "SysModulesSnapshot",
          "rmtree",
          "SubRequest",
          "HelpAction",
          "type",
          "pytest_fixture_post_finalizer",
          "python",
          "stop_global_capturing",
          "build_summary_stats_line",
          "visit_Starred",
          "reports",
          "extract_from",
          "mktemp",
          "getreports",
          "initialnames",
          "matchnodes",
          "fileno",
          "families",
          "_format_assertmsg",
          "DEFAULT_RELATIVE_TOLERANCE",
          "isdict",
          "LogCaptureFixture",
          "fail",
          "_warn_already_imported",
          "context",
          "explanation_param",
          "mkpydir",
          "AssertionRewritingHook",
          "getoption",
          "from_call",
          "MoreQuietAction",
          "find_prefixed",
          "out",
          "_PytestWrapper",
          "listextrakeywords",
          "RemovedInPytest4Warning",
          "getstatement",
          "template",
          "pytest_logwarning",
          "get_records",
          "maybe_delete_a_numbered_dir",
          "_getscopeitem",
          "popen",
          "pytest_collect_file",
          "conftest_options",
          "getfixtureclosure",
          "readline",
          "Interrupted",
          "TracebackEntry",
          "pytest_runtest_protocol",
          "record_tuples",
          "istrue",
          "_teardown_towards",
          "summary_warnings",
          "_seen",
          "write_captured_output",
          "location",
          "_cachedir",
          "_resolve_arg_value_types",
          "done",
          "MarkMapping",
          "post_mortem",
          "pytest_deselected",
          "__version__",
          "_approx_scalar",
          "NodeKeywords",
          "__setitem__",
          "skip",
          "_add_simple",
          "cached_eval",
          "_is_marked_for_rewrite",
          "for_later",
          "_update_current_test_var",
          "record_xml_attribute",
          "SysCapture",
          "resolve_from_str",
          "PytestAssertRewriteWarning",
          "print_teardown_sections",
          "append_error",
          "_truncate_explanation",
          "writelines",
          "funcargnames",
          "_folded_skips",
          "statement",
          "USAGE_ERROR",
          "start_capturing",
          "list",
          "pytest_plugin_registered",
          "line",
          "helpconfig",
          "MarkEvaluator",
          "re_match_lines",
          "_ALLOW_MARKERS",
          "close",
          "PytestConfigWarning",
          "format",
          "_do_configure",
          "get_open_files",
          "call_runtest_hook",
          "node_reporter",
          "_get_stderr_fileno",
          "pytest_generate_tests",
          "_py_ext_re",
          "compat",
          "_getentrysource",
          "doctest",
          "rex_outcome",
          "_tmppath_factory",
          "Function",
          "get_parametrized_fixture_keys",
          "tmpdir_factory",
          "exec_module",
          "PyobjMixin",
          "_getcrashline",
          "ReprExceptionInfo",
          "determine_setup",
          "caplog",
          "visit_Assert",
          "pytest_make_collect_report",
          "isparseable",
          "pytest_keyboard_interrupt",
          "getfuncargvalue",
          "patchsysdict",
          "syspathinsert",
          "scopes",
          "get_user",
          "parse_setoption",
          "BaseReport",
          "warning_record_to_str",
          "_getvaluepath",
          "_main",
          "simple",
          "File",
          "CwdSnapshot",
          "visit_BinOp",
          "Junit",
          "HookRecorder",
          "LineMatcher",
          "pytest_collection",
          "_setoption",
          "pytest_runtestloop",
          "_show_fixtures_per_test",
          "repr_instance",
          "show_test_item",
          "get_source",
          "getsource",
          "parse_known_and_unknown_args",
          "function",
          "_get_runner",
          "cleanup_candidates",
          "makefile",
          "setitem",
          "ApproxScalar",
          "start",
          "MODULE_NOT_FOUND_ERROR",
          "capture",
          "add_funcarg_pseudo_fixture_def",
          "_get_verbose_word",
          "_create_formatter",
          "set_session",
          "get_lock_path",
          "eval",
          "_version",
          "_start",
          "_typ_map",
          "_ensure_unconfigure",
          "__version_tuple__",
          "chdir",
          "_update_message",
          "_node_location_to_relpath",
          "runner",
          "readouterr",
          "_postmortem_traceback",
          "node",
          "_initini",
          "teardown_exact",
          "get_default_arg_names",
          "junitxml",
          "illegal_xml_re",
          "cls",
          "repr_args",
          "spawn",
          "ReprEntry",
          "_exec_lsof",
          "Instance",
          "ReprEntryNative",
          "keywords",
          "STRING_TYPES",
          "_report_unserialization_failure",
          "_outrep_summary",
          "_recursive_debug",
          "module",
          "ReprTraceback",
          "source",
          "resolve_fixture_function",
          "PyobjContext",
          "pytest_report_from_serializable",
          "pop_outerr_to_orig",
          "_log",
          "_showfixtures_main",
          "Class",
          "wrap_function_to_error_out_if_called_directly",
          "DEFAULT_MAX_LINES",
          "LEVELNAME_FMT_REGEX",
          "consider_preparse",
          "to_xml",
          "_pytest",
          "PytestExperimentalApiWarning",
          "__call__",
          "__nonzero__",
          "handler",
          "_truncate_recursive_traceback",
          "_repr_style",
          "update",
          "_width_of_current_line",
          "ensure_deletable",
          "applymarker",
          "_find_spec",
          "_PLUGGY_DIR",
          "_pyfuncitem",
          "USAGE_MSG",
          "python_api",
          "repr_unicode",
          "_compare_eq_verbose",
          "prepare",
          "_import_pdb_cls",
          "TempdirFactory",
          "formatrepr",
          "assert_contains",
          "XFailed",
          "summary_stats",
          "_callfinalizers",
          "errors",
          "head_line",
          "idmaker",
          "_inject_setup_class_fixture",
          "set_repr_style",
          "_parsearg",
          "_ANSI_ESCAPE_SEQ",
          "_getindent",
          "iter_markers_with_node",
          "display",
          "_callhelper",
          "Node",
          "_printcollecteditems",
          "pytest_runtest_logstart",
          "add_property",
          "MarkDecorator",
          "showlocals",
          "_sys_snapshot",
          "register_assert_rewrite",
          "warning_types",
          "faulthandler",
          "directory_arg",
          "Package",
          "consider_env",
          "WARNS_EXEC",
          "get_fslocation_from_item",
          "_strtobool",
          "rewrite",
          "showheader",
          "_get_override_ini_value",
          "__repr__",
          "getini",
          "_inject_setup_function_fixture",
          "helper",
          "istestfunction",
          "deactivate_fixture",
          "parse",
          "_running_on_ci",
          "_basetemp",
          "FastFilesCompleter",
          "showversion",
          "gethookproxy",
          "indent",
          "__getitem__",
          "get_empty_parameterset_mark",
          "log_outcome",
          "EncodedFile",
          "ihook",
          "prune_dependency_tree",
          "_importtestmodule",
          "_get_checker",
          "warn_about_none_ast",
          "_match_lines_random",
          "get_optionflags",
          "LogXML",
          "Skipped",
          "_compare_eq_set",
          "_should_repr_global_name",
          "pytest_exception_interact",
          "TestReport",
          "_init_pdb",
          "_ConfigDeprecated",
          "MultiCapture",
          "yield_fixture",
          "_resolve_arg_ids",
          "kwargs",
          "nodeid",
          "TestCaseFunction",
          "get_exconly",
          "_preparse",
          "_mark_plugins_for_rewrite",
          "UnformattedWarning",
          "visit_Compare",
          "getfslineno",
          "reorder_items",
          "message",
          "__init__",
          "_issue_warning_captured",
          "visit_UnaryOp",
          "_is_numpy_array",
          "normalize_mark_list",
          "CFG_PYTEST_SECTION",
          "when",
          "_yield_comparisons",
          "_install_capture_fixture_on_item",
          "isatty",
          "catch_warnings_for_item",
          "OK",
          "params",
          "_check_type",
          "ApproxMapping",
          "Source",
          "pytest_addoption",
          "parse_args",
          "listchain",
          "get",
          "NoCapture",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "__all__",
          "listnames",
          "_finalize",
          "safe_text_dupfile",
          "PYC_TAIL",
          "append",
          "hasopt",
          "getstatementrange_ast",
          "assert_contains_lines",
          "_set_opt_strings",
          "pytest_pycollect_makemodule",
          "_genfunctions",
          "Config",
          "_readline_workaround",
          "pyobj_property",
          "from_current",
          "bin_xml_escape",
          "tmp_path_factory",
          "_getpytestargs",
          "get_closest_marker",
          "NO_TESTS_COLLECTED",
          "REPORT_COLLECTING_RESOLUTION",
          "__delitem__",
          "get_real_func",
          "SysPathsSnapshot",
          "_write_pyc",
          "_is_mocked",
          "_get_xunit_setup_teardown",
          "funcargs",
          "RaisesContext",
          "matchreport",
          "set_location",
          "essential_plugins",
          "parsefactories",
          "_should_rewrite",
          "prog",
          "update_testcase_duration",
          "DEFAULT_LOG_DATE_FORMAT",
          "linecomp",
          "pytest_collectreport",
          "mark_rewrite",
          "unittest",
          "FILE_OR_DIR",
          "_getparser",
          "_call_with_optional_argument",
          "generic_visit",
          "_getfailureheadline",
          "skipped",
          "CaptureResult",
          "capfdbinary",
          "abspath",
          "register_cleanup_lock_removal",
          "find_spec",
          "EMPTY_BUFFER",
          "pytest_itemstart",
          "FIXTURE_FUNCTION_CALL",
          "DOCTEST_REPORT_CHOICES",
          "addSuccess",
          "istext",
          "safe_getattr",
          "get_scope_node",
          "addError",
          "AssertionState",
          "raiseerror",
          "assertoutcome",
          "pytest_pyfunc_call",
          "ishidden",
          "_show_fixture_action",
          "NoMatch",
          "getmodulecol",
          "_getglobals",
          "_perform_collect",
          "getreportopt",
          "DummyRewriteHook",
          "_check_all_skipped",
          "cacheshow",
          "pytest_configure",
          "copy_example",
          "_check_initialpaths_for_relpath",
          "_recurse",
          "WarningsRecorder",
          "xfail",
          "_getini",
          "_runtest_for",
          "logging",
          "_pop_and_teardown",
          "warn",
          "run",
          "hookspec",
          "Item",
          "report_collect",
          "spawn_pytest",
          "messages",
          "setall",
          "name2fixturedefs",
          "fslocation",
          "_state",
          "ExitCode",
          "astcache",
          "addoption",
          "reportinfo",
          "finish_recording",
          "repr",
          "ReprTracebackNative",
          "inline_runsource",
          "fromdictargs",
          "_get_direct_parametrize_args",
          "check_strict_xfail",
          "cmdline",
          "unary_map",
          "annotated_getattr",
          "get_unpacked_marks",
          "runpytest_inprocess",
          "capstdout",
          "_resume",
          "getfixturedefs",
          "__array_ufunc__",
          "setupplan",
          "strip",
          "start_global_capturing",
          "PYTEST_ENSURETEMP",
          "pytest_leave_pdb",
          "_markers",
          "getparent",
          "_idval",
          "PYTESTER_COPY_EXAMPLE",
          "FIXTURE_NAMED_REQUEST",
          "Traceback",
          "issequence",
          "safe_isclass",
          "deselect_by_mark",
          "get_scope_package",
          "GETFUNCARGVALUE",
          "scope2props",
          "ensure_reset_dir",
          "MarkGenerator",
          "ApproxSequencelike",
          "ExceptionChainRepr",
          "exconly",
          "SHOW_PYTEST_WARNINGS_ARG",
          "pytest_terminal_summary",
          "wrap_session",
          "LOGLEVEL_COLOROPTS",
          "delenv",
          "finish",
          "_in_venv",
          "collect_by_name",
          "repr_traceback",
          "getplugin",
          "showfixtures",
          "config",
          "getinicfg",
          "_get_pdb_wrapper_class",
          "binop_map",
          "add_cleanup",
          "assert_outcomes",
          "_colorama_workaround",
          "cached_result",
          "builtin",
          "warns",
          "addExpectedFailure",
          "_truncate_by_char_count",
          "record_property",
          "TimeoutExpired",
          "__enter__",
          "_idvalset",
          "newinstance",
          "getparam",
          "PrintHelp",
          "_makepath",
          "rewrite_asserts",
          "ensuretemp",
          "fillfixtures",
          "INTERRUPTED",
          "visit_Call",
          "DoctestTextfile",
          "showfspath",
          "recursionindex",
          "consider_pluginarg",
          "_parse_parametrize_parameters",
          "make_numbered_dir",
          "deprecated_call",
          "filter",
          "_saferepr",
          "_inject_setup_teardown_fixtures",
          "version_tuple",
          "defaultfuncargprefixmarker",
          "toterminal",
          "global_and_fixture_disabled",
          "repr_excinfo",
          "execute",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "create_module",
          "getfirstlinesource",
          "DEFAULT_MAX_CHARS",
          "inline_genitems",
          "DontReadFromInput",
          "write",
          "addsection",
          "pytest_unconfigure",
          "FixtureRequest",
          "findsource",
          "runpytest_subprocess",
          "delitem",
          "param",
          "_getlines",
          "getnode",
          "_PY_DIR",
          "with_args",
          "truncate_locals",
          "make_hook_recorder",
          "_factorytraceback",
          "PdbInvoke",
          "_rget_with_confmod",
          "exprinfo",
          "_test_pytest_function",
          "RunResult",
          "FixtureLookupError",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "visit_Attribute",
          "_bytes_to_ascii",
          "markname",
          "_getautousenames",
          "getdecoded",
          "_legal_xml_re",
          "skipping",
          "is_globally_capturing",
          "_non_printable_ascii_translate_table",
          "PYTEST_TAG",
          "isnosetest",
          "find_suffixes",
          "copy",
          "pytest_addhooks",
          "make_properties_node",
          "CaptureFixture",
          "_py36_windowsconsoleio_workaround",
          "_code",
          "create_cleanup_lock",
          "write_line",
          "pytest_cmdline_main",
          "teardown_all",
          "LOCK_TIMEOUT",
          "_result",
          "_compare_eq_cls",
          "repr_traceback_entry",
          "_write_report_lines_from_hooks",
          "isinitpath",
          "_addfinalizer",
          "fspath",
          "set_level",
          "PytestArg",
          "collect",
          "_validate_if_using_arg_names",
          "is_generator",
          "PyCollector",
          "ReprFileLocation",
          "filename_arg",
          "SEP",
          "getfuncargnames",
          "call_optional",
          "get_statement_startend2",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "get_option_ini",
          "is_capturing",
          "from_item_and_call",
          "_striptext",
          "addUnexpectedSuccess",
          "resolve",
          "pytest_report_to_serializable",
          "ResultLog",
          "pytest_runtest_setup",
          "isset",
          "getrepr",
          "PytestUnhandledCoroutineWarning",
          "version",
          "_getobj",
          "FixtureManager",
          "PytestCacheWarning",
          "_compare_eq_sequence",
          "scopename2class",
          "RAISES_EXEC",
          "_NodeReporter",
          "teardown_nose",
          "finalize",
          "runpython",
          "setuponly",
          "deprecated",
          "resume_global_capture",
          "scopeproperty",
          "REGEX_TYPE",
          "ensure_newline",
          "__take_sys_modules_snapshot",
          "import_plugin",
          "getcalls",
          "is_true",
          "makeini",
          "setup",
          "_parse_lsof_output",
          "getfixturemarker",
          "_argcomplete",
          "pytest_runtest_logfinish",
          "tmp_path",
          "addinivalue_line",
          "addfinalizer",
          "_find_parametrized_scope",
          "MARK_GEN",
          "write_log_entry",
          "_disable_output_capturing_for_darwin",
          "encoding",
          "setmulti2",
          "__hash__",
          "create_terminal_writer",
          "_iter_all_modules",
          "getvalueorskip",
          "RESULT_LOG",
          "TYPE_CHECKING",
          "filter_traceback",
          "getfailedcollections",
          "Frame",
          "for_config",
          "resume_fixture",
          "_wrapped_pdb_cls",
          "DEFAULT_LOG_FORMAT",
          "parametrize",
          "ReprFuncArgs",
          "_compare_eq_dict",
          "teardown",
          "__ne__",
          "listoutcomes",
          "_get_report_choice",
          "ParsedCall",
          "_locationline",
          "passed",
          "MonkeyPatch",
          "register",
          "FuncFixtureInfo",
          "AssertionRewriter",
          "tbfilter",
          "install_importhook",
          "parseconfigure",
          "_addexcinfo",
          "__array_priority__",
          "saferepr",
          "getmodpath",
          "stopTest",
          "read",
          "__next__",
          "showhelp",
          "getcfg",
          "runitem",
          "pytest_ignore_collect",
          "FuncargnamesCompatAttr",
          "gethookrecorder",
          "verbosity",
          "longreprtext",
          "mode",
          "append_pass",
          "is_potential_nosetest",
          "perform_collect",
          "FixtureFunctionMarker",
          "_notin_text",
          "capture_fixtures",
          "_prepareconfig",
          "try_cleanup",
          "mangle_test_address",
          "PYTEST_LOGWARNING",
          "_format_boolop",
          "PytestDeprecationWarning",
          "pytest_cmdline_parse",
          "_assert_start_repr",
          "monkeypatch",
          "_format_action_invocation",
          "set_trace",
          "argnames",
          "_log_text",
          "CollectReport",
          "WarningReport",
          "getimfunc",
          "add_stats",
          "FunctionDefinition",
          "_warn_about_missing_assertion",
          "genitems",
          "stop_capturing",
          "reorder_items_atscope",
          "section",
          "autouse",
          "_excinfo",
          "parseoutcomes",
          "matchmark",
          "_handle_skip",
          "relline",
          "pytest_sessionfinish",
          "Mark",
          "ischildnode",
          "_diff_text",
          "parse_num",
          "exec_",
          "_should_truncate_item",
          "main",
          "matchkeyword",
          "fail_marker",
          "read_global_capture",
          "FDCaptureBinary",
          "get_terminal_writer",
          "get_sections",
          "hasplugin",
          "_processopt",
          "pytest_doctest_prepare_content",
          "names_closure",
          "_parse_parametrize_args",
          "ApproxNumpy",
          "truncate_if_required",
          "__bool__",
          "_recursive_list_map",
          "style",
          "_get_pos",
          "write_sep",
          "repr_locals",
          "notify_exception",
          "DOCTEST_REPORT_CHOICE_NONE",
          "recwarn",
          "path",
          "_get_continue_on_failure",
          "__eq__",
          "scopemismatch",
          "resume_capturing",
          "nextitem",
          "_traceback",
          "parts",
          "INTERNAL_ERROR",
          "add_report_section",
          "getcall",
          "set_log_path",
          "Entry",
          "README_CONTENT",
          "fail_fixturefunc",
          "pop",
          "item_capture",
          "_teardown_yield_fixture",
          "_makeitem",
          "isiterable",
          "Testdir",
          "names",
          "_get_active_fixturedef",
          "__len__",
          "call_fixture_func",
          "addini",
          "pytest_report_header",
          "_checkargnotcontained",
          "DoctestModule",
          "name",
          "getgroup",
          "_get_allow_bytes_flag",
          "make_numbered_dir_with_cleanup",
          "alias",
          "mark",
          "startTest",
          "CaptureManager",
          "suspend_fixture",
          "suspend_capturing",
          "get_data",
          "add_marker",
          "_format_lines",
          "_addoption",
          "popcall",
          "_warn_incompatibility_with_xunit2",
          "wasvalid",
          "PYC_EXT",
          "tmpdir",
          "nose",
          "tb",
          "FixtureDef",
          "write_docstring",
          "istestclass",
          "session",
          "PdbTrace",
          "_makefile",
          "_io",
          "_compute_fixture_value",
          "_pluginmanager",
          "_importconftest",
          "debugging",
          "DropShorterLongHelpFormatter",
          "append_failure",
          "importorskip",
          "testdir",
          "getslaveinfoline",
          "RAISES_MESSAGE_PARAMETER",
          "deindent",
          "_setup_cli_logging",
          "pytest_collection_finish",
          "funcnamefilter",
          "pytest_load_initial_conftests",
          "undo",
          "SafeRepr",
          "pytest_cmdline_preparse",
          "_get_progress_information_message",
          "getstatementrange",
          "repr_failure",
          "default_plugins",
          "_setup_collect_fakemodule",
          "_istrue",
          "_remove_ansi_escape_sequences",
          "from_config",
          "_schedule_finalizers",
          "setattr",
          "hasinit",
          "_getconftest_pathlist",
          "hookimpl",
          "nodes",
          "_initrequest",
          "_legal_chars",
          "FixtureLookupErrorRepr",
          "check_xfail_no_run",
          "parse_hookimpl_opts",
          "flow_marker",
          "tracebackcutdir",
          "OptionGroup",
          "reset",
          "_testcase",
          "FSCollector",
          "LFPlugin",
          "_repr_failure_py",
          "hasnew",
          "own_markers",
          "format_explanation",
          "visit_BoolOp",
          "getitem",
          "cache_dir_from_config",
          "capstderr",
          "get_dirs_from_args",
          "_set_initial_conftests",
          "_split_explanation",
          "_suspend",
          "iter_markers",
          "_get_fixturestack",
          "disabled",
          "chain",
          "capsysbinary",
          "syspath_prepend",
          "getfailures",
          "inline_run",
          "_report_keyboardinterrupt",
          "TerminalRepr",
          "path_matches_patterns",
          "snap",
          "_mk_tmp",
          "FormattedExcinfo",
          "record_testreport",
          "warnings",
          "PseudoFixtureDef",
          "matching_platform",
          "pytest_itemcollected",
          "stepwise",
          "record_testsuite_property",
          "TerminalReporter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "ArgumentError",
          "_legal_ranges",
          "call_and_report",
          "_addoption_instance",
          "freeze_support",
          "KeywordMapping",
          "_config",
          "_get_line_with_reprcrash_message",
          "_inject_setup_module_fixture",
          "fnmatch_ex",
          "variable",
          "get_real_method",
          "CollectError",
          "Code",
          "_to_json",
          "LoggingPlugin",
          "ColoredLevelFormatter",
          "Collector",
          "merge_family",
          "_getcapture",
          "scopenum_function",
          "__setattr__",
          "PYTEST_CONFIG_GLOBAL",
          "suspend",
          "PercentStyleMultiline",
          "restore",
          "_opentestcase",
          "doctest_namespace",
          "append_skipped",
          "WarningsChecker",
          "StepwisePlugin",
          "get_actual_log_level",
          "_setup_fixtures",
          "pytest_runtest_makereport",
          "get_public_names",
          "get_config",
          "LineMatcher_fixture",
          "ParameterSet",
          "DoctestItem",
          "locals",
          "_get_non_fixture_func",
          "instance",
          "_tryconvertpyarg",
          "_log_cli_enabled",
          "catching_logs",
          "CACHEDIR_TAG_CONTENT",
          "_get_flag_lookup",
          "resume",
          "tolerance",
          "_get_marks",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "__iter__",
          "__getattr__",
          "_enter_pdb",
          "__exit__",
          "co_equal",
          "Metafunc",
          "PytestUnknownMarkWarning",
          "BASE_TYPE",
          "set",
          "entrysep",
          "errisinstance",
          "_patch_unwrap_mock_aware",
          "invalidraise",
          "setns",
          "_getreprcrash",
          "_splitnode",
          "result",
          "pytest_runtest_logreport",
          "Parser",
          "istestfunc",
          "outcomes",
          "iscoroutinefunction",
          "combined_with",
          "fixtures",
          "fullsource",
          "_from_json",
          "get_skip_exceptions",
          "LineComp",
          "at_level",
          "assertrepr_compare",
          "show_fixtures_per_test",
          "failed",
          "EMPTY_PARAMETERSET_OPTION",
          "_call_reprcompare",
          "MyOptionParser",
          "TempPathFactory",
          "getbasetemp",
          "clear",
          "__module__",
          "_teardown_with_finalization",
          "value",
          "error",
          "pytest_make_parametrize_id",
          "ApproxDecimal",
          "putaround",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "_ascii_escaped_by_config",
          "_prunetraceback",
          "ExceptionInfo",
          "emit",
          "RUNNER_CLASS",
          "pytest_fixture_setup",
          "_match_lines",
          "count_towards_summary",
          "isattrs",
          "Notset",
          "maketxtfile",
          "parse_known_args",
          "makeconftest",
          "derive_importpath",
          "str",
          "_PYTEST_DIR",
          "num_mock_patch_args",
          "stop",
          "exists",
          "runtestprotocol",
          "category",
          "pytestconfig",
          "_fillfixtures",
          "fixture",
          "check_testcase_implements_trial_reporter",
          "ascii_escaped",
          "add_attribute",
          "TESTS_FAILED",
          "_visit_filter",
          "getvalue",
          "_get_global_properties_node",
          "FSHookProxy",
          "_is_setup_py",
          "_matchfactories",
          "freeze_includes",
          "own_mark_names",
          "create_new_paste",
          "text",
          "pytest_runtest_teardown",
          "parse_hookspec_opts",
          "PytestWarning",
          "_trace",
          "__missing__",
          "short_test_summary",
          "_ensure_immutable_ids",
          "ConftestImportFailure",
          "get_direct_param_fixture_func",
          "_saved",
          "Argument",
          "capfd",
          "makedir",
          "_non_numeric_type_error",
          "cache",
          "_ensure_removed_sysmodule",
          "getfixtureinfo",
          "_check_record_param_type",
          "assertion",
          "attrs",
          "_is_doctest",
          "_compare_eq_iterable",
          "python_keywords_allowed_list",
          "makepyfile"
        ]
      },
      "response": {
        "keywords": [
          "AssertionRewritingHook",
          "assertion",
          "visit_Assert",
          "rewrite_asserts",
          "getexplanation",
          "PytestAssertRewriteWarning",
          "AssertionState",
          "assertrepr_compare",
          "assertoutcome",
          "_warn_about_missing_assertion"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:33:52.466827",
        "usage": "227.64015197753906 ms"
      },
      "request": {
        "tokens": [
          "AssertionRewritingHook",
          "assertion",
          "visit_Assert",
          "rewrite_asserts",
          "getexplanation",
          "PytestAssertRewriteWarning",
          "AssertionState",
          "assertrepr_compare",
          "assertoutcome",
          "_warn_about_missing_assertion"
        ]
      },
      "response": {
        "results": {
          "PytestAssertRewriteWarning": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/warning_types.py",
            "src/pytest.py"
          ],
          "assertion": [
            "src/_pytest/assertion/rewrite.py",
            "src/pytest.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/freeze_support.py"
          ],
          "AssertionRewritingHook": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py"
          ],
          "_warn_about_missing_assertion": [
            "src/_pytest/config/__init__.py"
          ],
          "getexplanation": [
            "src/_pytest/skipping.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "assertoutcome": [
            "src/_pytest/pytester.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/util.py"
          ],
          "AssertionState": [
            "src/_pytest/assertion/__init__.py"
          ],
          "rewrite_asserts": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "visit_Assert": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:33:52.694478",
        "usage": "7788.2399559021 ms"
      },
      "request": {
        "keyword_search_results": {
          "PytestAssertRewriteWarning": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/warning_types.py",
            "src/pytest.py"
          ],
          "assertion": [
            "src/_pytest/assertion/rewrite.py",
            "src/pytest.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/freeze_support.py"
          ],
          "AssertionRewritingHook": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py"
          ],
          "_warn_about_missing_assertion": [
            "src/_pytest/config/__init__.py"
          ],
          "getexplanation": [
            "src/_pytest/skipping.py",
            "src/_pytest/mark/evaluate.py"
          ],
          "assertoutcome": [
            "src/_pytest/pytester.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/util.py"
          ],
          "AssertionState": [
            "src/_pytest/assertion/__init__.py"
          ],
          "rewrite_asserts": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "visit_Assert": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is about assertion rewriting messages being confusing when byte strings are involved.\n\n1. **Understanding the Issue:**\n   - The problem is specifically about how the assertion rewriting mechanisms provide feedback when comparing byte strings.\n   - The example shows an assertion failure state, and the feedback includes ASCII codes (\"52\" and \"49\") rather than explicitly stating differences in terms of the actual string representation or intended comparison.\n\n2. **Identifying Keywords:**\n   - Based on the issue description, keywords of importance likely include \"assertion\" and \"rewrite\" as the problem centers around assertion messages.\n   - \"PytestAssertRewriteWarning\", \"AssertionRewritingHook\", and \"rewrite_asserts\", all related to assertion rewriting mechanisms, may also be relevant.\n\n3. **Relevant Files Identification:**\n   - Files involved in handling assertion rewriting should contain code dealing with the formatting or expression of final assertion messages.\n\n   Considering the search results, the most relevant files might be:\n   - **src/_pytest/assertion/rewrite.py**: Appears multiple times in association with assertion rewriting. It is most likely the core module dealing with the transformation or interpretation of assertion code in the context of pytest.\n   - **src/_pytest/assertion/__init__.py**: Involved in assertion handling, likely initializes or configures key aspects of assertion mechanics.\n   - **src/_pytest/assertion/util.py**: Could provide utility functions or formatting tools/utilities for assertion outputs.\n   - **src/_pytest/assertion/truncate.py**: While more speculative, this could be involved with shortening or formatting messages which might affect clarity in rewriting outputs.\n\n4. **Conclusion:**\n   - The main focus will be on files directly dealing with assertion rewriting, specifically any function or method impacting how assertion failures (particularly with byte strings) are displayed.\n   \nTherefore, I will select files most directly related to assertion rewriting and interpretation.",
        "file_paths": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/__init__.py",
          "src/_pytest/assertion/util.py",
          "src/_pytest/assertion/truncate.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:00.482735",
        "usage": "10388.494729995728 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/rewrite.py"
      },
      "response": {
        "scratch_pad": "### Analyzing the Reported Issue\nThe reported issue concerns the assertion rewriting message in pytest when dealing with byte string comparisons. The error message produced is somewhat misleading because it gives the ASCII ordinal of the first differing character, which is not immediately clear to the user. Instead of understanding the byte string representation and its differences, it quickly shows the ASCII value of the mismatched characters, such as 52 for \"4\" and 49 for \"1\".\n\n1.1 The user experiences confusion when asserting byte strings with pytest, specifically when the byte string does not match expected values.\n1.2 The user illustrates their concern using a test code snippet that asserts two byte strings against each other, highlighting the difference in the error message produced.\n1.3 The issue seems to arise from how pytest reformats and reports assertion failures for byte strings using under-the-hood assertion rewriting logic.\n1.4 The expectation is a clearer message explaining the logical rationale of the byte string comparison instead of an ASCII representation.\n1.5 The confusion stems primarily from the interpretation of differences as ASCII ordinals.\n1.6 Suggestions for solutions:\n- Modify error message to display hexadecimal or escaped characters rather than ASCII ordinals.\n- Provide explicit bytes difference in output.\n\n### Evaluating the File Content\nThe file `src/_pytest/assertion/rewrite.py` deals mainly with assertion rewriting, which is highly relevant to the reported issue.\n\n2.1 The file rewrites assertions for detailed messages, which aligns with the user's confusion about assertion outputs.\n2.2 The class `AssertionRewriter` along with its method `visit_Compare` is central to the handling and rewriting of assert comparisons, potentially including byte strings.\n2.3 The method `_call_reprcompare` is responsible for invoking a custom comparison over assertion expressions, which might contribute to generating confusing messages.\n2.4 The method `rewrite_asserts` is used to rewrite assert statements containing explanation about variable differences. \n2.5 Methods like `_saferepr` may contribute to the representation logic of different types including bytes, which can influence message output.\n2.6 This file likely isn't the sole root cause but a part of how assertion messages get formatted and rewritten. However, it plays a significant role in translating assertions, thus carrying potential for adjusting message clarity.\n\n### Conclusion\nThe file `rewrite.py` is indeed relevant because it hosts code responsible for transforming assertions into more informative messages, including via `AssertionRewriter`. Specifically, the handling of comparative asserts, operation maps, and representation formats align with where changes would make sense for improving clarity on byte string comparisons.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "AssertionRewritingHook#",
          "AssertionRewriter#",
          "AssertionRewriter.run",
          "AssertionRewriter.visit_Assert",
          "AssertionRewriter.visit_Compare",
          "_call_reprcompare"
        ],
        "root_cause_symbols": [
          "AssertionRewritingHook#",
          "AssertionRewriter#",
          "AssertionRewriter.run",
          "AssertionRewriter.visit_Assert",
          "AssertionRewriter.visit_Compare",
          "_call_reprcompare"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:10.871246",
        "usage": "8026.6218185424805 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/__init__.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue:**\n   - The issue describes confusion caused by assertion rewriting when comparing byte strings in Pytest. The error message shows ASCII ordinal instead of the actual byte difference, which is misleading to the users; Python is comparing byte strings and rather than showing straightforward information about the difference, it shows ASCII of individual differing characters first found.\n\n2. **Steps given:**\n   - Two examples of assert statements between two byte strings are provided where the error message is misleading.\n\n3. **Cause of Issue:**\n   - The root cause is related to how assertion rewriting interprets byte strings for display. It seems that the rewrite mechanism provides additional information (ASCII ordinal at first different character position) which might not be intuitive directly during debugging.\n\n4. **User expectation:**\n   - Users expect the assert error message in a more human-readable format, particularly outlining what made the byte strings different in a straightforward manner without ASCII ordinal information.\n\n5. **Possible Solutions:**\n   - Update the rewrite logic to skip or customize the reporting format for byte strings to make the error message more human-friendly.\n   - Customize the behavior for byte strings specifically in the assert-repr comparison to give a clearer difference without character ordinals.\n\n### Analysis of Provided File:\n1. **File Purpose and Context:**\n   - The file is part of assertion handling and rewriting in Pytest.\n   - It contains code related to assertion option setup, state management, and hooks for rewriting logic.\n\n2. **Relevant Code Areas:**\n   - `pytest_runtest_setup(item)` function seems relevant as it sets up the custom compare logic for test assertions, utilizing `util._reprcompare` with `callbinrepr`.\n   - This function deals with explaining assertion failures, likely impacting byte string representation.\n   \n3. **Root Cause Decision:**\n   - This file seems related as it handles setup for assertion comparison representation, affecting how byte comparison differences are shown but may not be the root where comparison and formatting happen distinctly. Further inspection of where the `util._reprcompare` function or equivalent comparison logic/how byte strings are handled in `util` library is needed.\n\n4. **Symbols of Interest:**\n   - `pytest_runtest_setup` is crucial as it influences assertion representation for tests.\n   - `util._reprcompare` and its setter indicate points where the rewriting behavior sets up deeper representation logic in assertions.\n\nOverall, the file is relevant and could be part of the root cause chain, but it would likely need investigation into deeper utility methods/functions within Pytest's assertion handling logic.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/util.py"
        ],
        "relevant_symbols": [
          "pytest_runtest_setup",
          "util._reprcompare"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:18.897883",
        "usage": "6510.203123092651 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/util.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is about confusing assertion failure messages in pytest when comparing byte strings. Specifically, the messages indicate differences using ASCII values but provide little context or clarity to the user.\n1.2 The provided examples show assertions between byte strings failing, pointing out the ASCII ordinal (e.g., 49 for '1') but not making it intuitive.\n1.3 The issue arises from how the comparison explanation is generated for byte strings, leading to confusion.\n1.4 The user's expectation is more human-readable and understandable assertion error messages, especially when dealing with byte string differences.\n1.5 A solution might involve improving the explanation generation logic for byte strings to display differences in a more understandable manner, perhaps using character representation rather than ASCII values.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/assertion/util.py` provides utility functions for comparisons and assertion messaging.\n2.2 The function `assertrepr_compare` is particularly relevant as it's responsible for creating explanations for comparison failures including textual ones.\n2.3 Another relevant function is `_diff_text`, which generates diff explanations and handles byte-string comparisons, which aligns with the issue.\n2.4 The `escape_for_readable_diff` within `_diff_text` might be where ASCII conversion happens, leading to the issue described.\n2.5 These functions seem relevant to the reported issue, as they deal with assertion message generation and could be causing the described confusion.\n2.6 The file is likely either the root cause or very close to it. Further investigation into the specific handling of byte strings in these functions is necessary.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "assertrepr_compare",
          "_diff_text",
          "escape_for_readable_diff"
        ],
        "root_cause_symbols": [
          "assertrepr_compare",
          "_diff_text",
          "escape_for_readable_diff"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:25.408103",
        "usage": "5009.911060333252 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/truncate.py"
      },
      "response": {
        "scratch_pad": "1. The issue describes a confusion in the assertion rewriting message when comparing byte strings in Python. The message includes ASCII ordinal numbers (like 52 instead of characters \"4\"), which is not immediately clear to all users.\n\n2. The provided examples highlight that the message indicates the first extra item using its ASCII value instead of character representation.\n\n3. This issue might arise because the current implementation formats the assertion difference messages by showing ASCII values when bytes are involved, which might not be intuitive for all users understanding the message.\n\n4. The user's expected behavior seems to be more straightforward representation of differences in byte strings, perhaps with characters rather than ASCII values, making it easier to understand which characters differ.\n\n5. The code in 'src/_pytest/assertion/truncate.py' deals with truncation of the explanation messages but doesn't seem directly related to how byte string differences are presented in error messages. This file handles the length of messages and whether they should be truncated on CI systems or not based on verbosity settings. There is no indication that it formats or influences how each line of the assertion message is generated, particularly with regards to ASCII representation.\n\n6. The current file appears to not be related to the root cause of the issue and instead focuses on managing and truncating output length. Therefore, no symbol in this file directly relates to solving the reported issue about confusion in byte string error messages involving ASCII values. \n\n7. Suggest evaluating the files or modules involved in formatting or constructing assertion failure messages, particularly where byte comparison formatting is done, as a more relevant source of the problem.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/util.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:34:30.418067",
        "usage": "395.5340385437012 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/assertion/rewrite.py",
            "relevant_symbol_keys": [
              "AssertionRewritingHook#",
              "AssertionRewriter#",
              "AssertionRewriter.run",
              "AssertionRewriter.visit_Assert",
              "AssertionRewriter.visit_Compare",
              "_call_reprcompare"
            ],
            "root_cause_symbol_keys": [
              "AssertionRewritingHook#",
              "AssertionRewriter#",
              "AssertionRewriter.run",
              "AssertionRewriter.visit_Assert",
              "AssertionRewriter.visit_Compare",
              "_call_reprcompare"
            ]
          },
          {
            "file_path": "src/_pytest/assertion/__init__.py",
            "relevant_symbol_keys": [
              "pytest_runtest_setup",
              "util._reprcompare"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/util.py",
            "relevant_symbol_keys": [
              "assertrepr_compare",
              "_diff_text",
              "escape_for_readable_diff"
            ],
            "root_cause_symbol_keys": [
              "assertrepr_compare",
              "_diff_text",
              "escape_for_readable_diff"
            ]
          },
          {
            "file_path": "src/_pytest/assertion/truncate.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_runtest_setup(item):\n    \"\"\"Setup the pytest_assertrepr_compare hook\n\n    The newinterpret and rewrite modules will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == \"rewrite\":\n                    res = res.replace(\"%\", \"%%\")\n                return res\n\n    util._reprcompare = callbinrepr",
            "start_line": 93,
            "start_column": 2937,
            "end_line": 0,
            "end_column": 4439,
            "start_byte": 2937,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 216,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7424,
            "start_byte": 7283,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 349,
            "start_column": 11341,
            "end_line": 0,
            "end_column": 11429,
            "start_byte": 11341,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 562,
            "start_column": 19159,
            "end_line": 4,
            "end_column": 19300,
            "start_byte": 19159,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the res",
            "start_line": 107,
            "start_column": 3225,
            "end_line": 0,
            "end_column": 3343,
            "start_byte": 3225,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": ")\n    config._assertstate.trace(\"installed rewrite import hook\")\n\n    def undo():\n        hook = config._assertstate.hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session):\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = getattr(session.config, \"_assertstate\", None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\ndef pytest_runtest_setup(item):\n    \"\"\"S",
            "start_line": 67,
            "start_column": 2294,
            "end_line": 0,
            "end_column": 2977,
            "start_byte": 2294,
            "end_byte": 0
          },
          {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": " register_assert_rewrite(*names):\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError",
            "start_line": 28,
            "start_column": 795,
            "end_line": 0,
            "end_column": 1207,
            "start_byte": 795,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion._call_reprcompare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
            "start_line": 386,
            "start_column": 14311,
            "end_line": 0,
            "end_column": 14735,
            "start_byte": 14311,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 513,
            "start_column": 18546,
            "end_line": 4,
            "end_column": 20935,
            "start_byte": 18546,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 662,
            "start_column": 24275,
            "end_line": 4,
            "end_column": 26963,
            "start_byte": 24275,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 856,
            "start_column": 32390,
            "end_line": 4,
            "end_column": 34123,
            "start_byte": 32390,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "elif op == \"not in\":\n            if istext(left) an",
            "start_line": 144,
            "start_column": 4794,
            "end_line": 0,
            "end_column": 4845,
            "start_byte": 4794,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 115,
            "start_column": 3183,
            "end_line": 0,
            "end_column": 5297,
            "start_byte": 3183,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
            "start_line": 165,
            "start_column": 5300,
            "end_line": 0,
            "end_column": 7552,
            "start_byte": 5300,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:30.813609",
        "usage": "19320.380210876465 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_runtest_setup(item):\n    \"\"\"Setup the pytest_assertrepr_compare hook\n\n    The newinterpret and rewrite modules will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == \"rewrite\":\n                    res = res.replace(\"%\", \"%%\")\n                return res\n\n    util._reprcompare = callbinrepr",
            "start_line": 93,
            "start_column": 2937,
            "end_line": 0,
            "end_column": 4439,
            "start_byte": 2937,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 216,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7424,
            "start_byte": 7283,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 349,
            "start_column": 11341,
            "end_line": 0,
            "end_column": 11429,
            "start_byte": 11341,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 562,
            "start_column": 19159,
            "end_line": 4,
            "end_column": 19300,
            "start_byte": 19159,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the res",
            "start_line": 107,
            "start_column": 3225,
            "end_line": 0,
            "end_column": 3343,
            "start_byte": 3225,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": ")\n    config._assertstate.trace(\"installed rewrite import hook\")\n\n    def undo():\n        hook = config._assertstate.hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session):\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = getattr(session.config, \"_assertstate\", None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\ndef pytest_runtest_setup(item):\n    \"\"\"S",
            "start_line": 67,
            "start_column": 2294,
            "end_line": 0,
            "end_column": 2977,
            "start_byte": 2294,
            "end_byte": 0
          },
          {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": " register_assert_rewrite(*names):\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError",
            "start_line": 28,
            "start_column": 795,
            "end_line": 0,
            "end_column": 1207,
            "start_byte": 795,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion._call_reprcompare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
            "start_line": 386,
            "start_column": 14311,
            "end_line": 0,
            "end_column": 14735,
            "start_byte": 14311,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 513,
            "start_column": 18546,
            "end_line": 4,
            "end_column": 20935,
            "start_byte": 18546,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 662,
            "start_column": 24275,
            "end_line": 4,
            "end_column": 26963,
            "start_byte": 24275,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 856,
            "start_column": 32390,
            "end_line": 4,
            "end_column": 34123,
            "start_byte": 32390,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "elif op == \"not in\":\n            if istext(left) an",
            "start_line": 144,
            "start_column": 4794,
            "end_line": 0,
            "end_column": 4845,
            "start_byte": 4794,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 115,
            "start_column": 3183,
            "end_line": 0,
            "end_column": 5297,
            "start_byte": 3183,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
            "start_line": 165,
            "start_column": 5300,
            "end_line": 0,
            "end_column": 7552,
            "start_byte": 5300,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue describes a lack of clarity in assert statement error messages when dealing with byte strings. The messages show ASCII ordinal numbers instead of the characters, which can be confusing.\n1.2 The issue might be caused by the way assertions are rewritten and compared, possibly not taking into account the need to convert or represent byte strings more clearly.\n1.3 The expected result would be a more transparent error message that directly indicates the byte difference in a human-understandable form.\n1.4 Ideally, the message should highlight differences between byte strings in terms of actual characters or byte values, not ASCII codes.\n1.5 The issue could be fixed by modifying the assertion error message generation to better handle byte strings, perhaps by translating byte differences into a more intuitive format.\n\n2. Make the evaluate:\n2.1 Analyzing each symbol provided.\n2.2 Looking for those involved in generating assertion messages, especially those that generate or format comparison outputs.\n2.3 Evaluating which component contributes to the problematic byte-to-string representation of differences.\n\nIn order to solve the problem, we need to:\n- Identify where byte strings are being compared and where their representations are decided.\n- Locate any utility functions involved in formatting these error messages and check if there's a utility that can be improved or overwritten to change how the diff is represented.\n- Locate the specific piece of code where the message is composed and modify it to better handle byte strings.\n\nRight now, it appears we might need changes in the `_diff_text` or related functions that format the explanation based on comparisons of byte strings. There might also be changes needed in `_call_reprcompare` or `assertrepr_compare` to ensure they correctly interpret these diff results.",
        "symbols": [
          {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "reason": "The `_diff_text` function is directly responsible for explaining differences between two text or byte strings. Enhancing the handling of byte strings here to ensure that differences are shown in a non-confusing manner could resolve the issue."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "The `_call_reprcompare` symbol seems responsible for generating representations of comparisons. It utilizes the function `_reprcompare` if available, which is set by `pytest_runtest_setup`. It potentially prepares data for the comparison, but doesn't directly format byte string output.",
          "The `AssertionRewriter.run` symbol is a part of the process of rewriting assert statements but doesn't directly impact message formatting or byte string handling.",
          "The `visit_Assert` function of `AssertionRewriter` relates to transforming assertions and possibly influencing what gets compared or how, but doesn't appear directly connected to changing output for byte strings.",
          "The `visit_Compare` method generates some form of explanation or output that may be relevant to byte string presentation but doesn't define specific output formats.",
          "The symbol `assertrepr_compare` from `util.py` is involved in generating specialized explanations and proves relevant as it likely assembles parts of the error message including diffs.",
          "The `_diff_text` function within `util.py` appears crucial for explaining diffs between text or bytes, with specific handling for bytes which might be lacking, leading to confusion mentioned in the issue.",
          "The `pytest_runtest_setup` functions across various files initialize or set up hooks but don't directly shape assertion messages, though they do ensure custom comparison methods are used as needed."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:34:50.134018",
        "usage": "1.1169910430908203 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "def pytest_runtest_setup(item):\n    \"\"\"Setup the pytest_assertrepr_compare hook\n\n    The newinterpret and rewrite modules will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == \"rewrite\":\n                    res = res.replace(\"%\", \"%%\")\n                return res\n\n    util._reprcompare = callbinrepr",
              "start_line": 93,
              "start_column": 2937,
              "end_line": 0,
              "end_column": 4439,
              "start_byte": 2937,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 216,
              "start_column": 7283,
              "end_line": 4,
              "end_column": 7424,
              "start_byte": 7283,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 349,
              "start_column": 11341,
              "end_line": 0,
              "end_column": 11429,
              "start_byte": 11341,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 562,
              "start_column": 19159,
              "end_line": 4,
              "end_column": 19300,
              "start_byte": 19159,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the res",
              "start_line": 107,
              "start_column": 3225,
              "end_line": 0,
              "end_column": 3343,
              "start_byte": 3225,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": ")\n    config._assertstate.trace(\"installed rewrite import hook\")\n\n    def undo():\n        hook = config._assertstate.hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session):\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = getattr(session.config, \"_assertstate\", None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\ndef pytest_runtest_setup(item):\n    \"\"\"S",
              "start_line": 67,
              "start_column": 2294,
              "end_line": 0,
              "end_column": 2977,
              "start_byte": 2294,
              "end_byte": 0
            },
            {
              "name": "_pytest.nose.pytest_runtest_setup",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": " register_assert_rewrite(*names):\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError",
              "start_line": 28,
              "start_column": 795,
              "end_line": 0,
              "end_column": 1207,
              "start_byte": 795,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.assertion._call_reprcompare",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
              "start_line": 386,
              "start_column": 14311,
              "end_line": 0,
              "end_column": 14735,
              "start_byte": 14311,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.run",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
              "start_line": 513,
              "start_column": 18546,
              "end_line": 4,
              "end_column": 20935,
              "start_byte": 18546,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
              "start_line": 662,
              "start_column": 24275,
              "end_line": 4,
              "end_column": 26963,
              "start_byte": 24275,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
              "start_line": 856,
              "start_column": 32390,
              "end_line": 4,
              "end_column": 34123,
              "start_byte": 32390,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "elif op == \"not in\":\n            if istext(left) an",
              "start_line": 144,
              "start_column": 4794,
              "end_line": 0,
              "end_column": 4845,
              "start_byte": 4794,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
              "start_line": 115,
              "start_column": 3183,
              "end_line": 0,
              "end_column": 5297,
              "start_byte": 3183,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._diff_text",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
              "start_line": 165,
              "start_column": 5300,
              "end_line": 0,
              "end_column": 7552,
              "start_byte": 5300,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "",
              "start_line": 475,
              "start_column": 15508,
              "end_line": 0,
              "end_column": 16001,
              "start_byte": 15508,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue describes a lack of clarity in assert statement error messages when dealing with byte strings. The messages show ASCII ordinal numbers instead of the characters, which can be confusing.\n1.2 The issue might be caused by the way assertions are rewritten and compared, possibly not taking into account the need to convert or represent byte strings more clearly.\n1.3 The expected result would be a more transparent error message that directly indicates the byte difference in a human-understandable form.\n1.4 Ideally, the message should highlight differences between byte strings in terms of actual characters or byte values, not ASCII codes.\n1.5 The issue could be fixed by modifying the assertion error message generation to better handle byte strings, perhaps by translating byte differences into a more intuitive format.\n\n2. Make the evaluate:\n2.1 Analyzing each symbol provided.\n2.2 Looking for those involved in generating assertion messages, especially those that generate or format comparison outputs.\n2.3 Evaluating which component contributes to the problematic byte-to-string representation of differences.\n\nIn order to solve the problem, we need to:\n- Identify where byte strings are being compared and where their representations are decided.\n- Locate any utility functions involved in formatting these error messages and check if there's a utility that can be improved or overwritten to change how the diff is represented.\n- Locate the specific piece of code where the message is composed and modify it to better handle byte strings.\n\nRight now, it appears we might need changes in the `_diff_text` or related functions that format the explanation based on comparisons of byte strings. There might also be changes needed in `_call_reprcompare` or `assertrepr_compare` to ensure they correctly interpret these diff results.",
          "symbols": [
            {
              "name": "_pytest.assertion._diff_text",
              "file_path": "src/_pytest/assertion/util.py",
              "reason": "The `_diff_text` function is directly responsible for explaining differences between two text or byte strings. Enhancing the handling of byte strings here to ensure that differences are shown in a non-confusing manner could resolve the issue."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "The `_call_reprcompare` symbol seems responsible for generating representations of comparisons. It utilizes the function `_reprcompare` if available, which is set by `pytest_runtest_setup`. It potentially prepares data for the comparison, but doesn't directly format byte string output.",
            "The `AssertionRewriter.run` symbol is a part of the process of rewriting assert statements but doesn't directly impact message formatting or byte string handling.",
            "The `visit_Assert` function of `AssertionRewriter` relates to transforming assertions and possibly influencing what gets compared or how, but doesn't appear directly connected to changing output for byte strings.",
            "The `visit_Compare` method generates some form of explanation or output that may be relevant to byte string presentation but doesn't define specific output formats.",
            "The symbol `assertrepr_compare` from `util.py` is involved in generating specialized explanations and proves relevant as it likely assembles parts of the error message including diffs.",
            "The `_diff_text` function within `util.py` appears crucial for explaining diffs between text or bytes, with specific handling for bytes which might be lacking, leading to confusion mentioned in the issue.",
            "The `pytest_runtest_setup` functions across various files initialize or set up hooks but don't directly shape assertion messages, though they do ensure custom comparison methods are used as needed."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/assertion/util.py"
        ],
        "symbols": [
          "_pytest.assertion._diff_text"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_runtest_setup": {
            "name": "_pytest.assertion.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_runtest_setup(item):\n    \"\"\"Setup the pytest_assertrepr_compare hook\n\n    The newinterpret and rewrite modules will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == \"rewrite\":\n                    res = res.replace(\"%\", \"%%\")\n                return res\n\n    util._reprcompare = callbinrepr",
            "start_line": 93,
            "start_column": 2937,
            "end_line": 0,
            "end_column": 4439,
            "start_byte": 2937,
            "end_byte": 0
          },
          "_pytest.capture.CaptureManager.pytest_runtest_setup": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 216,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7424,
            "start_byte": 7283,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_setup": {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 349,
            "start_column": 11341,
            "end_line": 0,
            "end_column": 11429,
            "start_byte": 11341,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_setup": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 562,
            "start_column": 19159,
            "end_line": 4,
            "end_column": 19300,
            "start_byte": 19159,
            "end_byte": 4
          },
          "_pytest.runner.pytest_runtest_setup": {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the res",
            "start_line": 107,
            "start_column": 3225,
            "end_line": 0,
            "end_column": 3343,
            "start_byte": 3225,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_setup": {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": ")\n    config._assertstate.trace(\"installed rewrite import hook\")\n\n    def undo():\n        hook = config._assertstate.hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session):\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = getattr(session.config, \"_assertstate\", None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\ndef pytest_runtest_setup(item):\n    \"\"\"S",
            "start_line": 67,
            "start_column": 2294,
            "end_line": 0,
            "end_column": 2977,
            "start_byte": 2294,
            "end_byte": 0
          },
          "_pytest.nose.pytest_runtest_setup": {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": " register_assert_rewrite(*names):\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError",
            "start_line": 28,
            "start_column": 795,
            "end_line": 0,
            "end_column": 1207,
            "start_byte": 795,
            "end_byte": 0
          },
          "_pytest.assertion._call_reprcompare": {
            "name": "_pytest.assertion._call_reprcompare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
            "start_line": 386,
            "start_column": 14311,
            "end_line": 0,
            "end_column": 14735,
            "start_byte": 14311,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewriter.run": {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 513,
            "start_column": 18546,
            "end_line": 4,
            "end_column": 20935,
            "start_byte": 18546,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Assert": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 662,
            "start_column": 24275,
            "end_line": 4,
            "end_column": 26963,
            "start_byte": 24275,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Compare": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 856,
            "start_column": 32390,
            "end_line": 4,
            "end_column": 34123,
            "start_byte": 32390,
            "end_byte": 4
          },
          "_pytest.assertion.pytest_assertrepr_compare": {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "elif op == \"not in\":\n            if istext(left) an",
            "start_line": 144,
            "start_column": 4794,
            "end_line": 0,
            "end_column": 4845,
            "start_byte": 4794,
            "end_byte": 0
          },
          "_pytest.assertion.assertrepr_compare": {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 115,
            "start_column": 3183,
            "end_line": 0,
            "end_column": 5297,
            "start_byte": 3183,
            "end_byte": 0
          },
          "_pytest.assertion._diff_text": {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
            "start_line": 165,
            "start_column": 5300,
            "end_line": 0,
            "end_column": 7552,
            "start_byte": 5300,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_assertrepr_compare": {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        }
      }
    }
  ]
}