{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5692",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:33:50.715738",
        "usage": "1320.0321197509766 ms"
      },
      "request": {
        "repo_tokens": [
          "FDCaptureBinary",
          "get_terminal_writer",
          "runpytest_inprocess",
          "pytest_runtestloop",
          "capstdout",
          "_resume",
          "_show_fixtures_per_test",
          "repr_instance",
          "getfixturedefs",
          "show_test_item",
          "get_source",
          "getsource",
          "__array_ufunc__",
          "get_sections",
          "setupplan",
          "strip",
          "hasplugin",
          "parse_known_and_unknown_args",
          "function",
          "summary_passes",
          "_get_runner",
          "start_global_capturing",
          "Cache",
          "_processopt",
          "cleanup_candidates",
          "makefile",
          "pytest_leave_pdb",
          "summary_failures",
          "visit_Name",
          "invocation_dir",
          "fixturenames",
          "_markers",
          "setitem",
          "push_format_context",
          "getparent",
          "extract_suffixes",
          "_idval",
          "ApproxScalar",
          "pytest_doctest_prepare_content",
          "start",
          "MODULE_NOT_FOUND_ERROR",
          "processoption",
          "names_closure",
          "fnmatch_lines",
          "PYTESTER_COPY_EXAMPLE",
          "capture",
          "add_funcarg_pseudo_fixture_def",
          "LogCaptureHandler",
          "_get_verbose_word",
          "append_collect_error",
          "_parse_parametrize_args",
          "Traceback",
          "truncate_if_required",
          "_create_formatter",
          "set_session",
          "ApproxNumpy",
          "get_lock_path",
          "_read_pyc",
          "eval",
          "getpluginversioninfo",
          "issequence",
          "__bool__",
          "_version",
          "_start",
          "_typ_map",
          "_ensure_unconfigure",
          "_recursive_list_map",
          "typename",
          "style",
          "_get_pos",
          "__version_tuple__",
          "write_sep",
          "chdir",
          "repr_locals",
          "cacheprovider",
          "find",
          "summary_errors",
          "ids",
          "append_collect_skipped",
          "_update_message",
          "_node_location_to_relpath",
          "exit",
          "_plugin_nameversions",
          "runner",
          "safe_isclass",
          "notify_exception",
          "DOCTEST_REPORT_CHOICE_NONE",
          "readouterr",
          "_postmortem_traceback",
          "recwarn",
          "path",
          "traceback",
          "_initini",
          "node",
          "get_scope_package",
          "_consider_importhook",
          "deselect_by_mark",
          "_get_continue_on_failure",
          "teardown_exact",
          "__eq__",
          "scopemismatch",
          "get_default_arg_names",
          "resume_capturing",
          "scope2props",
          "junitxml",
          "illegal_xml_re",
          "ensure_reset_dir",
          "nextitem",
          "_validate_args",
          "cls",
          "delattr",
          "repr_args",
          "_traceback",
          "parts",
          "MarkGenerator",
          "spawn",
          "INTERNAL_ERROR",
          "ReprEntry",
          "CallInfo",
          "write_fspath_result",
          "_exec_lsof",
          "add_report_section",
          "getcall",
          "set_log_path",
          "CLOSE_STDIN",
          "Instance",
          "cwd_relative_nodeid",
          "mkdir",
          "ApproxSequencelike",
          "Entry",
          "ReprEntryNative",
          "ExceptionChainRepr",
          "getpathnode",
          "obj",
          "pytest_warning_captured",
          "README_CONTENT",
          "FunctionMixin",
          "exconly",
          "keywords",
          "_assert_expr_to_lineno",
          "fail_fixturefunc",
          "pop",
          "_import_plugin_specs",
          "pytest_terminal_summary",
          "plugins",
          "_fail_on_non_top_pytest_plugins",
          "item_capture",
          "_teardown_yield_fixture",
          "wrap_session",
          "_makeitem",
          "isiterable",
          "_given_basetemp",
          "STRING_TYPES",
          "_report_unserialization_failure",
          "Testdir",
          "addSkip",
          "names",
          "_get_active_fixturedef",
          "__len__",
          "dir",
          "call_fixture_func",
          "_recursive_debug",
          "module",
          "LOGLEVEL_COLOROPTS",
          "delenv",
          "_outrep_summary",
          "last_failed_paths",
          "finish",
          "addini",
          "ReprTraceback",
          "pytest_report_header",
          "_in_venv",
          "add_global_property",
          "store_mark",
          "resultlog",
          "OutcomeException",
          "source",
          "_check_if_assertion_pass_impl",
          "parseconfig",
          "collect_by_name",
          "repr_traceback",
          "_format_args",
          "resolve_fixture_function",
          "_checkargnotcontained",
          "getplugin",
          "DoctestModule",
          "_ensure_basetemp",
          "PyobjContext",
          "showfixtures",
          "runpytest",
          "name",
          "config",
          "getgroup",
          "builtin_plugins",
          "pytest_report_from_serializable",
          "annotated_getattr",
          "getinicfg",
          "pop_outerr_to_orig",
          "_get_allow_bytes_flag",
          "_get_pdb_wrapper_class",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "_log",
          "_showfixtures_main",
          "Class",
          "make_numbered_dir_with_cleanup",
          "_getnextfixturedef",
          "alias",
          "add_cleanup",
          "assert_outcomes",
          "mark",
          "_get_allow_unicode_flag",
          "CaptureManager",
          "wrap_function_to_error_out_if_called_directly",
          "startTest",
          "suspend_fixture",
          "check_interactive_exception",
          "_colorama_workaround",
          "cached_result",
          "builtin",
          "id",
          "DEFAULT_MAX_LINES",
          "warns",
          "addExpectedFailure",
          "LEVELNAME_FMT_REGEX",
          "getitems",
          "_truncate_by_char_count",
          "consider_preparse",
          "record_property",
          "to_xml",
          "suspend_capturing",
          "pastebin",
          "capsys",
          "TimeoutExpired",
          "__enter__",
          "get_data",
          "_idvalset",
          "_format_repr_exception",
          "add_marker",
          "_pytest",
          "NFPlugin",
          "newinstance",
          "PytestExperimentalApiWarning",
          "_format_lines",
          "approx",
          "getparam",
          "__call__",
          "__nonzero__",
          "_addoption",
          "PrintHelp",
          "_makepath",
          "handler",
          "rewrite_asserts",
          "_assertion_pass",
          "popcall",
          "_truncate_recursive_traceback",
          "fillfixtures",
          "_repr_style",
          "_warn_incompatibility_with_xunit2",
          "wasvalid",
          "update",
          "deselect_by_keyword",
          "PYC_EXT",
          "_early_rewrite_bailout",
          "_width_of_current_line",
          "ensure_deletable",
          "tmpdir",
          "applymarker",
          "_find_spec",
          "_PLUGGY_DIR",
          "_get_increasing_order",
          "INTERRUPTED",
          "_collect",
          "summary_stats",
          "nose",
          "tb",
          "visit_Call",
          "DoctestTextfile",
          "FixtureDef",
          "_pyfuncitem",
          "safeformat",
          "write_docstring",
          "USAGE_MSG",
          "_determine_show_progress_info",
          "showfspath",
          "pytest_sessionstart",
          "python_api",
          "istestclass",
          "_compare_eq_verbose",
          "writeorg",
          "PdbTrace",
          "session",
          "prepare",
          "_translate_non_printable",
          "recursionindex",
          "_makefile",
          "cleanup_numbered_dir",
          "_io",
          "is_rewrite_disabled",
          "_get_number_flag",
          "_get_plugin_specs_as_list",
          "consider_pluginarg",
          "_import_pdb_cls",
          "TempdirFactory",
          "_rewrite_test",
          "_parse_parametrize_parameters",
          "_compute_fixture_value",
          "_assertion_supported",
          "make_numbered_dir",
          "deprecated_call",
          "filter",
          "consider_module",
          "_saferepr",
          "_inject_setup_teardown_fixtures",
          "_pluginmanager",
          "_importconftest",
          "Failed",
          "debugging",
          "_ensure_supporting_files",
          "formatrepr",
          "version_tuple",
          "DropShorterLongHelpFormatter",
          "defaultfuncargprefixmarker",
          "append_failure",
          "importorskip",
          "testdir",
          "pathlib",
          "assert_contains",
          "toterminal",
          "global_and_fixture_disabled",
          "repr_excinfo",
          "execute",
          "XFailed",
          "getslaveinfoline",
          "terminal",
          "PytestPluginManager",
          "_callfinalizers",
          "errors",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "head_line",
          "deindent",
          "buffer",
          "idmaker",
          "create_module",
          "_inject_setup_class_fixture",
          "getfirstlinesource",
          "_setup_cli_logging",
          "set_repr_style",
          "DEFAULT_MAX_CHARS",
          "_parsearg",
          "pytest_runtest_call",
          "pytest_collection_finish",
          "_getindent",
          "_ANSI_ESCAPE_SEQ",
          "iter_markers_with_node",
          "_compilecounter",
          "TEST_OUTCOME",
          "inline_genitems",
          "funcnamefilter",
          "display",
          "pytest_load_initial_conftests",
          "undo",
          "Node",
          "SafeRepr",
          "suspend_global_capture",
          "SysCaptureBinary",
          "pytest_cmdline_preparse",
          "DontReadFromInput",
          "_printcollecteditems",
          "get_lines_after",
          "pytest_internalerror",
          "_get_progress_information_message",
          "pytestPDB",
          "getstatementrange",
          "BINOP_MAP",
          "write",
          "pytest_runtest_logstart",
          "add_property",
          "MarkDecorator",
          "runtest",
          "repr_failure",
          "addsection",
          "pytest_unconfigure",
          "getrawcode",
          "FixtureRequest",
          "findsource",
          "__str__",
          "showlocals",
          "Exit",
          "default_plugins",
          "getlocation",
          "_setup_collect_fakemodule",
          "_istrue",
          "_remove_ansi_escape_sequences",
          "from_config",
          "_schedule_finalizers",
          "runpytest_subprocess",
          "UsageError",
          "setattr",
          "hasinit",
          "delitem",
          "SetupState",
          "_ensure_only_one_capture_fixture",
          "_getconftest_pathlist",
          "hookimpl",
          "_sys_snapshot",
          "param",
          "nodes",
          "_getlines",
          "getnode",
          "_PY_DIR",
          "register_assert_rewrite",
          "_legal_chars",
          "with_args",
          "_initrequest",
          "truncate_locals",
          "RE_IMPORT_ERROR_NAME",
          "make_hook_recorder",
          "match",
          "_factorytraceback",
          "warning_types",
          "write_ensure_prefix",
          "FixtureLookupErrorRepr",
          "PdbInvoke",
          "faulthandler",
          "_check_scope",
          "check_xfail_no_run",
          "_get_assertion_exprs",
          "pytester",
          "_inject_setup_method_fixture",
          "_rget_with_confmod",
          "exprinfo",
          "directory_arg",
          "parse_hookimpl_opts",
          "flow_marker",
          "_test_pytest_function",
          "Package",
          "tracebackcutdir",
          "consider_env",
          "OptionGroup",
          "RunResult",
          "_is_capturing",
          "reset",
          "Session",
          "_testcase",
          "FixtureLookupError",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "FSCollector",
          "get_fslocation_from_item",
          "_strtobool",
          "visit_Attribute",
          "LFPlugin",
          "activate_fixture",
          "_bytes_to_ascii",
          "rewrite",
          "pytest_assertion_pass",
          "_repr_failure_py",
          "hasnew",
          "setenv",
          "showheader",
          "own_markers",
          "_get_override_ini_value",
          "__repr__",
          "format_explanation",
          "markname",
          "visit_BoolOp",
          "_getautousenames",
          "IGNORE_PAM",
          "getdecoded",
          "getini",
          "_legal_xml_re",
          "_inject_setup_function_fixture",
          "getitem",
          "InvocationParams",
          "skipping",
          "cache_dir_from_config",
          "helper",
          "is_globally_capturing",
          "_non_printable_ascii_translate_table",
          "getexplanation",
          "capstderr",
          "pytest_report_collectionfinish",
          "get_dirs_from_args",
          "_set_initial_conftests",
          "PYTEST_TAG",
          "_split_explanation",
          "classnamefilter",
          "deactivate_fixture",
          "_suspend",
          "args",
          "parse",
          "iter_markers",
          "isnosetest",
          "istestfunction",
          "find_suffixes",
          "copy",
          "assign",
          "_running_on_ci",
          "pytest_addhooks",
          "get_plugin_manager",
          "FastFilesCompleter",
          "_basetemp",
          "matchmark",
          "_get_fixturestack",
          "disabled",
          "make_properties_node",
          "CaptureFixture",
          "_py36_windowsconsoleio_workaround",
          "MultipleDoctestFailures",
          "indent",
          "showversion",
          "gethookproxy",
          "ReprLocals",
          "showlongtestinfo",
          "_matchnodes",
          "get_location",
          "_code",
          "__getitem__",
          "_bestrelpath_cache",
          "chain",
          "get_empty_parameterset_mark",
          "create_cleanup_lock",
          "log_outcome",
          "EncodedFile",
          "ihook",
          "NOTSET",
          "prune_dependency_tree",
          "capsysbinary",
          "excinfo",
          "write_line",
          "_importtestmodule",
          "syspath_prepend",
          "getfailures",
          "UnitTestCase",
          "_get_checker",
          "pytest_cmdline_main",
          "warn_about_none_ast",
          "_match_lines_random",
          "get_optionflags",
          "LogXML",
          "Skipped",
          "_compare_eq_set",
          "teardown_all",
          "inline_run",
          "LOCK_TIMEOUT",
          "fnmatch_lines_random",
          "_should_repr_global_name",
          "pytest_exception_interact",
          "TestReport",
          "_result",
          "LsofFdLeakChecker",
          "_compare_eq_cls",
          "_report_keyboardinterrupt",
          "CallSpec2",
          "TerminalRepr",
          "path_matches_patterns",
          "repr_traceback_entry",
          "snap",
          "_mk_tmp",
          "FormattedExcinfo",
          "_init_pdb",
          "_iter_rewritable_modules",
          "PseudoFixtureDef",
          "record_testreport",
          "raises",
          "isinitpath",
          "MultiCapture",
          "_write_report_lines_from_hooks",
          "yield_fixture",
          "_write_progress_information_filling_space",
          "warnings",
          "_resolve_arg_ids",
          "_addfinalizer",
          "kwargs",
          "addFailure",
          "fspath",
          "cut",
          "nodeid",
          "readlines",
          "records",
          "pytest_assertrepr_compare",
          "set_level",
          "PytestArg",
          "getcrashentry",
          "matching_platform",
          "pytest_itemcollected",
          "TestCaseFunction",
          "collect",
          "_runtest_for_main",
          "pytest_enter_pdb",
          "collect_one_node",
          "Module",
          "get_exconly",
          "consider_conftest",
          "is_generator",
          "compile",
          "record_testsuite_property",
          "PyCollector",
          "_validate_if_using_arg_names",
          "ReprFileLocation",
          "stepwise",
          "TerminalReporter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "_preparse",
          "_mark_plugins_for_rewrite",
          "ArgumentError",
          "_legal_ranges",
          "filename_arg",
          "call_and_report",
          "UnformattedWarning",
          "_addoption_instance",
          "SEP",
          "_config_for_test",
          "getfuncargnames",
          "visit_Compare",
          "getfslineno",
          "call_optional",
          "get_statement_startend2",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "reorder_items",
          "freeze_support",
          "message",
          "get_option_ini",
          "is_capturing",
          "notset",
          "runpython_c",
          "__init__",
          "pytest_pycollect_makeitem",
          "from_item_and_call",
          "_issue_warning_captured",
          "_striptext",
          "KeywordMapping",
          "addUnexpectedSuccess",
          "resolve",
          "visit_UnaryOp",
          "pytest_report_to_serializable",
          "from_item",
          "_config",
          "_is_numpy_array",
          "_get_line_with_reprcrash_message",
          "_inject_setup_module_fixture",
          "fnmatch_ex",
          "frame",
          "ResultLog",
          "variable",
          "get_real_method",
          "normalize_mark_list",
          "CFG_PYTEST_SECTION",
          "CollectError",
          "when",
          "Code",
          "pytest_runtest_setup",
          "_to_json",
          "getargs",
          "LoggingPlugin",
          "_done",
          "isset",
          "_checkversion",
          "FDCapture",
          "pytest_collectstart",
          "ColoredLevelFormatter",
          "set_when",
          "_force_symlink",
          "getrepr",
          "FUNCARGNAMES",
          "_install_capture_fixture_on_item",
          "CaptureIO",
          "scope",
          "countoutcomes",
          "isatty",
          "_yield_comparisons",
          "compile_",
          "__test__",
          "PytestUnhandledCoroutineWarning",
          "_LiveLoggingStreamHandler",
          "catch_warnings_for_item",
          "OK",
          "warning_record_to_str",
          "_init_runner_class",
          "params",
          "Collector",
          "ApproxBase",
          "merge_family",
          "_check_type",
          "ApproxMapping",
          "_reprcompare",
          "Source",
          "_getcapture",
          "_validate_usepdb_cls",
          "version",
          "scopenum_function",
          "_getobj",
          "FixtureManager",
          "pytest_addoption",
          "pytest_collection_modifyitems",
          "parse_args",
          "suspend",
          "PercentStyleMultiline",
          "getfixturevalue",
          "_opentestcase",
          "listchain",
          "on_rm_rf_error",
          "restore",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_compare_eq_sequence",
          "_make_xunit_fixture",
          "doctest_namespace",
          "PytestCacheWarning",
          "scopename2class",
          "isdatacls",
          "get",
          "NoCapture",
          "append_skipped",
          "_NodeReporter",
          "WarningsChecker",
          "teardown_nose",
          "StepwisePlugin",
          "get_actual_log_level",
          "pytest_collect_directory",
          "__all__",
          "_setup_fixtures",
          "pytest_runtest_makereport",
          "listnames",
          "finalize",
          "_finalize",
          "ExceptionRepr",
          "safe_text_dupfile",
          "runpython",
          "setuponly",
          "_getconftestmodules",
          "PYC_TAIL",
          "append",
          "get_config",
          "get_public_names",
          "hasopt",
          "nofuncargs",
          "getstatementrange_ast",
          "assert_contains_lines",
          "re_match_lines_random",
          "deprecated",
          "_matches_prefix_or_glob_option",
          "fill_unfilled",
          "LineMatcher_fixture",
          "get_common_ancestor",
          "ParameterSet",
          "pop_format_context",
          "resume_global_capture",
          "_set_opt_strings",
          "scope2index",
          "pytest_pycollect_makemodule",
          "_genfunctions",
          "pytest_report_teststatus",
          "ReprFailDoctest",
          "scopeproperty",
          "PytestCollectionWarning",
          "REGEX_TYPE",
          "DoctestItem",
          "NodeMarkers",
          "ensure_newline",
          "__take_sys_modules_snapshot",
          "import_plugin",
          "Config",
          "is_true",
          "_readline_workaround",
          "getcalls",
          "pyobj_property",
          "from_current",
          "locals",
          "instance",
          "_collectfile",
          "_tryconvertpyarg",
          "makeini",
          "_dump_lines",
          "setup",
          "bin_xml_escape",
          "catching_logs",
          "_log_cli_enabled",
          "CACHEDIR_TAG_CONTENT",
          "tmp_path_factory",
          "fix_cache_order",
          "_getpytestargs",
          "_for_parametrize",
          "get_closest_marker",
          "_parse_lsof_output",
          "_try_load_conftest",
          "CollectErrorRepr",
          "_get_flag_lookup",
          "getfixturemarker",
          "_argcomplete",
          "resume",
          "pytest_runtest_logfinish",
          "tolerance",
          "_get_marks",
          "SysModulesSnapshot",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "__iter__",
          "tmp_path",
          "__getattr__",
          "addinivalue_line",
          "_enter_pdb",
          "NO_TESTS_COLLECTED",
          "__exit__",
          "REPORT_COLLECTING_RESOLUTION",
          "__delitem__",
          "addfinalizer",
          "get_real_func",
          "co_equal",
          "SysPathsSnapshot",
          "Metafunc",
          "_write_pyc",
          "PytestUnknownMarkWarning",
          "_is_mocked",
          "SubRequest",
          "BASE_TYPE",
          "_find_parametrized_scope",
          "_ellipsize",
          "MARK_GEN",
          "funcargs",
          "set",
          "HelpAction",
          "entrysep",
          "errisinstance",
          "_patch_unwrap_mock_aware",
          "invalidraise",
          "setns",
          "type",
          "pytest_fixture_post_finalizer",
          "write_log_entry",
          "python",
          "RaisesContext",
          "_disable_output_capturing_for_darwin",
          "_getreprcrash",
          "stop_global_capturing",
          "encoding",
          "set_location",
          "matchreport",
          "setmulti2",
          "build_summary_stats_line",
          "__hash__",
          "essential_plugins",
          "visit_Starred",
          "parsefactories",
          "_splitnode",
          "pytest_runtest_logreport",
          "Parser",
          "create_terminal_writer",
          "reports",
          "istestfunc",
          "result",
          "_should_rewrite",
          "extract_from",
          "_iter_all_modules",
          "getreports",
          "mktemp",
          "getvalueorskip",
          "initialnames",
          "outcomes",
          "matchnodes",
          "iscoroutinefunction",
          "RESULT_LOG",
          "combined_with",
          "fixtures",
          "prog",
          "fileno",
          "families",
          "update_testcase_duration",
          "fullsource",
          "filter_traceback",
          "_from_json",
          "TYPE_CHECKING",
          "_format_assertmsg",
          "getfailedcollections",
          "DEFAULT_RELATIVE_TOLERANCE",
          "isdict",
          "Frame",
          "LogCaptureFixture",
          "LineComp",
          "DEFAULT_LOG_DATE_FORMAT",
          "for_config",
          "at_level",
          "fail",
          "_warn_already_imported",
          "linecomp",
          "resume_fixture",
          "context",
          "_wrapped_pdb_cls",
          "DEFAULT_LOG_FORMAT",
          "parametrize",
          "pytest_collectreport",
          "explanation_param",
          "ReprFuncArgs",
          "assertrepr_compare",
          "mkpydir",
          "mark_rewrite",
          "AssertionRewritingHook",
          "show_fixtures_per_test",
          "failed",
          "unittest",
          "FILE_OR_DIR",
          "_compare_eq_dict",
          "getoption",
          "from_call",
          "EMPTY_PARAMETERSET_OPTION",
          "_getparser",
          "teardown",
          "find_prefixed",
          "__ne__",
          "_call_with_optional_argument",
          "out",
          "_PytestWrapper",
          "_call_reprcompare",
          "listextrakeywords",
          "listoutcomes",
          "MoreQuietAction",
          "_get_report_choice",
          "getstatement",
          "ParsedCall",
          "template",
          "MyOptionParser",
          "TempPathFactory",
          "getbasetemp",
          "clear",
          "HookRecorder",
          "_locationline",
          "__module__",
          "MonkeyPatch",
          "get_records",
          "maybe_delete_a_numbered_dir",
          "generic_visit",
          "passed",
          "_call_assertion_pass",
          "_getscopeitem",
          "popen",
          "LineMatcher",
          "register",
          "pytest_collect_file",
          "conftest_options",
          "getfixtureclosure",
          "_getfailureheadline",
          "skipped",
          "FuncFixtureInfo",
          "_teardown_with_finalization",
          "value",
          "AssertionRewriter",
          "CaptureResult",
          "tbfilter",
          "readline",
          "install_importhook",
          "error",
          "parseconfigure",
          "_addexcinfo",
          "capfdbinary",
          "__array_priority__",
          "Interrupted",
          "pytest_make_parametrize_id",
          "ApproxDecimal",
          "abspath",
          "putaround",
          "register_cleanup_lock_removal",
          "find_spec",
          "TracebackEntry",
          "saferepr",
          "EMPTY_BUFFER",
          "rm_rf",
          "pytest_runtest_protocol",
          "getmodpath",
          "_ascii_escaped_by_config",
          "record_tuples",
          "_prunetraceback",
          "ExceptionInfo",
          "pytest_itemstart",
          "istrue",
          "stopTest",
          "read",
          "emit",
          "__next__",
          "RUNNER_CLASS",
          "pytest_fixture_setup",
          "_teardown_towards",
          "summary_warnings",
          "_match_lines",
          "_seen",
          "write_captured_output",
          "location",
          "_cachedir",
          "showhelp",
          "_resolve_arg_value_types",
          "count_towards_summary",
          "DOCTEST_REPORT_CHOICES",
          "_E",
          "done",
          "addSuccess",
          "isattrs",
          "MarkMapping",
          "post_mortem",
          "pytest_deselected",
          "istext",
          "safe_getattr",
          "__version__",
          "Notset",
          "_approx_scalar",
          "get_scope_node",
          "NodeKeywords",
          "addError",
          "__setitem__",
          "AssertionState",
          "getcfg",
          "_add_simple",
          "skip",
          "runitem",
          "maketxtfile",
          "parse_known_args",
          "pytest_ignore_collect",
          "raiseerror",
          "cached_eval",
          "FuncargnamesCompatAttr",
          "gethookrecorder",
          "_is_marked_for_rewrite",
          "verbosity",
          "for_later",
          "_update_current_test_var",
          "assertoutcome",
          "record_xml_attribute",
          "pytest_pyfunc_call",
          "ishidden",
          "_getcrashline",
          "SysCapture",
          "longreprtext",
          "_show_fixture_action",
          "NoMatch",
          "mode",
          "makeconftest",
          "resolve_from_str",
          "derive_importpath",
          "getmodulecol",
          "append_pass",
          "is_potential_nosetest",
          "PytestAssertRewriteWarning",
          "_getglobals",
          "perform_collect",
          "str",
          "_PYTEST_DIR",
          "FixtureFunctionMarker",
          "append_error",
          "print_teardown_sections",
          "num_mock_patch_args",
          "_truncate_explanation",
          "_perform_collect",
          "writelines",
          "getreportopt",
          "_notin_text",
          "funcargnames",
          "_folded_skips",
          "DummyRewriteHook",
          "_check_all_skipped",
          "statement",
          "cacheshow",
          "USAGE_ERROR",
          "stop",
          "start_capturing",
          "list",
          "exists",
          "runtestprotocol",
          "category",
          "capture_fixtures",
          "_prepareconfig",
          "_fillfixtures",
          "fixture",
          "pytestconfig",
          "check_testcase_implements_trial_reporter",
          "ascii_escaped",
          "pytest_plugin_registered",
          "pytest_configure",
          "add_attribute",
          "TESTS_FAILED",
          "_visit_filter",
          "try_cleanup",
          "line",
          "getvalue",
          "helpconfig",
          "copy_example",
          "_get_global_properties_node",
          "mangle_test_address",
          "_check_initialpaths_for_relpath",
          "_recurse",
          "FSHookProxy",
          "_is_setup_py",
          "MarkEvaluator",
          "_matchfactories",
          "re_match_lines",
          "_format_boolop",
          "PytestDeprecationWarning",
          "WarningsRecorder",
          "xfail",
          "pytest_cmdline_parse",
          "_getini",
          "_assert_start_repr",
          "freeze_includes",
          "own_mark_names",
          "monkeypatch",
          "_ALLOW_MARKERS",
          "create_new_paste",
          "_runtest_for",
          "close",
          "_format_action_invocation",
          "format",
          "pytest_runtest_teardown",
          "logging",
          "text",
          "PytestConfigWarning",
          "set_trace",
          "argnames",
          "_do_configure",
          "get_open_files",
          "parse_hookspec_opts",
          "warn",
          "node_reporter",
          "_get_stderr_fileno",
          "_log_text",
          "call_runtest_hook",
          "_pop_and_teardown",
          "run",
          "hookspec",
          "_trace",
          "PytestWarning",
          "__missing__",
          "CollectReport",
          "short_test_summary",
          "WarningReport",
          "pytest_generate_tests",
          "_py_ext_re",
          "getimfunc",
          "Item",
          "spawn_pytest",
          "add_stats",
          "compat",
          "report_collect",
          "_ensure_immutable_ids",
          "messages",
          "FunctionDefinition",
          "setall",
          "ConftestImportFailure",
          "_warn_about_missing_assertion",
          "_getentrysource",
          "name2fixturedefs",
          "genitems",
          "stop_capturing",
          "doctest",
          "_saved",
          "get_direct_param_fixture_func",
          "reorder_items_atscope",
          "fslocation",
          "Argument",
          "_state",
          "ExitCode",
          "rex_outcome",
          "capfd",
          "makedir",
          "_tmppath_factory",
          "Function",
          "autouse",
          "_excinfo",
          "astcache",
          "get_parametrized_fixture_keys",
          "section",
          "exec_module",
          "tmpdir_factory",
          "from_exc_info",
          "parseoutcomes",
          "PyobjMixin",
          "ReprExceptionInfo",
          "_non_numeric_type_error",
          "cache",
          "determine_setup",
          "caplog",
          "UNARY_MAP",
          "visit_Assert",
          "isparseable",
          "relline",
          "pytest_make_collect_report",
          "pytest_keyboard_interrupt",
          "_ensure_removed_sysmodule",
          "addoption",
          "reportinfo",
          "_get_first_non_fixture_func",
          "_handle_skip",
          "patchsysdict",
          "syspathinsert",
          "finish_recording",
          "pytest_sessionfinish",
          "Mark",
          "getfixtureinfo",
          "scopes",
          "repr",
          "ischildnode",
          "get_user",
          "ReprTracebackNative",
          "_diff_text",
          "parse_setoption",
          "_check_record_param_type",
          "BaseReport",
          "_getvaluepath",
          "_main",
          "exec_",
          "parse_num",
          "simple",
          "assertion",
          "attrs",
          "_should_truncate_item",
          "inline_runsource",
          "File",
          "CwdSnapshot",
          "main",
          "fromdictargs",
          "_is_doctest",
          "matchkeyword",
          "_compare_eq_iterable",
          "_get_direct_parametrize_args",
          "check_strict_xfail",
          "visit_BinOp",
          "cmdline",
          "fail_marker",
          "Junit",
          "read_global_capture",
          "python_keywords_allowed_list",
          "pytest_collection",
          "_setoption",
          "makepyfile",
          "get_unpacked_marks"
        ]
      },
      "response": {
        "keywords": [
          "junitxml",
          "to_xml",
          "record_testsuite_property",
          "LogXML",
          "add_property",
          "add_report_section",
          "record_property",
          "update_testcase_duration",
          "pytest_configure"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:33:52.035785",
        "usage": "217.82183647155762 ms"
      },
      "request": {
        "tokens": [
          "junitxml",
          "to_xml",
          "record_testsuite_property",
          "LogXML",
          "add_property",
          "add_report_section",
          "record_property",
          "update_testcase_duration",
          "pytest_configure"
        ]
      },
      "response": {
        "results": {
          "pytest_configure": [
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/terminal.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/skipping.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/stepwise.py"
          ],
          "add_report_section": [
            "src/_pytest/nodes.py",
            "src/_pytest/capture.py",
            "src/_pytest/logging.py"
          ],
          "junitxml": [
            "src/_pytest/junitxml.py",
            "src/_pytest/config/__init__.py"
          ],
          "add_property": [
            "src/_pytest/junitxml.py"
          ],
          "to_xml": [
            "src/_pytest/junitxml.py"
          ],
          "record_property": [
            "src/_pytest/junitxml.py"
          ],
          "record_testsuite_property": [
            "src/_pytest/junitxml.py"
          ],
          "LogXML": [
            "src/_pytest/junitxml.py"
          ],
          "update_testcase_duration": [
            "src/_pytest/junitxml.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:33:52.253615",
        "usage": "7338.9787673950195 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_configure": [
            "src/_pytest/resultlog.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/terminal.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/skipping.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/stepwise.py"
          ],
          "add_report_section": [
            "src/_pytest/nodes.py",
            "src/_pytest/capture.py",
            "src/_pytest/logging.py"
          ],
          "junitxml": [
            "src/_pytest/junitxml.py",
            "src/_pytest/config/__init__.py"
          ],
          "add_property": [
            "src/_pytest/junitxml.py"
          ],
          "to_xml": [
            "src/_pytest/junitxml.py"
          ],
          "record_property": [
            "src/_pytest/junitxml.py"
          ],
          "record_testsuite_property": [
            "src/_pytest/junitxml.py"
          ],
          "LogXML": [
            "src/_pytest/junitxml.py"
          ],
          "update_testcase_duration": [
            "src/_pytest/junitxml.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue reports that the generated JUnit XML reports by pytest lack 'hostname' and 'timestamp' properties in the 'testsuite' XML element. To address this, we need to find where the XML reports are generated or configured, particularly focusing on adding or modifying these properties.\n\n1. **junitxml** keyword:\n   - The file `src/_pytest/junitxml.py` appears repeatedly with different related keywords such as 'junitxml', 'add_property', 'to_xml', 'record_property', 'record_testsuite_property', 'LogXML', and 'update_testcase_duration'. This suggests that this file is heavily involved in the generation and configuration of JUnit XML reports in pytest. It's likely where modifications can be made to include the 'hostname' and 'timestamp' properties in the XML output.\n\n2. **pytest_configure** keyword:\n   - The file `src/_pytest/junitxml.py` also appears under the 'pytest_configure' keyword. This is relevant since configuration hooks in pytest might allow setting the required properties.\n\n3. **record_testsuite_property** keyword:\n   - The file `src/_pytest/junitxml.py` is specifically connected to 'record_testsuite_property', indicating it may have functionality for adding properties to the testsuite element. This is directly relevant to adding 'hostname' and 'timestamp'.\n\nGiven the repetitive appearance and the direct connection of these keywords to the issue, `src/_pytest/junitxml.py` is very likely the file where the solution resides or needs to be implemented.\n\nThus, I will prioritize `src/_pytest/junitxml.py` as the relevant file path.",
        "file_paths": [
          "src/_pytest/junitxml.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:33:59.592611",
        "usage": "10020.71499824524 ms"
      },
      "request": {
        "file_path": "src/_pytest/junitxml.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing User Instructions:\n1.1 The user is describing an issue related to the pytest framework where JUnit XML reports do not include `hostname` and `timestamp` properties in the <testsuite> XML element.\n1.2 The user provided an example of a pytest report and contrasted it with a junit report to show the missing attributes.\n1.3 The user expects to have both `hostname` and `timestamp` attributes in the JUnit XML output by pytest, similar to standard junit reports.\n1.4 To address the user expectation, pytest needs to have functionality where it captures and includes the system hostname and the current timestamp as part of the XML it generates for each test suite.\n\n2. Evaluating File Content:\n2.1 The `LogXML` class in the file appears to be responsible for generating JUnit XML reports for pytest.\n2.2 In the `JUnit.testsuite` method within `LogXML.pytest_sessionfinish`, it sets several attributes like name, errors, failures, etc., but does not include `hostname` or `timestamp` in its generation process.\n2.3 The `LogXML.pytest_sessionstart` method records the start time but does not use it for the timestamp. It also lacks hostname handling, which was identified as missing.\n2.4 There are no methods or properties that explicitly set the `hostname` and `timestamp` attributes for the testsuite element.\n2.5 Adding properties like the hostname and timestamp within the `pytest_sessionstart` and `pytest_sessionfinish` methods by using, for instance, the socket module for the hostname and extending the suite_node with a timestamp string would be potential solutions.\n2.6 The problem seems to lie within the `LogXML` class and methods responsible for setting suite-level attributes, root cause.\n\n3. Conclusion:\n- The root cause of the issue seems to be within the `LogXML` class, particularly in its handling of super-methods for session timing (`pytest_sessionstart`) and finalization (`pytest_sessionfinish`).",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "LogXML.pytest_sessionfinish",
          "LogXML"
        ],
        "root_cause_symbols": [
          "LogXML.pytest_sessionfinish",
          "LogXML"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:34:09.613349",
        "usage": "75.86884498596191 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/junitxml.py",
            "relevant_symbol_keys": [
              "LogXML.pytest_sessionfinish",
              "LogXML"
            ],
            "root_cause_symbol_keys": [
              "LogXML.pytest_sessionfinish",
              "LogXML"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.junitxml.LogXML",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 465,
            "start_column": 15042,
            "end_line": 0,
            "end_column": 23343,
            "start_byte": 15042,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.LogXML.__init__",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
            "start_line": 466,
            "start_column": 15060,
            "end_line": 4,
            "end_column": 16111,
            "start_byte": 15060,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.finalize",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
            "start_line": 497,
            "start_column": 16117,
            "end_line": 4,
            "end_column": 16424,
            "start_byte": 16117,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.node_reporter",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
            "start_line": 505,
            "start_column": 16430,
            "end_line": 4,
            "end_column": 16945,
            "start_byte": 16430,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_stats",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
            "start_line": 523,
            "start_column": 16951,
            "end_line": 4,
            "end_column": 17039,
            "start_byte": 16951,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._opentestcase",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
            "start_line": 527,
            "start_column": 17045,
            "end_line": 4,
            "end_column": 17190,
            "start_byte": 17045,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
            "start_line": 532,
            "start_column": 17196,
            "end_line": 4,
            "end_column": 20514,
            "start_byte": 17196,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.update_testcase_duration",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
            "start_line": 618,
            "start_column": 20520,
            "end_line": 4,
            "end_column": 20919,
            "start_byte": 20520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_collectreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
            "start_line": 626,
            "start_column": 20925,
            "end_line": 4,
            "end_column": 21202,
            "start_byte": 20925,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_internalerror",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
            "start_line": 634,
            "start_column": 21208,
            "end_line": 4,
            "end_column": 21434,
            "start_byte": 21208,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
            "start_line": 639,
            "start_column": 21440,
            "end_line": 4,
            "end_column": 21514,
            "start_byte": 21440,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
            "start_line": 642,
            "start_column": 21520,
            "end_line": 4,
            "end_column": 22618,
            "start_byte": 21520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
            "start_line": 672,
            "start_column": 22624,
            "end_line": 4,
            "end_column": 22759,
            "start_byte": 22624,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_global_property",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
            "start_line": 675,
            "start_column": 22765,
            "end_line": 4,
            "end_column": 22957,
            "start_byte": 22765,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._get_global_properties_node",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 680,
            "start_column": 22963,
            "end_line": 4,
            "end_column": 23343,
            "start_byte": 22963,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:34:09.689232",
        "usage": "10135.5140209198 ms"
      },
      "request": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.junitxml.LogXML",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 465,
            "start_column": 15042,
            "end_line": 0,
            "end_column": 23343,
            "start_byte": 15042,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.LogXML.__init__",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
            "start_line": 466,
            "start_column": 15060,
            "end_line": 4,
            "end_column": 16111,
            "start_byte": 15060,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.finalize",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
            "start_line": 497,
            "start_column": 16117,
            "end_line": 4,
            "end_column": 16424,
            "start_byte": 16117,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.node_reporter",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
            "start_line": 505,
            "start_column": 16430,
            "end_line": 4,
            "end_column": 16945,
            "start_byte": 16430,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_stats",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
            "start_line": 523,
            "start_column": 16951,
            "end_line": 4,
            "end_column": 17039,
            "start_byte": 16951,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._opentestcase",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
            "start_line": 527,
            "start_column": 17045,
            "end_line": 4,
            "end_column": 17190,
            "start_byte": 17045,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
            "start_line": 532,
            "start_column": 17196,
            "end_line": 4,
            "end_column": 20514,
            "start_byte": 17196,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.update_testcase_duration",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
            "start_line": 618,
            "start_column": 20520,
            "end_line": 4,
            "end_column": 20919,
            "start_byte": 20520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_collectreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
            "start_line": 626,
            "start_column": 20925,
            "end_line": 4,
            "end_column": 21202,
            "start_byte": 20925,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_internalerror",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
            "start_line": 634,
            "start_column": 21208,
            "end_line": 4,
            "end_column": 21434,
            "start_byte": 21208,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
            "start_line": 639,
            "start_column": 21440,
            "end_line": 4,
            "end_column": 21514,
            "start_byte": 21440,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
            "start_line": 642,
            "start_column": 21520,
            "end_line": 4,
            "end_column": 22618,
            "start_byte": 21520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
            "start_line": 672,
            "start_column": 22624,
            "end_line": 4,
            "end_column": 22759,
            "start_byte": 22624,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_global_property",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
            "start_line": 675,
            "start_column": 22765,
            "end_line": 4,
            "end_column": 22957,
            "start_byte": 22765,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._get_global_properties_node",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 680,
            "start_column": 22963,
            "end_line": 4,
            "end_column": 23343,
            "start_byte": 22963,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1.1 The user is reporting a missing 'hostname' and 'timestamp' attribute in the JUnit XML reports generated by pytest.\n1.2 The issue is likely caused by these attributes not being added to the XML generation process.\n1.3 The user expects the 'testsuite' XML element in the pytest report to include 'hostname' and 'timestamp'.\n1.4 The expected result is for the generated XML report to conform to the JUnit report standard, including a 'hostname' and 'timestamp'.\n1.5 The issue could be fixed by modifying the XML generation logic to include 'hostname' and 'timestamp' attributes.\n\n2 Evaluate:\n2.1 Analyzing the provided symbols is crucial to identify where modifications might be needed.\n2.2 The 'LogXML.pytest_sessionfinish' method seems to handle the generation of the final XML report and includes the 'testsuite' element generation.\n2.3 Include 'hostname' and 'timestamp' attributes in the 'suite_node' creation within 'pytest_sessionfinish'.\n2.4 'hostname' can be obtained using 'socket.gethostname()' and 'timestamp' using 'datetime.datetime.now().isoformat()'.\n2.6 It seems '_pytest.junitxml.LogXML.pytest_sessionfinish' is the relative method that needs to be changed for solving the issue.",
        "symbols": [
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "reason": "This method is responsible for writing the JUnit XML output and should be extended to include 'hostname' and 'timestamp' in the 'testsuite' element."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "This class manages the JUnit XML report generation, but specific method implementation details are needed to understand where 'hostname' and 'timestamp' could be added.",
          "Initialization method, no direct effect on the reported issue, but confirms class properties.",
          "Finalizes node reports, not directly related to XML output structure.",
          "Retrieves or creates node reporters, unrelated to XML output structure.",
          "Manages test statistics, not connected with XML element attributes.",
          "Handles the opening and processing of test cases, unrelated to XML modifications needed for 'testsuite'.",
          "This method does handle XML structure but is concerned with individual test cases rather than 'testsuite' attributes.",
          "Manages duration for test cases. No direct impact on the 'testsuite' attributes.",
          "Handles collection reports, unrelated to 'testsuite' attributes in JUnit XML.",
          "Internal error logging, not related to XML structure output.",
          "Tracks session start time; could relate to timestamp but needs tying into XML output logic.",
          "Responsible for final XML output. Key place to modify for adding 'hostname' and 'timestamp' in 'testsuite'.",
          "Ends the summary of the session, unrelated to 'testsuite' XML structure.",
          "Handles global properties for XML; potentially extendable for additional global properties like 'hostname'.",
          "Returns XML properties, can be utilized if 'hostname' or 'timestamp' are treated as 'properties', though doesn't directly alter 'testsuite'."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:34:19.824771",
        "usage": "9.163856506347656 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [],
          "root_caused_symbols": [
            {
              "name": "_pytest.junitxml.LogXML",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
              "start_line": 465,
              "start_column": 15042,
              "end_line": 0,
              "end_column": 23343,
              "start_byte": 15042,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.LogXML.__init__",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
              "start_line": 466,
              "start_column": 15060,
              "end_line": 4,
              "end_column": 16111,
              "start_byte": 15060,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.finalize",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
              "start_line": 497,
              "start_column": 16117,
              "end_line": 4,
              "end_column": 16424,
              "start_byte": 16117,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.node_reporter",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
              "start_line": 505,
              "start_column": 16430,
              "end_line": 4,
              "end_column": 16945,
              "start_byte": 16430,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.add_stats",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
              "start_line": 523,
              "start_column": 16951,
              "end_line": 4,
              "end_column": 17039,
              "start_byte": 16951,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML._opentestcase",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
              "start_line": 527,
              "start_column": 17045,
              "end_line": 4,
              "end_column": 17190,
              "start_byte": 17045,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
              "start_line": 532,
              "start_column": 17196,
              "end_line": 4,
              "end_column": 20514,
              "start_byte": 17196,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.update_testcase_duration",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
              "start_line": 618,
              "start_column": 20520,
              "end_line": 4,
              "end_column": 20919,
              "start_byte": 20520,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_collectreport",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
              "start_line": 626,
              "start_column": 20925,
              "end_line": 4,
              "end_column": 21202,
              "start_byte": 20925,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_internalerror",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
              "start_line": 634,
              "start_column": 21208,
              "end_line": 4,
              "end_column": 21434,
              "start_byte": 21208,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
              "start_line": 639,
              "start_column": 21440,
              "end_line": 4,
              "end_column": 21514,
              "start_byte": 21440,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
              "start_line": 642,
              "start_column": 21520,
              "end_line": 4,
              "end_column": 22618,
              "start_byte": 21520,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
              "start_line": 672,
              "start_column": 22624,
              "end_line": 4,
              "end_column": 22759,
              "start_byte": 22624,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.add_global_property",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
              "start_line": 675,
              "start_column": 22765,
              "end_line": 4,
              "end_column": 22957,
              "start_byte": 22765,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML._get_global_properties_node",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
              "start_line": 680,
              "start_column": 22963,
              "end_line": 4,
              "end_column": 23343,
              "start_byte": 22963,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1.1 The user is reporting a missing 'hostname' and 'timestamp' attribute in the JUnit XML reports generated by pytest.\n1.2 The issue is likely caused by these attributes not being added to the XML generation process.\n1.3 The user expects the 'testsuite' XML element in the pytest report to include 'hostname' and 'timestamp'.\n1.4 The expected result is for the generated XML report to conform to the JUnit report standard, including a 'hostname' and 'timestamp'.\n1.5 The issue could be fixed by modifying the XML generation logic to include 'hostname' and 'timestamp' attributes.\n\n2 Evaluate:\n2.1 Analyzing the provided symbols is crucial to identify where modifications might be needed.\n2.2 The 'LogXML.pytest_sessionfinish' method seems to handle the generation of the final XML report and includes the 'testsuite' element generation.\n2.3 Include 'hostname' and 'timestamp' attributes in the 'suite_node' creation within 'pytest_sessionfinish'.\n2.4 'hostname' can be obtained using 'socket.gethostname()' and 'timestamp' using 'datetime.datetime.now().isoformat()'.\n2.6 It seems '_pytest.junitxml.LogXML.pytest_sessionfinish' is the relative method that needs to be changed for solving the issue.",
          "symbols": [
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
              "file_path": "src/_pytest/junitxml.py",
              "reason": "This method is responsible for writing the JUnit XML output and should be extended to include 'hostname' and 'timestamp' in the 'testsuite' element."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "This class manages the JUnit XML report generation, but specific method implementation details are needed to understand where 'hostname' and 'timestamp' could be added.",
            "Initialization method, no direct effect on the reported issue, but confirms class properties.",
            "Finalizes node reports, not directly related to XML output structure.",
            "Retrieves or creates node reporters, unrelated to XML output structure.",
            "Manages test statistics, not connected with XML element attributes.",
            "Handles the opening and processing of test cases, unrelated to XML modifications needed for 'testsuite'.",
            "This method does handle XML structure but is concerned with individual test cases rather than 'testsuite' attributes.",
            "Manages duration for test cases. No direct impact on the 'testsuite' attributes.",
            "Handles collection reports, unrelated to 'testsuite' attributes in JUnit XML.",
            "Internal error logging, not related to XML structure output.",
            "Tracks session start time; could relate to timestamp but needs tying into XML output logic.",
            "Responsible for final XML output. Key place to modify for adding 'hostname' and 'timestamp' in 'testsuite'.",
            "Ends the summary of the session, unrelated to 'testsuite' XML structure.",
            "Handles global properties for XML; potentially extendable for additional global properties like 'hostname'.",
            "Returns XML properties, can be utilized if 'hostname' or 'timestamp' are treated as 'properties', though doesn't directly alter 'testsuite'."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/junitxml.py"
        ],
        "symbols": [
          "_pytest.junitxml.LogXML.pytest_sessionfinish"
        ],
        "code_spans": {
          "_pytest.junitxml.LogXML": {
            "name": "_pytest.junitxml.LogXML",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 465,
            "start_column": 15042,
            "end_line": 0,
            "end_column": 23343,
            "start_byte": 15042,
            "end_byte": 0
          },
          "_pytest.junitxml.LogXML.__init__": {
            "name": "_pytest.junitxml.LogXML.__init__",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
            "start_line": 466,
            "start_column": 15060,
            "end_line": 4,
            "end_column": 16111,
            "start_byte": 15060,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.finalize": {
            "name": "_pytest.junitxml.LogXML.finalize",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
            "start_line": 497,
            "start_column": 16117,
            "end_line": 4,
            "end_column": 16424,
            "start_byte": 16117,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.node_reporter": {
            "name": "_pytest.junitxml.LogXML.node_reporter",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
            "start_line": 505,
            "start_column": 16430,
            "end_line": 4,
            "end_column": 16945,
            "start_byte": 16430,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.add_stats": {
            "name": "_pytest.junitxml.LogXML.add_stats",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
            "start_line": 523,
            "start_column": 16951,
            "end_line": 4,
            "end_column": 17039,
            "start_byte": 16951,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML._opentestcase": {
            "name": "_pytest.junitxml.LogXML._opentestcase",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
            "start_line": 527,
            "start_column": 17045,
            "end_line": 4,
            "end_column": 17190,
            "start_byte": 17045,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_runtest_logreport": {
            "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
            "start_line": 532,
            "start_column": 17196,
            "end_line": 4,
            "end_column": 20514,
            "start_byte": 17196,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.update_testcase_duration": {
            "name": "_pytest.junitxml.LogXML.update_testcase_duration",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
            "start_line": 618,
            "start_column": 20520,
            "end_line": 4,
            "end_column": 20919,
            "start_byte": 20520,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_collectreport": {
            "name": "_pytest.junitxml.LogXML.pytest_collectreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
            "start_line": 626,
            "start_column": 20925,
            "end_line": 4,
            "end_column": 21202,
            "start_byte": 20925,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_internalerror": {
            "name": "_pytest.junitxml.LogXML.pytest_internalerror",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
            "start_line": 634,
            "start_column": 21208,
            "end_line": 4,
            "end_column": 21434,
            "start_byte": 21208,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_sessionstart": {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
            "start_line": 639,
            "start_column": 21440,
            "end_line": 4,
            "end_column": 21514,
            "start_byte": 21440,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_sessionfinish": {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
            "start_line": 642,
            "start_column": 21520,
            "end_line": 4,
            "end_column": 22618,
            "start_byte": 21520,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_terminal_summary": {
            "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
            "start_line": 672,
            "start_column": 22624,
            "end_line": 4,
            "end_column": 22759,
            "start_byte": 22624,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.add_global_property": {
            "name": "_pytest.junitxml.LogXML.add_global_property",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
            "start_line": 675,
            "start_column": 22765,
            "end_line": 4,
            "end_column": 22957,
            "start_byte": 22765,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML._get_global_properties_node": {
            "name": "_pytest.junitxml.LogXML._get_global_properties_node",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 680,
            "start_column": 22963,
            "end_line": 4,
            "end_column": 23343,
            "start_byte": 22963,
            "end_byte": 4
          }
        }
      }
    }
  ]
}