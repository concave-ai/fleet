{
  "name": "CodeGenV0",
  "model": "gpt-4o-mini",
  "metadata": {
    "token_count": 0,
    "cost": 0
  },
  "issue": "<description>:Starting v6.2.0, unittest setUpClass fixtures are no longer \"private\"\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\nMinimal example:\r\n```\r\nimport unittest\r\n\r\nclass Tests(unittest.TestCase):\r\n    @classmethod\r\n    def setUpClass(cls):\r\n        pass\r\n\r\n    def test_1(self):\r\n        pass\r\n```\r\n```\r\n~$  pytest --fixtures\r\n...\r\nunittest_setUpClass_fixture_Tests [class scope] -- ../Platform/.venv/lib/python3.6/site-packages/_pytest/unittest.py:145\r\n    /home/ubuntu/src/Platform/.venv/lib/python3.6/site-packages/_pytest/unittest.py:145: no docstring available\r\n```\r\nThe expected (and previously implemented behavior) is that this fixture's name would start with an underscore, and would therefore only get printed if the additional `-v` flag was used. As it stands, I don't see a way to hide such generated fixtures which will not have a docstring.\r\n\r\nThis breaks a code-quality CI script that makes sure we don't have undocumented pytest fixtures (and the code-base has many legacy tests that use unittest, and that will not get upgraded).\r\n\n</description>",
  "request": {
    "related_symbols": [
      {
        "name": "add_funcarg_pseudo_fixture_def().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "def add_funcarg_pseudo_fixture_def(\n    collector: nodes.Collector, metafunc: \"Metafunc\", fixturemanager: \"FixtureManager\"\n) -> None:\n    # This function will transform all collected calls to functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        # This function call does not have direct parametrization.\n        return\n    # Collect funcargs of all callspecs into a list of values.\n    arg2params: Dict[str, List[object]] = {}\n    arg2scope: Dict[str, _Scope] = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # Register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # If we have a scope that is higher than function, we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # Use module-level collector for class-scope (for now).\n                node = collector\n        if node is None:\n            name2pseudofixturedef = None\n        else:\n            default: Dict[str, FixtureDef[Any]] = {}\n            name2pseudofixturedef = node._store.setdefault(\n                name2pseudofixturedef_key, default\n            )\n        if name2pseudofixturedef is not None and argname in name2pseudofixturedef:\n            arg2fixturedefs[argname] = [name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager=fixturemanager,\n                baseid=\"\",\n                argname=argname,\n                func=get_direct_param_fixture_func,\n                scope=arg2scope[argname],\n                params=valuelist,\n                unittest=False,\n                ids=None,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if name2pseudofixturedef is not None:"
      },
      {
        "name": "getfixturemarker().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "def getfixturemarker(obj: object) -> Optional[\"FixtureFunctionMarker\"]:\n    \"\"\"Return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        fixturemarker: Optional[FixtureFunctionMarker] = getattr(\n            obj, \"_pytestfixturefunction\", None\n        )\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None"
      },
      {
        "name": "pytest_fixture_setup().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "def pytest_fixture_setup(\n    fixturedef: FixtureDef[_FixtureValue], request: SubRequest\n) -> _FixtureValue:\n    \"\"\"Execution of fixture setup.\"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        assert fixdef.cached_result is not None\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = fixturedef.cache_key(request)\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        exc_info = sys.exc_info()\n        assert exc_info[0] is not None\n        fixturedef.cached_result = (None, my_cache_key, exc_info)\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)"
      },
      {
        "name": "main().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def main(\n    args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n    plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n) -> Union[int, ExitCode]:\n    \"\"\"Perform an in-process test run.\n\n    :param args: List of command line arguments.\n    :param plugins: List of plugin objects to be auto-registered during initialization.\n\n    :returns: An exit code.\n    \"\"\"\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = TerminalWriter(sys.stderr)\n            tw.line(f\"ImportError while loading conftest '{e.path}'.\", red=True)\n            exc_info.traceback = exc_info.traceback.filter(\n                filter_traceback_for_conftest_import_failure\n            )\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\n                    config=config\n                )\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(f\"ERROR: {msg}\\n\", red=True)"
      },
      {
        "name": "console_main().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def console_main() -> int:\n    \"\"\"The CLI entry point of pytest.\n\n    This function is not meant for programmable use; use `main()` instead.\n    \"\"\"\n    # https://docs.python.org/3/library/signal.html#note-on-sigpipe\n    try:\n        code = main()\n        sys.stdout.flush()\n        return code\n    except BrokenPipeError:\n        # Python flushes standard streams on exit; redirect remaining output\n        # to devnull to avoid another BrokenPipeError at shutdown\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())"
      },
      {
        "name": "get_config().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def get_config(\n    args: Optional[List[str]] = None,\n    plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n) -> \"Config\":\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (),\n            plugins=plugins,\n            dir=Path.cwd(),\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args, exclude_only=True)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n"
      },
      {
        "name": "PytestPluginManager#",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "@final\nclass PytestPluginManager(PluginManager):\n    \"\"\"A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\n    additional pytest-specific functionality:\n\n    * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded.\n    * ``conftest.py`` loading during start-up.\n    \"\"\"\n\n    def __init__(self) -> None:\n        import _pytest.assertion\n\n        super().__init__(\"pytest\")\n        # The objects are module objects, only used generically.\n        self._conftest_plugins: Set[types.ModuleType] = set()\n\n        # State related to local conftest plugins.\n        self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n        self._conftestpath2mod: Dict[Path, types.ModuleType] = {}\n        self._confcutdir: Optional[Path] = None\n        self._noconftest = False\n        self._duplicatepaths: Set[Path] = set()\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: List[Tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n        # pytest hooks are always prefixed with \"pytest_\",\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073).\n        if not name.startswith(\"pytest_\"):\n            return\n        # Ignore names which can not be hooks.\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # Consider only actual functions for hooks (#3775).\n        if not inspect.isroutine(method):\n            return\n\n        # Collect unmarked hooks as long as they have the `pytest_' prefix.\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name: str):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(\n        self, plugin: _PluggyPlugin, name: Optional[str] = None\n    ) -> Optional[str]:\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                    \"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return None\n        ret: Optional[str] = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name: str):\n        # Support deprecated naming because plugins (xdist e.g.) use it.\n        plugin: Optional[_PluggyPlugin] = self.get_plugin(name)\n        return plugin\n\n    def hasplugin(self, name: str) -> bool:\n        \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config: \"Config\") -> None:\n        \"\"\":meta private:\"\"\"\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers.\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # Internal API for local conftest plugin handling.\n    #\n    def _set_initial_conftests(self, namespace: argparse.Namespace) -> None:\n        \"\"\"Load initial conftest files given a preparsed \"namespace\".\n\n        As conftest files may add their own command line options which have\n        arguments ('--my-opt somepath') we might get some false positives.\n        All builtin and 3rd party plugins will have been loaded, however, so\n        common options will not confuse our logic here.\n        \"\"\"\n        current = Path.cwd()\n        self._confcutdir = (\n            absolutepath(current / namespace.confcutdir)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for testpath in testpaths:\n            path = str(testpath)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = absolutepath(current / path)\n            if anchor.exists():  # we found some file object\n                self._try_load_conftest(anchor, namespace.importmode)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current, namespace.importmode)\n\n    def _try_load_conftest(\n        self, anchor: Path, importmode: Union[str, ImportMode]\n    ) -> None:\n        self._getconftestmodules(anchor, importmode)\n        # let's also consider test* subdirs\n        if anchor.is_dir():\n            for x in anchor.glob(\"test*\"):\n                if x.is_dir():\n                    self._getconftestmodules(x, importmode)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(\n        self,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> List[types.ModuleType]:\n        if self._noconftest:\n            return []\n\n        if path.is_file():\n            directory = path.parent\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootpath\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir.\n        clist = []\n        for parent in reversed((directory, *directory.parents)):\n            if self._confcutdir and parent in self._confcutdir.parents:\n                continue\n            conftestpath = parent / \"conftest.py\"\n            if conftestpath.is_file():\n                mod = self._importconftest(conftestpath, importmode)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(\n        self,\n        name: str,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> Tuple[types.ModuleType, Any]:\n        modules = self._getconftestmodules(path, importmode)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(\n        self,\n        conftestpath: Path,\n        importmode: Union[str, ImportMode],\n    ) -> types.ModuleType:\n        # Use a resolved Path object as key to avoid loading the same conftest\n        # twice with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = conftestpath.resolve()\n\n        with contextlib.suppress(KeyError):\n            return self._conftestpath2mod[key]\n\n        pkgpath = resolve_package_path(conftestpath)\n        if pkgpath is None:\n            _ensure_removed_sysmodule(conftestpath.stem)\n\n        try:\n            mod = import_path(conftestpath, mode=importmode)\n        except Exception as e:\n            assert e.__traceback__ is not None\n            exc_info = (type(e), e, e.__traceback__)\n            raise ConftestImportFailure(conftestpath, exc_info) from e\n\n        self._check_non_top_pytest_plugins(mod, conftestpath)\n\n        self._conftest_plugins.add(mod)\n        self._conftestpath2mod[key] = mod\n        dirpath = conftestpath.parent\n        if dirpath in self._dirpath2confmods:\n            for path, mods in self._dirpath2confmods.items():\n                if path and dirpath in path.parents or path == dirpath:\n                    assert mod not in mods\n                    mods.append(mod)\n        self.trace(f\"loading conftestmodule {mod!r}\")\n        self.consider_conftest(mod)\n        return mod\n\n    def _check_non_top_pytest_plugins(\n        self,\n        mod: types.ModuleType,\n        conftestpath: Path,\n    ) -> None:\n        if (\n            hasattr(mod, \"pytest_plugins\")\n            and self._configured\n            and not self._using_pyargs\n        ):\n            msg = (\n                \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n                \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n                \"  {}\\n\"\n                \"Please move it to a top level conftest file at the rootdir:\\n\"\n                \"  {}\\n\"\n                \"For more information, visit:\\n\"\n                \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n            )\n            fail(msg.format(conftestpath, self._confcutdir), pytrace=False)\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(\n        self, args: Sequence[str], *, exclude_only: bool = False\n    ) -> None:\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                if exclude_only and not parg.startswith(\"no:\"):\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg: str) -> None:\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304: remove stepwise if cacheprovider is blocked.\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule: types.ModuleType) -> None:\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self) -> None:\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod: types.ModuleType) -> None:\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(\n        self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n    ) -> None:\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n        \"\"\"Import a plugin with ``modname``.\n\n        If ``consider_entry_points`` is True, entry point names are also\n        considered to find a plugin.\n        \"\"\"\n        # Most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            raise ImportError(\n                'Error importing plugin \"{}\": {}'.format(modname, str(e.args[0]))\n            ).with_traceback(e.__traceback__) from e\n\n        except Skipped as e:\n            self.skipped_plugins.append((modname, e.msg or \"\"))\n        else:\n            mod = sys.modules[importspec]"
      },
      {
        "name": "PytestPluginManager#__init__().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def __init__(self) -> None:\n        import _pytest.assertion\n\n        super().__init__(\"pytest\")\n        # The objects are module objects, only used generically.\n        self._conftest_plugins: Set[types.ModuleType] = set()\n\n        # State related to local conftest plugins.\n        self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n        self._conftestpath2mod: Dict[Path, types.ModuleType] = {}\n        self._confcutdir: Optional[Path] = None\n        self._noconftest = False\n        self._duplicatepaths: Set[Path] = set()\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: List[Tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage."
      },
      {
        "name": "PytestPluginManager#parse_hookimpl_opts().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n        # pytest hooks are always prefixed with \"pytest_\",\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073).\n        if not name.startswith(\"pytest_\"):\n            return\n        # Ignore names which can not be hooks.\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # Consider only actual functions for hooks (#3775).\n        if not inspect.isroutine(method):\n            return\n\n        # Collect unmarked hooks as long as they have the `pytest_' prefix.\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)"
      },
      {
        "name": "PytestPluginManager#parse_hookspec_opts().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def parse_hookspec_opts(self, module_or_class, name: str):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }"
      },
      {
        "name": "PytestPluginManager#register().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def register(\n        self, plugin: _PluggyPlugin, name: Optional[str] = None\n    ) -> Optional[str]:\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                    \"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return None\n        ret: Optional[str] = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)"
      },
      {
        "name": "PytestPluginManager#getplugin().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def getplugin(self, name: str):\n        # Support deprecated naming because plugins (xdist e.g.) use it.\n        plugin: Optional[_PluggyPlugin] = self.get_plugin(name)"
      },
      {
        "name": "PytestPluginManager#hasplugin().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def hasplugin(self, name: str) -> bool:\n        \"\"\"Return whether a plugin with the given name is registered.\"\"\""
      },
      {
        "name": "PytestPluginManager#pytest_configure().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def pytest_configure(self, config: \"Config\") -> None:\n        \"\"\":meta private:\"\"\"\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers.\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )"
      },
      {
        "name": "PytestPluginManager#_set_initial_conftests().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _set_initial_conftests(self, namespace: argparse.Namespace) -> None:\n        \"\"\"Load initial conftest files given a preparsed \"namespace\".\n\n        As conftest files may add their own command line options which have\n        arguments ('--my-opt somepath') we might get some false positives.\n        All builtin and 3rd party plugins will have been loaded, however, so\n        common options will not confuse our logic here.\n        \"\"\"\n        current = Path.cwd()\n        self._confcutdir = (\n            absolutepath(current / namespace.confcutdir)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for testpath in testpaths:\n            path = str(testpath)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = absolutepath(current / path)\n            if anchor.exists():  # we found some file object\n                self._try_load_conftest(anchor, namespace.importmode)\n                foundanchor = True\n        if not foundanchor:"
      },
      {
        "name": "PytestPluginManager#_try_load_conftest().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _try_load_conftest(\n        self, anchor: Path, importmode: Union[str, ImportMode]\n    ) -> None:\n        self._getconftestmodules(anchor, importmode)\n        # let's also consider test* subdirs\n        if anchor.is_dir():\n            for x in anchor.glob(\"test*\"):\n                if x.is_dir():"
      },
      {
        "name": "PytestPluginManager#_getconftestmodules().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @lru_cache(maxsize=128)\n    def _getconftestmodules(\n        self,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> List[types.ModuleType]:\n        if self._noconftest:\n            return []\n\n        if path.is_file():\n            directory = path.parent\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootpath\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir.\n        clist = []\n        for parent in reversed((directory, *directory.parents)):\n            if self._confcutdir and parent in self._confcutdir.parents:\n                continue\n            conftestpath = parent / \"conftest.py\"\n            if conftestpath.is_file():\n                mod = self._importconftest(conftestpath, importmode)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist"
      },
      {
        "name": "PytestPluginManager#_rget_with_confmod().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _rget_with_confmod(\n        self,\n        name: str,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> Tuple[types.ModuleType, Any]:\n        modules = self._getconftestmodules(path, importmode)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue"
      },
      {
        "name": "PytestPluginManager#_importconftest().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _importconftest(\n        self,\n        conftestpath: Path,\n        importmode: Union[str, ImportMode],\n    ) -> types.ModuleType:\n        # Use a resolved Path object as key to avoid loading the same conftest\n        # twice with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = conftestpath.resolve()\n\n        with contextlib.suppress(KeyError):\n            return self._conftestpath2mod[key]\n\n        pkgpath = resolve_package_path(conftestpath)\n        if pkgpath is None:\n            _ensure_removed_sysmodule(conftestpath.stem)\n\n        try:\n            mod = import_path(conftestpath, mode=importmode)\n        except Exception as e:\n            assert e.__traceback__ is not None\n            exc_info = (type(e), e, e.__traceback__)\n            raise ConftestImportFailure(conftestpath, exc_info) from e\n\n        self._check_non_top_pytest_plugins(mod, conftestpath)\n\n        self._conftest_plugins.add(mod)\n        self._conftestpath2mod[key] = mod\n        dirpath = conftestpath.parent\n        if dirpath in self._dirpath2confmods:\n            for path, mods in self._dirpath2confmods.items():\n                if path and dirpath in path.parents or path == dirpath:\n                    assert mod not in mods\n                    mods.append(mod)\n        self.trace(f\"loading conftestmodule {mod!r}\")\n        self.consider_conftest(mod)"
      },
      {
        "name": "PytestPluginManager#_check_non_top_pytest_plugins().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _check_non_top_pytest_plugins(\n        self,\n        mod: types.ModuleType,\n        conftestpath: Path,\n    ) -> None:\n        if (\n            hasattr(mod, \"pytest_plugins\")\n            and self._configured\n            and not self._using_pyargs\n        ):\n            msg = (\n                \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n                \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n                \"  {}\\n\"\n                \"Please move it to a top level conftest file at the rootdir:\\n\"\n                \"  {}\\n\"\n                \"For more information, visit:\\n\"\n                \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n            )"
      },
      {
        "name": "PytestPluginManager#consider_preparse().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def consider_preparse(\n        self, args: Sequence[str], *, exclude_only: bool = False\n    ) -> None:\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                if exclude_only and not parg.startswith(\"no:\"):\n                    continue"
      },
      {
        "name": "PytestPluginManager#consider_pluginarg().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def consider_pluginarg(self, arg: str) -> None:\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304: remove stepwise if cacheprovider is blocked.\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]"
      },
      {
        "name": "PytestPluginManager#consider_conftest().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def consider_conftest(self, conftestmodule: types.ModuleType) -> None:"
      },
      {
        "name": "PytestPluginManager#consider_env().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def consider_env(self) -> None:"
      },
      {
        "name": "PytestPluginManager#consider_module().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def consider_module(self, mod: types.ModuleType) -> None:"
      },
      {
        "name": "PytestPluginManager#_import_plugin_specs().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _import_plugin_specs(\n        self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n    ) -> None:\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:"
      },
      {
        "name": "PytestPluginManager#import_plugin().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n        \"\"\"Import a plugin with ``modname``.\n\n        If ``consider_entry_points`` is True, entry point names are also\n        considered to find a plugin.\n        \"\"\"\n        # Most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            raise ImportError(\n                'Error importing plugin \"{}\": {}'.format(modname, str(e.args[0]))\n            ).with_traceback(e.__traceback__) from e\n\n        except Skipped as e:\n            self.skipped_plugins.append((modname, e.msg or \"\"))\n        else:\n            mod = sys.modules[importspec]"
      },
      {
        "name": "Config#",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "@final\nclass Config:\n    \"\"\"Access to configuration values, pluginmanager and plugin hooks.\n\n    :param PytestPluginManager pluginmanager:\n\n    :param InvocationParams invocation_params:\n        Object containing parameters regarding the :func:`pytest.main`\n        invocation.\n    \"\"\"\n\n    @final\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during :func:`pytest.main`.\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(type=Tuple[str, ...], converter=_args_converter)\n        \"\"\"The command-line arguments as passed to :func:`pytest.main`.\n\n        :type: Tuple[str, ...]\n        \"\"\"\n        plugins = attr.ib(type=Optional[Sequence[Union[str, _PluggyPlugin]]])\n        \"\"\"Extra plugins, might be `None`.\n\n        :type: Optional[Sequence[Union[str, plugin]]]\n        \"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"The directory from which :func:`pytest.main` was invoked.\n\n        :type: pathlib.Path\n        \"\"\"\n\n    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None,\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path.cwd()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"Access to command line option as attributes.\n\n        :type: argparse.Namespace\n        \"\"\"\n\n        self.invocation_params = invocation_params\n        \"\"\"The parameters with which pytest was invoked.\n\n        :type: InvocationParams\n        \"\"\"\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"The plugin manager handles plugin registration and hook invocation.\n\n        :type: PytestPluginManager\n        \"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache: Dict[str, Any] = {}\n        self._override_ini: Sequence[str] = ()\n        self._opt2dest: Dict[str, str] = {}\n        self._cleanup: List[Callable[[], None]] = []\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n\n            self.cache: Optional[Cache] = None\n\n    @property\n    def invocation_dir(self) -> py.path.local:\n        \"\"\"The directory from which pytest was invoked.\n\n        Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,\n        which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    @property\n    def rootpath(self) -> Path:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        :type: pathlib.Path\n\n        .. versionadded:: 6.1\n        \"\"\"\n        return self._rootpath\n\n    @property\n    def rootdir(self) -> py.path.local:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\"\n        return py.path.local(str(self.rootpath))\n\n    @property\n    def inipath(self) -> Optional[Path]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        :type: Optional[pathlib.Path]\n\n        .. versionadded:: 6.1\n        \"\"\"\n        return self._inipath\n\n    @property\n    def inifile(self) -> Optional[py.path.local]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.\n\n        :type: Optional[py.path.local]\n        \"\"\"\n        return py.path.local(str(self.inipath)) if self.inipath else None\n\n    def add_cleanup(self, func: Callable[[], None]) -> None:\n        \"\"\"Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self) -> None:\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self) -> None:\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self) -> TerminalWriter:\n        terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n            \"terminalreporter\"\n        )\n        return terminalreporter._tw\n\n    def pytest_cmdline_parse(\n        self, pluginmanager: PytestPluginManager, args: List[str]\n    ) -> \"Config\":\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n\n        return self\n\n    def notify_exception(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        option: Optional[argparse.Namespace] = None,\n    ) -> None:\n        if option and getattr(option, \"fulltrace\", False):\n            style: _TracebackStyle = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n                sys.stderr.flush()\n\n    def cwd_relative_nodeid(self, nodeid: str) -> str:\n        # nodeid's are relative to the rootpath, compute relative to cwd.\n        if self.invocation_params.dir != self.rootpath:\n            fullpath = self.rootpath / nodeid\n            nodeid = bestrelpath(self.invocation_params.dir, fullpath)\n        return nodeid\n\n    @classmethod\n    def fromdictargs(cls, option_dict, args) -> \"Config\":\n        \"\"\"Constructor usable for subprocesses.\"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)\n        return config\n\n    def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):\n                setattr(self.option, opt.dest, opt.default)\n\n    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:\n        self.pluginmanager._set_initial_conftests(early_config.known_args_namespace)\n\n    def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        rootpath, inipath, inicfg = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self._rootpath = rootpath\n        self._inipath = inipath\n        self.inicfg = inicfg\n        self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n        self._parser.extra_info[\"inifile\"] = str(self.inipath)\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._parser.addini(\n            \"required_plugins\",\n            \"plugins that must be present for pytest to run\",\n            type=\"args\",\n            default=[],\n        )\n        self._override_ini = ns.override_ini or ()\n\n    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)\n        self._warn_about_missing_assertion(mode)\n\n    def _mark_plugins_for_rewrite(self, hook) -> None:\n        \"\"\"Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):\n            hook.mark_rewrite(name)\n\n    def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n\n        return args\n\n    def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.known_args_namespace)\n        )\n\n        self._validate_plugins()\n        self._warn_about_skipped_plugins()\n\n        if self.known_args_namespace.strict:\n            self.issue_config_time_warning(\n                _pytest.deprecated.STRICT_OPTION, stacklevel=2\n            )\n\n        if self.known_args_namespace.confcutdir is None and self.inipath is not None:\n            confcutdir = str(self.inipath.parent)\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if self.known_args_namespace.help or self.known_args_namespace.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                self.issue_config_time_warning(\n                    PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n                    stacklevel=2,\n                )\n            else:\n                raise\n\n    @hookimpl(hookwrapper=True)\n    def pytest_collection(self) -> Generator[None, None, None]:\n        \"\"\"Validate invalid ini keys after collection is done so we take in account\n        options added by late-loading conftest files.\"\"\"\n        yield\n        self._validate_config_options()\n\n    def _checkversion(self) -> None:\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            # Imported lazily to improve start-up time.\n            from packaging.version import Version\n\n            if not isinstance(minver, str):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' must be a single value\" % self.inipath\n                )\n\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inipath,\n                        minver,\n                        pytest.__version__,\n                    )\n                )\n\n    def _validate_config_options(self) -> None:\n        for key in sorted(self._get_unknown_ini_keys()):\n            self._warn_or_fail_if_strict(f\"Unknown config option: {key}\\n\")\n\n    def _validate_plugins(self) -> None:\n        required_plugins = sorted(self.getini(\"required_plugins\"))\n        if not required_plugins:\n            return\n\n        # Imported lazily to improve start-up time.\n        from packaging.version import Version\n        from packaging.requirements import InvalidRequirement, Requirement\n\n        plugin_info = self.pluginmanager.list_plugin_distinfo()\n        plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n\n        missing_plugins = []\n        for required_plugin in required_plugins:\n            try:\n                spec = Requirement(required_plugin)\n            except InvalidRequirement:\n                missing_plugins.append(required_plugin)\n                continue\n\n            if spec.name not in plugin_dist_info:\n                missing_plugins.append(required_plugin)\n            elif Version(plugin_dist_info[spec.name]) not in spec.specifier:\n                missing_plugins.append(required_plugin)\n\n        if missing_plugins:\n            raise UsageError(\n                \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),\n            )\n\n    def _warn_or_fail_if_strict(self, message: str) -> None:\n        if self.known_args_namespace.strict_config:\n            raise UsageError(message)\n\n        self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)\n\n    def _get_unknown_ini_keys(self) -> List[str]:\n        parser_inicfg = self._parser._inidict\n        return [name for name in self.inicfg if name not in parser_inicfg]\n\n    def parse(self, args: List[str], addopts: bool = True) -> None:\n        # Parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_params.dir == self.rootpath:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_params.dir)]\n            self.args = args\n        except PrintHelp:\n            pass\n\n    def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n        \"\"\"Issue and handle a warning during the \"configure\" stage.\n\n        During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n        function because it is not possible to have hookwrappers around ``pytest_configure``.\n\n        This function is mainly intended for plugins that need to issue warnings during\n        ``pytest_configure`` (or similar stages).\n\n        :param warning: The warning instance.\n        :param stacklevel: stacklevel forwarded to warnings.warn.\n        \"\"\"\n        if self.pluginmanager.is_blocked(\"warnings\"):\n            return\n\n        cmdline_filters = self.known_args_namespace.pythonwarnings or []\n        config_filters = self.getini(\"filterwarnings\")\n\n        with warnings.catch_warnings(record=True) as records:\n            warnings.simplefilter(\"always\", type(warning))\n            apply_warning_filters(config_filters, cmdline_filters)\n            warnings.warn(warning, stacklevel=stacklevel)\n\n        if records:\n            frame = sys._getframe(stacklevel - 1)\n            location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n            self.hook.pytest_warning_captured.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    item=None,\n                    location=location,\n                )\n            )\n            self.hook.pytest_warning_recorded.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    nodeid=\"\",\n                    location=location,\n                )\n            )\n\n    def addinivalue_line(self, name: str, line: str) -> None:\n        \"\"\"Add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes\n        the first line in its value.\"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)\n        x.append(line)  # modifies the cached list inline\n\n    def getini(self, name: str):\n        \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n\n        If the specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised.\n        \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)\n            return val\n\n    def _getini(self, name: str):\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError as e:\n            raise ValueError(f\"unknown configuration value: {name!r}\") from e\n        override_value = self._get_override_ini_value(name)\n        if override_value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        else:\n            value = override_value\n        # Coerce the values based on types.\n        #\n        # Note: some coercions are only required if we are reading from .ini files, because\n        # the file format doesn't contain type information, but when reading from toml we will\n        # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n        # For example:\n        #\n        #   ini:\n        #     a_line_list = \"tests acceptance\"\n        #   in this case, we need to split the string to obtain a list of strings.\n        #\n        #   toml:\n        #     a_line_list = [\"tests\", \"acceptance\"]\n        #   in this case, we already have a list ready to use.\n        #\n        if type == \"pathlist\":\n            # TODO: This assert is probably not valid in all cases.\n            assert self.inipath is not None\n            dp = self.inipath.parent\n            input_values = shlex.split(value) if isinstance(value, str) else value\n            return [py.path.local(str(dp / x)) for x in input_values]\n        elif type == \"args\":\n            return shlex.split(value) if isinstance(value, str) else value\n        elif type == \"linelist\":\n            if isinstance(value, str):\n                return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n            else:\n                return value\n        elif type == \"bool\":\n            return _strtobool(str(value).strip())\n        else:\n            assert type in [None, \"string\"]\n            return value\n\n    def _getconftest_pathlist(self, name: str, path: Path) -> Optional[List[Path]]:\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(\n                name, path, self.getoption(\"importmode\")\n            )\n        except KeyError:\n            return None\n        modpath = Path(mod.__file__).parent\n        values: List[Path] = []\n        for relroot in relroots:\n            if isinstance(relroot, Path):\n                pass\n            elif isinstance(relroot, py.path.local):\n                relroot = Path(relroot)\n            else:\n                relroot = relroot.replace(\"/\", os.sep)\n                relroot = absolutepath(modpath / relroot)\n            values.append(relroot)\n        return values\n\n    def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options.\n        # Always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError as e:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                ) from e\n            else:\n                if key == name:\n                    value = user_ini_value\n        return value\n\n    def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\"Return command line option value.\n\n        :param name: Name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :param default: Default value if no option of that name exists.\n        :param skip: If True, raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError as e:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(f\"no {name!r} option found\")\n            raise ValueError(f\"no option named {name!r}\") from e\n\n    def getvalue(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption() instead.\"\"\"\n        return self.getoption(name)\n\n    def getvalueorskip(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\"\n        return self.getoption(name, skip=True)\n\n    def _warn_about_missing_assertion(self, mode: str) -> None:\n        if not _assertion_supported():\n            if mode == \"plain\":\n                warning_text = (\n                    \"ASSERTIONS ARE NOT EXECUTED\"\n                    \" and FAILING TESTS WILL PASS.  Are you\"\n                    \" using python -O?\"\n                )\n            else:\n                warning_text = (\n                    \"assertions not in test modules or\"\n                    \" plugins will be ignored\"\n                    \" because assert statements are not executed \"\n                    \"by the underlying Python interpreter \"\n                    \"(are you using python -O?)\\n\"\n                )\n            self.issue_config_time_warning(\n                PytestConfigWarning(warning_text),\n                stacklevel=3,\n            )\n\n    def _warn_about_skipped_plugins(self) -> None:\n        for module_name, msg in self.pluginmanager.skipped_plugins:\n            self.issue_config_time_warning(\n                PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n                stacklevel=2,"
      },
      {
        "name": "Config#InvocationParams#",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @final\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during :func:`pytest.main`.\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(type=Tuple[str, ...], converter=_args_converter)\n        \"\"\"The command-line arguments as passed to :func:`pytest.main`.\n\n        :type: Tuple[str, ...]\n        \"\"\"\n        plugins = attr.ib(type=Optional[Sequence[Union[str, _PluggyPlugin]]])\n        \"\"\"Extra plugins, might be `None`.\n\n        :type: Optional[Sequence[Union[str, plugin]]]\n        \"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"The directory from which :func:`pytest.main` was invoked.\n\n        :type: pathlib.Path"
      },
      {
        "name": "Config#__init__().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None,\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path.cwd()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"Access to command line option as attributes.\n\n        :type: argparse.Namespace\n        \"\"\"\n\n        self.invocation_params = invocation_params\n        \"\"\"The parameters with which pytest was invoked.\n\n        :type: InvocationParams\n        \"\"\"\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"The plugin manager handles plugin registration and hook invocation.\n\n        :type: PytestPluginManager\n        \"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache: Dict[str, Any] = {}\n        self._override_ini: Sequence[str] = ()\n        self._opt2dest: Dict[str, str] = {}\n        self._cleanup: List[Callable[[], None]] = []\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n"
      },
      {
        "name": "Config#invocation_dir().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @property\n    def invocation_dir(self) -> py.path.local:\n        \"\"\"The directory from which pytest was invoked.\n\n        Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,\n        which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\""
      },
      {
        "name": "Config#rootpath().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @property\n    def rootpath(self) -> Path:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        :type: pathlib.Path\n\n        .. versionadded:: 6.1\n        \"\"\""
      },
      {
        "name": "Config#rootdir().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @property\n    def rootdir(self) -> py.path.local:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\""
      },
      {
        "name": "Config#inipath().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @property\n    def inipath(self) -> Optional[Path]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        :type: Optional[pathlib.Path]\n\n        .. versionadded:: 6.1\n        \"\"\""
      },
      {
        "name": "Config#inifile().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @property\n    def inifile(self) -> Optional[py.path.local]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.\n\n        :type: Optional[py.path.local]\n        \"\"\""
      },
      {
        "name": "Config#add_cleanup().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def add_cleanup(self, func: Callable[[], None]) -> None:\n        \"\"\"Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\""
      },
      {
        "name": "Config#_do_configure().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _do_configure(self) -> None:\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")"
      },
      {
        "name": "Config#_ensure_unconfigure().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _ensure_unconfigure(self) -> None:\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()"
      },
      {
        "name": "Config#get_terminal_writer().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def get_terminal_writer(self) -> TerminalWriter:\n        terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n            \"terminalreporter\"\n        )"
      },
      {
        "name": "Config#pytest_cmdline_parse().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def pytest_cmdline_parse(\n        self, pluginmanager: PytestPluginManager, args: List[str]\n    ) -> \"Config\":\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n"
      },
      {
        "name": "Config#notify_exception().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def notify_exception(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        option: Optional[argparse.Namespace] = None,\n    ) -> None:\n        if option and getattr(option, \"fulltrace\", False):\n            style: _TracebackStyle = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)"
      },
      {
        "name": "Config#cwd_relative_nodeid().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def cwd_relative_nodeid(self, nodeid: str) -> str:\n        # nodeid's are relative to the rootpath, compute relative to cwd.\n        if self.invocation_params.dir != self.rootpath:\n            fullpath = self.rootpath / nodeid\n            nodeid = bestrelpath(self.invocation_params.dir, fullpath)"
      },
      {
        "name": "Config#fromdictargs().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @classmethod\n    def fromdictargs(cls, option_dict, args) -> \"Config\":\n        \"\"\"Constructor usable for subprocesses.\"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)"
      },
      {
        "name": "Config#_processopt().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):"
      },
      {
        "name": "Config#pytest_load_initial_conftests().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:"
      },
      {
        "name": "Config#_initini().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        rootpath, inipath, inicfg = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self._rootpath = rootpath\n        self._inipath = inipath\n        self.inicfg = inicfg\n        self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n        self._parser.extra_info[\"inifile\"] = str(self.inipath)\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._parser.addini(\n            \"required_plugins\",\n            \"plugins that must be present for pytest to run\",\n            type=\"args\",\n            default=[],\n        )"
      },
      {
        "name": "Config#_consider_importhook().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)"
      },
      {
        "name": "Config#_mark_plugins_for_rewrite().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _mark_plugins_for_rewrite(self, hook) -> None:\n        \"\"\"Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):"
      },
      {
        "name": "Config#_validate_args().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n"
      },
      {
        "name": "Config#_preparse().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.known_args_namespace)\n        )\n\n        self._validate_plugins()\n        self._warn_about_skipped_plugins()\n\n        if self.known_args_namespace.strict:\n            self.issue_config_time_warning(\n                _pytest.deprecated.STRICT_OPTION, stacklevel=2\n            )\n\n        if self.known_args_namespace.confcutdir is None and self.inipath is not None:\n            confcutdir = str(self.inipath.parent)\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if self.known_args_namespace.help or self.known_args_namespace.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                self.issue_config_time_warning(\n                    PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n                    stacklevel=2,\n                )\n            else:"
      },
      {
        "name": "Config#pytest_collection().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    @hookimpl(hookwrapper=True)\n    def pytest_collection(self) -> Generator[None, None, None]:\n        \"\"\"Validate invalid ini keys after collection is done so we take in account\n        options added by late-loading conftest files.\"\"\"\n        yield"
      },
      {
        "name": "Config#_checkversion().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _checkversion(self) -> None:\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            # Imported lazily to improve start-up time.\n            from packaging.version import Version\n\n            if not isinstance(minver, str):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' must be a single value\" % self.inipath\n                )\n\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inipath,\n                        minver,\n                        pytest.__version__,\n                    )"
      },
      {
        "name": "Config#_validate_config_options().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _validate_config_options(self) -> None:\n        for key in sorted(self._get_unknown_ini_keys()):"
      },
      {
        "name": "Config#_validate_plugins().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _validate_plugins(self) -> None:\n        required_plugins = sorted(self.getini(\"required_plugins\"))\n        if not required_plugins:\n            return\n\n        # Imported lazily to improve start-up time.\n        from packaging.version import Version\n        from packaging.requirements import InvalidRequirement, Requirement\n\n        plugin_info = self.pluginmanager.list_plugin_distinfo()\n        plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n\n        missing_plugins = []\n        for required_plugin in required_plugins:\n            try:\n                spec = Requirement(required_plugin)\n            except InvalidRequirement:\n                missing_plugins.append(required_plugin)\n                continue\n\n            if spec.name not in plugin_dist_info:\n                missing_plugins.append(required_plugin)\n            elif Version(plugin_dist_info[spec.name]) not in spec.specifier:\n                missing_plugins.append(required_plugin)\n\n        if missing_plugins:\n            raise UsageError(\n                \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),"
      },
      {
        "name": "Config#_warn_or_fail_if_strict().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _warn_or_fail_if_strict(self, message: str) -> None:\n        if self.known_args_namespace.strict_config:\n            raise UsageError(message)\n"
      },
      {
        "name": "Config#_get_unknown_ini_keys().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _get_unknown_ini_keys(self) -> List[str]:\n        parser_inicfg = self._parser._inidict"
      },
      {
        "name": "Config#parse().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def parse(self, args: List[str], addopts: bool = True) -> None:\n        # Parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_params.dir == self.rootpath:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_params.dir)]\n            self.args = args\n        except PrintHelp:"
      },
      {
        "name": "Config#issue_config_time_warning().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n        \"\"\"Issue and handle a warning during the \"configure\" stage.\n\n        During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n        function because it is not possible to have hookwrappers around ``pytest_configure``.\n\n        This function is mainly intended for plugins that need to issue warnings during\n        ``pytest_configure`` (or similar stages).\n\n        :param warning: The warning instance.\n        :param stacklevel: stacklevel forwarded to warnings.warn.\n        \"\"\"\n        if self.pluginmanager.is_blocked(\"warnings\"):\n            return\n\n        cmdline_filters = self.known_args_namespace.pythonwarnings or []\n        config_filters = self.getini(\"filterwarnings\")\n\n        with warnings.catch_warnings(record=True) as records:\n            warnings.simplefilter(\"always\", type(warning))\n            apply_warning_filters(config_filters, cmdline_filters)\n            warnings.warn(warning, stacklevel=stacklevel)\n\n        if records:\n            frame = sys._getframe(stacklevel - 1)\n            location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n            self.hook.pytest_warning_captured.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    item=None,\n                    location=location,\n                )\n            )\n            self.hook.pytest_warning_recorded.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    nodeid=\"\",\n                    location=location,\n                )"
      },
      {
        "name": "Config#addinivalue_line().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def addinivalue_line(self, name: str, line: str) -> None:\n        \"\"\"Add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes\n        the first line in its value.\"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)"
      },
      {
        "name": "Config#getini().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def getini(self, name: str):\n        \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n\n        If the specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised.\n        \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)"
      },
      {
        "name": "Config#_getini().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _getini(self, name: str):\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError as e:\n            raise ValueError(f\"unknown configuration value: {name!r}\") from e\n        override_value = self._get_override_ini_value(name)\n        if override_value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        else:\n            value = override_value\n        # Coerce the values based on types.\n        #\n        # Note: some coercions are only required if we are reading from .ini files, because\n        # the file format doesn't contain type information, but when reading from toml we will\n        # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n        # For example:\n        #\n        #   ini:\n        #     a_line_list = \"tests acceptance\"\n        #   in this case, we need to split the string to obtain a list of strings.\n        #\n        #   toml:\n        #     a_line_list = [\"tests\", \"acceptance\"]\n        #   in this case, we already have a list ready to use.\n        #\n        if type == \"pathlist\":\n            # TODO: This assert is probably not valid in all cases.\n            assert self.inipath is not None\n            dp = self.inipath.parent\n            input_values = shlex.split(value) if isinstance(value, str) else value\n            return [py.path.local(str(dp / x)) for x in input_values]\n        elif type == \"args\":\n            return shlex.split(value) if isinstance(value, str) else value\n        elif type == \"linelist\":\n            if isinstance(value, str):\n                return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n            else:\n                return value\n        elif type == \"bool\":\n            return _strtobool(str(value).strip())\n        else:\n            assert type in [None, \"string\"]"
      },
      {
        "name": "Config#_getconftest_pathlist().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _getconftest_pathlist(self, name: str, path: Path) -> Optional[List[Path]]:\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(\n                name, path, self.getoption(\"importmode\")\n            )\n        except KeyError:\n            return None\n        modpath = Path(mod.__file__).parent\n        values: List[Path] = []\n        for relroot in relroots:\n            if isinstance(relroot, Path):\n                pass\n            elif isinstance(relroot, py.path.local):\n                relroot = Path(relroot)\n            else:\n                relroot = relroot.replace(\"/\", os.sep)\n                relroot = absolutepath(modpath / relroot)\n            values.append(relroot)"
      },
      {
        "name": "Config#_get_override_ini_value().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options.\n        # Always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError as e:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                ) from e\n            else:\n                if key == name:\n                    value = user_ini_value"
      },
      {
        "name": "Config#getoption().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\"Return command line option value.\n\n        :param name: Name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :param default: Default value if no option of that name exists.\n        :param skip: If True, raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError as e:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(f\"no {name!r} option found\")"
      },
      {
        "name": "Config#getvalue().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def getvalue(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption() instead.\"\"\""
      },
      {
        "name": "Config#getvalueorskip().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def getvalueorskip(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\""
      },
      {
        "name": "Config#_warn_about_missing_assertion().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _warn_about_missing_assertion(self, mode: str) -> None:\n        if not _assertion_supported():\n            if mode == \"plain\":\n                warning_text = (\n                    \"ASSERTIONS ARE NOT EXECUTED\"\n                    \" and FAILING TESTS WILL PASS.  Are you\"\n                    \" using python -O?\"\n                )\n            else:\n                warning_text = (\n                    \"assertions not in test modules or\"\n                    \" plugins will be ignored\"\n                    \" because assert statements are not executed \"\n                    \"by the underlying Python interpreter \"\n                    \"(are you using python -O?)\\n\"\n                )\n            self.issue_config_time_warning(\n                PytestConfigWarning(warning_text),\n                stacklevel=3,"
      },
      {
        "name": "Config#_warn_about_skipped_plugins().",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    def _warn_about_skipped_plugins(self) -> None:\n        for module_name, msg in self.pluginmanager.skipped_plugins:\n            self.issue_config_time_warning(\n                PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n                stacklevel=2,"
      }
    ],
    "root_caused_symbols": [
      {
        "name": "UnitTestCase#",
        "file_path": "src/_pytest/unittest.py",
        "file_content": "class UnitTestCase(Class):\n    # Marker for fixturemanger.getfixtureinfo()\n    # to declare that our children do not support funcargs.\n    nofuncargs = True\n\n    def collect(self) -> Iterable[Union[Item, Collector]]:\n        from unittest import TestLoader\n\n        cls = self.obj\n        if not getattr(cls, \"__test__\", True):\n            return\n\n        skipped = _is_skipped(cls)\n        if not skipped:\n            self._inject_setup_teardown_fixtures(cls)\n            self._inject_setup_class_fixture()\n\n        self.session._fixturemanager.parsefactories(self, unittest=True)\n        loader = TestLoader()\n        foundsomething = False\n        for name in loader.getTestCaseNames(self.obj):\n            x = getattr(self.obj, name)\n            if not getattr(x, \"__test__\", True):\n                continue\n            funcobj = getimfunc(x)\n            yield TestCaseFunction.from_parent(self, name=name, callobj=funcobj)\n            foundsomething = True\n\n        if not foundsomething:\n            runtest = getattr(self.obj, \"runTest\", None)\n            if runtest is not None:\n                ut = sys.modules.get(\"twisted.trial.unittest\", None)\n                # Type ignored because `ut` is an opaque module.\n                if ut is None or runtest != ut.TestCase.runTest:  # type: ignore\n                    yield TestCaseFunction.from_parent(self, name=\"runTest\")\n\n    def _inject_setup_teardown_fixtures(self, cls: type) -> None:\n        \"\"\"Injects a hidden auto-use fixture to invoke setUpClass/setup_method and corresponding\n        teardown functions (#517).\"\"\"\n        class_fixture = _make_xunit_fixture(\n            cls,\n            \"setUpClass\",\n            \"tearDownClass\",\n            \"doClassCleanups\",\n            scope=\"class\",\n            pass_self=False,\n        )\n        if class_fixture:\n            cls.__pytest_class_setup = class_fixture  # type: ignore[attr-defined]\n\n        method_fixture = _make_xunit_fixture(\n            cls,\n            \"setup_method\",\n            \"teardown_method\",\n            None,\n            scope=\"function\",\n            pass_self=True,\n        )\n        if method_fixture:"
      },
      {
        "name": "UnitTestCase#collect().",
        "file_path": "src/_pytest/unittest.py",
        "file_content": "    def collect(self) -> Iterable[Union[Item, Collector]]:\n        from unittest import TestLoader\n\n        cls = self.obj\n        if not getattr(cls, \"__test__\", True):\n            return\n\n        skipped = _is_skipped(cls)\n        if not skipped:\n            self._inject_setup_teardown_fixtures(cls)\n            self._inject_setup_class_fixture()\n\n        self.session._fixturemanager.parsefactories(self, unittest=True)\n        loader = TestLoader()\n        foundsomething = False\n        for name in loader.getTestCaseNames(self.obj):\n            x = getattr(self.obj, name)\n            if not getattr(x, \"__test__\", True):\n                continue\n            funcobj = getimfunc(x)\n            yield TestCaseFunction.from_parent(self, name=name, callobj=funcobj)\n            foundsomething = True\n\n        if not foundsomething:\n            runtest = getattr(self.obj, \"runTest\", None)\n            if runtest is not None:\n                ut = sys.modules.get(\"twisted.trial.unittest\", None)\n                # Type ignored because `ut` is an opaque module.\n                if ut is None or runtest != ut.TestCase.runTest:  # type: ignore"
      },
      {
        "name": "UnitTestCase#_inject_setup_teardown_fixtures().",
        "file_path": "src/_pytest/unittest.py",
        "file_content": "    def _inject_setup_teardown_fixtures(self, cls: type) -> None:\n        \"\"\"Injects a hidden auto-use fixture to invoke setUpClass/setup_method and corresponding\n        teardown functions (#517).\"\"\"\n        class_fixture = _make_xunit_fixture(\n            cls,\n            \"setUpClass\",\n            \"tearDownClass\",\n            \"doClassCleanups\",\n            scope=\"class\",\n            pass_self=False,\n        )\n        if class_fixture:\n            cls.__pytest_class_setup = class_fixture  # type: ignore[attr-defined]\n\n        method_fixture = _make_xunit_fixture(\n            cls,\n            \"setup_method\",\n            \"teardown_method\",\n            None,\n            scope=\"function\",\n            pass_self=True,\n        )\n        if method_fixture:"
      },
      {
        "name": "_make_xunit_fixture().",
        "file_path": "src/_pytest/unittest.py",
        "file_content": "def _make_xunit_fixture(\n    obj: type,\n    setup_name: str,\n    teardown_name: str,\n    cleanup_name: Optional[str],\n    scope: \"_Scope\",\n    pass_self: bool,\n):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    if cleanup_name:\n        cleanup = getattr(obj, cleanup_name, lambda *args: None)\n    else:\n\n        def cleanup(*args):\n            pass\n\n    @pytest.fixture(\n        scope=scope,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:\n                cleanup()\n"
      },
      {
        "name": "_make_xunit_fixture().fixture().",
        "file_path": "src/_pytest/unittest.py",
        "file_content": "    @pytest.fixture(\n        scope=scope,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:"
      },
      {
        "name": "PseudoFixtureDef#",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(Generic[_FixtureValue]):\n    cached_result = attr.ib(type=\"_FixtureCachedResult[_FixtureValue]\")"
      },
      {
        "name": "FixtureRequest#",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "class FixtureRequest:\n    \"\"\"A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context and has\n    an optional ``param`` attribute in case the fixture is parametrized\n    indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pyfuncitem = pyfuncitem\n        #: Fixture for which this request is being performed.\n        self.fixturename: Optional[str] = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\".\n        self.scope: _Scope = \"function\"\n        self._fixture_defs: Dict[str, FixtureDef[Any]] = {}\n        fixtureinfo: FuncFixtureInfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index: Dict[str, int] = {}\n        self._fixturemanager: FixtureManager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self) -> List[str]:\n        \"\"\"Names of all active fixtures in this request.\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\"Underlying collection node (depends on current request scope).\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname: str) -> \"FixtureDef[Any]\":\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # We arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time.\n            assert self._pyfuncitem.parent is not None\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            # TODO: Fix this type ignore. Either add assert or adjust types.\n            #       Can this be None here?\n            self._arg2fixturedefs[argname] = fixturedefs  # type: ignore[assignment]\n        # fixturedefs list is immutable so we maintain a decreasing index.\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self) -> Config:\n        \"\"\"The pytest config object associated with this request.\"\"\"\n        return self._pyfuncitem.config  # type: ignore[no-any-return]\n\n    @property\n    def function(self):\n        \"\"\"Test function object if the request has a per-function scope.\"\"\"\n        if self.scope != \"function\":\n            raise AttributeError(\n                f\"function not available in {self.scope}-scoped context\"\n            )\n        return self._pyfuncitem.obj\n\n    @property\n    def cls(self):\n        \"\"\"Class (can be None) where the test function was collected.\"\"\"\n        if self.scope not in (\"class\", \"function\"):\n            raise AttributeError(f\"cls not available in {self.scope}-scoped context\")\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\"Instance (can be None) on which test function was collected.\"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction.\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @property\n    def module(self):\n        \"\"\"Python module object where the test function was collected.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @property\n    def fspath(self) -> py.path.local:\n        \"\"\"The file system path of the test module which collected this test.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\", \"package\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore\n\n    @property\n    def keywords(self) -> MutableMapping[str, Any]:\n        \"\"\"Keywords/markers dictionary for the underlying node.\"\"\"\n        node: nodes.Node = self.node\n        return node.keywords\n\n    @property\n    def session(self) -> \"Session\":\n        \"\"\"Pytest session object.\"\"\"\n        return self._pyfuncitem.session  # type: ignore[no-any-return]\n\n    def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n        \"\"\"Add finalizer/teardown function to be called after the last test\n        within the requesting test context finished execution.\"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones.\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer: Callable[[], object], scope) -> None:\n        node = self._getscopeitem(scope)\n        node.addfinalizer(finalizer)\n\n    def applymarker(self, marker: Union[str, MarkDecorator]) -> None:\n        \"\"\"Apply a marker to a single test function invocation.\n\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :param marker:\n            A :class:`pytest.MarkDecorator` object created by a call\n            to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg: Optional[str]) -> \"NoReturn\":\n        \"\"\"Raise a FixtureLookupError with the given message.\"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self) -> None:\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname: str) -> Any:\n        \"\"\"Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raises pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        fixturedef = self._get_active_fixturedef(argname)\n        assert fixturedef.cached_result is not None\n        return fixturedef.cached_result[0]\n\n    def _get_active_fixturedef(\n        self, argname: str\n    ) -> Union[\"FixtureDef[object]\", PseudoFixtureDef[object]]:\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope: _Scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # Remove indent to prevent the python3 exception\n        # from leaking into the call.\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self) -> List[\"FixtureDef[Any]\"]:\n        current = self\n        values: List[FixtureDef[Any]] = []\n        while isinstance(current, SubRequest):\n            values.append(current._fixturedef)  # type: ignore[has-type]\n            current = current._parent_request\n        values.reverse()\n        return values\n\n    def _compute_fixture_value(self, fixturedef: \"FixtureDef[object]\") -> None:\n        \"\"\"Create a SubRequest based on \"self\" and call the execute method\n        of the given FixtureDef object.\n\n        This will force the FixtureDef object to throw away any previous\n        results and compute a new fixture value, which will be stored into\n        the FixtureDef object itself.\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = absolutepath(frameinfo.filename)\n                source_lineno = frameinfo.lineno\n                try:\n                    source_path_str = str(\n                        source_path.relative_to(funcitem.config.rootpath)\n                    )\n                except ValueError:\n                    source_path_str = str(source_path)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path_str,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # If a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function.\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(\n            self, scope, param, param_index, fixturedef, _ispytest=True\n        )\n\n        # Check if a higher-level scoped fixture accesses a lower level one.\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # Call the fixture function.\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(\n        self, fixturedef: \"FixtureDef[object]\", subrequest: \"SubRequest\"\n    ) -> None:\n        # If fixture function failed it might have registered finalizers.\n        subrequest.node.addfinalizer(lambda: fixturedef.finish(request=subrequest))\n\n    def _check_scope(\n        self,\n        argname: str,\n        invoking_scope: \"_Scope\",\n        requested_scope: \"_Scope\",\n    ) -> None:\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # Try to report something helpful.\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self) -> List[str]:\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            if isinstance(fs, Path):\n                session: Session = self._pyfuncitem.session\n                p = bestrelpath(Path(session.fspath), fs)\n            else:\n                p = fs\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope: \"_Scope\") -> Union[nodes.Item, nodes.Collector]:\n        if scope == \"function\":\n            # This might also be a non-function Item despite its attribute name.\n            node: Optional[Union[nodes.Item, nodes.Collector]] = self._pyfuncitem\n        elif scope == \"package\":\n            # FIXME: _fixturedef is not defined on FixtureRequest (this class),\n            # but on FixtureRequest (a subclass).\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)  # type: ignore[attr-defined]\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # Fallback to function item itself.\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self) -> str:"
      },
      {
        "name": "FixtureRequest#__init__().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pyfuncitem = pyfuncitem\n        #: Fixture for which this request is being performed.\n        self.fixturename: Optional[str] = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\".\n        self.scope: _Scope = \"function\"\n        self._fixture_defs: Dict[str, FixtureDef[Any]] = {}\n        fixtureinfo: FuncFixtureInfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index: Dict[str, int] = {}"
      },
      {
        "name": "FixtureRequest#fixturenames().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def fixturenames(self) -> List[str]:\n        \"\"\"Names of all active fixtures in this request.\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))"
      },
      {
        "name": "FixtureRequest#node().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def node(self):\n        \"\"\"Underlying collection node (depends on current request scope).\"\"\""
      },
      {
        "name": "FixtureRequest#_getnextfixturedef().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _getnextfixturedef(self, argname: str) -> \"FixtureDef[Any]\":\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # We arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time.\n            assert self._pyfuncitem.parent is not None\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            # TODO: Fix this type ignore. Either add assert or adjust types.\n            #       Can this be None here?\n            self._arg2fixturedefs[argname] = fixturedefs  # type: ignore[assignment]\n        # fixturedefs list is immutable so we maintain a decreasing index.\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index"
      },
      {
        "name": "FixtureRequest#config().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def config(self) -> Config:\n        \"\"\"The pytest config object associated with this request.\"\"\""
      },
      {
        "name": "FixtureRequest#function().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def function(self):\n        \"\"\"Test function object if the request has a per-function scope.\"\"\"\n        if self.scope != \"function\":\n            raise AttributeError(\n                f\"function not available in {self.scope}-scoped context\"\n            )"
      },
      {
        "name": "FixtureRequest#cls().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def cls(self):\n        \"\"\"Class (can be None) where the test function was collected.\"\"\"\n        if self.scope not in (\"class\", \"function\"):\n            raise AttributeError(f\"cls not available in {self.scope}-scoped context\")\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:"
      },
      {
        "name": "FixtureRequest#instance().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def instance(self):\n        \"\"\"Instance (can be None) on which test function was collected.\"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction.\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)"
      },
      {
        "name": "FixtureRequest#module().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def module(self):\n        \"\"\"Python module object where the test function was collected.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")"
      },
      {
        "name": "FixtureRequest#fspath().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def fspath(self) -> py.path.local:\n        \"\"\"The file system path of the test module which collected this test.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\", \"package\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")\n        # TODO: Remove ignore once _pyfuncitem is properly typed."
      },
      {
        "name": "FixtureRequest#keywords().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def keywords(self) -> MutableMapping[str, Any]:\n        \"\"\"Keywords/markers dictionary for the underlying node.\"\"\"\n        node: nodes.Node = self.node"
      },
      {
        "name": "FixtureRequest#session().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    @property\n    def session(self) -> \"Session\":\n        \"\"\"Pytest session object.\"\"\""
      },
      {
        "name": "FixtureRequest#addfinalizer().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n        \"\"\"Add finalizer/teardown function to be called after the last test\n        within the requesting test context finished execution.\"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones."
      },
      {
        "name": "FixtureRequest#_addfinalizer().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _addfinalizer(self, finalizer: Callable[[], object], scope) -> None:\n        node = self._getscopeitem(scope)"
      },
      {
        "name": "FixtureRequest#applymarker().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def applymarker(self, marker: Union[str, MarkDecorator]) -> None:\n        \"\"\"Apply a marker to a single test function invocation.\n\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :param marker:\n            A :class:`pytest.MarkDecorator` object created by a call\n            to ``pytest.mark.NAME(...)``.\n        \"\"\""
      },
      {
        "name": "FixtureRequest#raiseerror().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def raiseerror(self, msg: Optional[str]) -> \"NoReturn\":\n        \"\"\"Raise a FixtureLookupError with the given message.\"\"\""
      },
      {
        "name": "FixtureRequest#_fillfixtures().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _fillfixtures(self) -> None:\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:"
      },
      {
        "name": "FixtureRequest#getfixturevalue().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def getfixturevalue(self, argname: str) -> Any:\n        \"\"\"Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raises pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        fixturedef = self._get_active_fixturedef(argname)\n        assert fixturedef.cached_result is not None"
      },
      {
        "name": "FixtureRequest#_get_active_fixturedef().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _get_active_fixturedef(\n        self, argname: str\n    ) -> Union[\"FixtureDef[object]\", PseudoFixtureDef[object]]:\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope: _Scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # Remove indent to prevent the python3 exception\n        # from leaking into the call.\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef"
      },
      {
        "name": "FixtureRequest#_get_fixturestack().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _get_fixturestack(self) -> List[\"FixtureDef[Any]\"]:\n        current = self\n        values: List[FixtureDef[Any]] = []\n        while isinstance(current, SubRequest):\n            values.append(current._fixturedef)  # type: ignore[has-type]\n            current = current._parent_request\n        values.reverse()"
      },
      {
        "name": "FixtureRequest#_compute_fixture_value().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _compute_fixture_value(self, fixturedef: \"FixtureDef[object]\") -> None:\n        \"\"\"Create a SubRequest based on \"self\" and call the execute method\n        of the given FixtureDef object.\n\n        This will force the FixtureDef object to throw away any previous\n        results and compute a new fixture value, which will be stored into\n        the FixtureDef object itself.\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = absolutepath(frameinfo.filename)\n                source_lineno = frameinfo.lineno\n                try:\n                    source_path_str = str(\n                        source_path.relative_to(funcitem.config.rootpath)\n                    )\n                except ValueError:\n                    source_path_str = str(source_path)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path_str,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # If a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function.\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(\n            self, scope, param, param_index, fixturedef, _ispytest=True\n        )\n\n        # Check if a higher-level scoped fixture accesses a lower level one.\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # Call the fixture function.\n            fixturedef.execute(request=subrequest)\n        finally:"
      },
      {
        "name": "FixtureRequest#_schedule_finalizers().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _schedule_finalizers(\n        self, fixturedef: \"FixtureDef[object]\", subrequest: \"SubRequest\"\n    ) -> None:\n        # If fixture function failed it might have registered finalizers."
      },
      {
        "name": "FixtureRequest#_check_scope().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _check_scope(\n        self,\n        argname: str,\n        invoking_scope: \"_Scope\",\n        requested_scope: \"_Scope\",\n    ) -> None:\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # Try to report something helpful.\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,"
      },
      {
        "name": "FixtureRequest#_factorytraceback().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _factorytraceback(self) -> List[str]:\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            if isinstance(fs, Path):\n                session: Session = self._pyfuncitem.session\n                p = bestrelpath(Path(session.fspath), fs)\n            else:\n                p = fs\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))"
      },
      {
        "name": "FixtureRequest#_getscopeitem().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _getscopeitem(self, scope: \"_Scope\") -> Union[nodes.Item, nodes.Collector]:\n        if scope == \"function\":\n            # This might also be a non-function Item despite its attribute name.\n            node: Optional[Union[nodes.Item, nodes.Collector]] = self._pyfuncitem\n        elif scope == \"package\":\n            # FIXME: _fixturedef is not defined on FixtureRequest (this class),\n            # but on FixtureRequest (a subclass).\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)  # type: ignore[attr-defined]\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # Fallback to function item itself.\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )"
      },
      {
        "name": "FixtureRequest#__repr__().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def __repr__(self) -> str:"
      },
      {
        "name": "FixtureDef#",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "@final\nclass FixtureDef(Generic[_FixtureValue]):\n    \"\"\"A container for a factory definition.\"\"\"\n\n    def __init__(\n        self,\n        fixturemanager: \"FixtureManager\",\n        baseid: Optional[str],\n        argname: str,\n        func: \"_FixtureFunc[_FixtureValue]\",\n        scope: \"Union[_Scope, Callable[[str, Config], _Scope]]\",\n        params: Optional[Sequence[object]],\n        unittest: bool = False,\n        ids: Optional[\n            Union[\n                Tuple[Union[None, str, float, int, bool], ...],\n                Callable[[Any], Optional[object]],\n            ]\n        ] = None,\n    ) -> None:\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        if callable(scope):\n            scope_ = _eval_scope_callable(scope, argname, fixturemanager.config)\n        else:\n            scope_ = scope\n        self.scopenum = scope2index(\n            # TODO: Check if the `or` here is really necessary.\n            scope_ or \"function\",  # type: ignore[unreachable]\n            descr=f\"Fixture '{func.__name__}'\",\n            where=baseid,\n        )\n        self.scope = scope_\n        self.params: Optional[Sequence[object]] = params\n        self.argnames: Tuple[str, ...] = getfuncargnames(\n            func, name=argname, is_method=unittest\n        )\n        self.unittest = unittest\n        self.ids = ids\n        self.cached_result: Optional[_FixtureCachedResult[_FixtureValue]] = None\n        self._finalizers: List[Callable[[], object]] = []\n\n    def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n        self._finalizers.append(finalizer)\n\n    def finish(self, request: SubRequest) -> None:\n        exc = None\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except BaseException as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n            if exc:\n                raise exc\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # Even if finalization fails, we invalidate the cached fixture\n            # value and remove all finalizers because they may be bound methods\n            # which will keep instances alive.\n            self.cached_result = None\n            self._finalizers = []\n\n    def execute(self, request: SubRequest) -> _FixtureValue:\n        # Get required arguments and register our own finish()\n        # with their finalization.\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                # PseudoFixtureDef is only for \"request\".\n                assert isinstance(fixturedef, FixtureDef)\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = self.cache_key(request)\n        if self.cached_result is not None:\n            # note: comparison with `==` can fail (or be expensive) for e.g.\n            # numpy arrays (#6497).\n            cache_key = self.cached_result[1]\n            if my_cache_key is cache_key:\n                if self.cached_result[2] is not None:\n                    _, val, tb = self.cached_result[2]\n                    raise val.with_traceback(tb)\n                else:\n                    result = self.cached_result[0]\n                    return result\n            # We have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one.\n            self.finish(request)\n            assert self.cached_result is None\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        result = hook.pytest_fixture_setup(fixturedef=self, request=request)\n        return result\n\n    def cache_key(self, request: SubRequest) -> object:\n        return request.param_index if not hasattr(request, \"param\") else request.param\n\n    def __repr__(self) -> str:\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid"
      },
      {
        "name": "FixtureDef#__init__().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def __init__(\n        self,\n        fixturemanager: \"FixtureManager\",\n        baseid: Optional[str],\n        argname: str,\n        func: \"_FixtureFunc[_FixtureValue]\",\n        scope: \"Union[_Scope, Callable[[str, Config], _Scope]]\",\n        params: Optional[Sequence[object]],\n        unittest: bool = False,\n        ids: Optional[\n            Union[\n                Tuple[Union[None, str, float, int, bool], ...],\n                Callable[[Any], Optional[object]],\n            ]\n        ] = None,\n    ) -> None:\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        if callable(scope):\n            scope_ = _eval_scope_callable(scope, argname, fixturemanager.config)\n        else:\n            scope_ = scope\n        self.scopenum = scope2index(\n            # TODO: Check if the `or` here is really necessary.\n            scope_ or \"function\",  # type: ignore[unreachable]\n            descr=f\"Fixture '{func.__name__}'\",\n            where=baseid,\n        )\n        self.scope = scope_\n        self.params: Optional[Sequence[object]] = params\n        self.argnames: Tuple[str, ...] = getfuncargnames(\n            func, name=argname, is_method=unittest\n        )\n        self.unittest = unittest\n        self.ids = ids\n        self.cached_result: Optional[_FixtureCachedResult[_FixtureValue]] = None"
      },
      {
        "name": "FixtureDef#addfinalizer().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def addfinalizer(self, finalizer: Callable[[], object]) -> None:"
      },
      {
        "name": "FixtureDef#finish().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def finish(self, request: SubRequest) -> None:\n        exc = None\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except BaseException as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n            if exc:\n                raise exc\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # Even if finalization fails, we invalidate the cached fixture\n            # value and remove all finalizers because they may be bound methods\n            # which will keep instances alive.\n            self.cached_result = None"
      },
      {
        "name": "FixtureDef#execute().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def execute(self, request: SubRequest) -> _FixtureValue:\n        # Get required arguments and register our own finish()\n        # with their finalization.\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                # PseudoFixtureDef is only for \"request\".\n                assert isinstance(fixturedef, FixtureDef)\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = self.cache_key(request)\n        if self.cached_result is not None:\n            # note: comparison with `==` can fail (or be expensive) for e.g.\n            # numpy arrays (#6497).\n            cache_key = self.cached_result[1]\n            if my_cache_key is cache_key:\n                if self.cached_result[2] is not None:\n                    _, val, tb = self.cached_result[2]\n                    raise val.with_traceback(tb)\n                else:\n                    result = self.cached_result[0]\n                    return result\n            # We have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one.\n            self.finish(request)\n            assert self.cached_result is None\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        result = hook.pytest_fixture_setup(fixturedef=self, request=request)"
      },
      {
        "name": "FixtureDef#cache_key().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def cache_key(self, request: SubRequest) -> object:"
      },
      {
        "name": "FixtureDef#__repr__().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def __repr__(self) -> str:\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid"
      },
      {
        "name": "FixtureManager#",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "class FixtureManager:\n    \"\"\"pytest fixture definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function. An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i.e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session: \"Session\") -> None:\n        self.session = session\n        self.config: Config = session.config\n        self._arg2fixturedefs: Dict[str, List[FixtureDef[Any]]] = {}\n        self._holderobjseen: Set[object] = set()\n        # A mapping from a nodeid to a list of autouse fixtures it defines.\n        self._nodeid_autousenames: Dict[str, List[str]] = {\n            \"\": self.config.getini(\"usefixtures\"),\n        }\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node: nodes.Node) -> List[str]:\n        \"\"\"Return all direct parametrization arguments of a node, so we don't\n        mistake them for fixtures.\n\n        Check https://github.com/pytest-dev/pytest/issues/5036.\n\n        These things are done later as well when dealing with parametrization\n        so this could be improved.\n        \"\"\"\n        parametrize_argnames: List[str] = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(\n        self, node: nodes.Node, func, cls, funcargs: bool = True\n    ) -> FuncFixtureInfo:\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = tuple(\n            arg for mark in node.iter_markers(name=\"usefixtures\") for arg in mark.args\n        )\n        initialnames = usefixtures + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin: _PluggyPlugin) -> None:\n        nodeid = None\n        try:\n            p = absolutepath(plugin.__file__)  # type: ignore[attr-defined]\n        except AttributeError:\n            pass\n        else:\n            # Construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id).\n            if p.name.startswith(\"conftest.py\"):\n                try:\n                    nodeid = str(p.parent.relative_to(self.config.rootpath))\n                except ValueError:\n                    nodeid = \"\"\n                if nodeid == \".\":\n                    nodeid = \"\"\n                if os.sep != nodes.SEP:\n                    nodeid = nodeid.replace(os.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid: str) -> Iterator[str]:\n        \"\"\"Return the names of autouse fixtures applicable to nodeid.\"\"\"\n        for parentnodeid in nodes.iterparentnodeids(nodeid):\n            basenames = self._nodeid_autousenames.get(parentnodeid)\n            if basenames:\n                yield from basenames\n\n    def getfixtureclosure(\n        self,\n        fixturenames: Tuple[str, ...],\n        parentnode: nodes.Node,\n        ignore_args: Sequence[str] = (),\n    ) -> Tuple[Tuple[str, ...], List[str], Dict[str, Sequence[FixtureDef[Any]]]]:\n        # Collect the closure of all fixtures, starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive).\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = list(self._getautousenames(parentid))\n\n        def merge(otherlist: Iterable[str]) -> None:\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # At this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs: Dict[str, Sequence[FixtureDef[Any]]] = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc: \"Metafunc\") -> None:\n        \"\"\"Generate new tests based on parametrized fixtures used by the given metafunc\"\"\"\n\n        def get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:\n            args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)\n            return args\n\n        for argname in metafunc.fixturenames:\n            # Get the FixtureDefs for the argname.\n            fixture_defs = metafunc._arg2fixturedefs.get(argname)\n            if not fixture_defs:\n                # Will raise FixtureLookupError at setup time if not parametrized somewhere\n                # else (e.g @pytest.mark.parametrize)\n                continue\n\n            # If the test itself parametrizes using this argname, give it\n            # precedence.\n            if any(\n                argname in get_parametrize_mark_argnames(mark)\n                for mark in metafunc.definition.iter_markers(\"parametrize\")\n            ):\n                continue\n\n            # In the common case we only look at the fixture def with the\n            # closest scope (last in the list). But if the fixture overrides\n            # another fixture, while requesting the super fixture, keep going\n            # in case the super fixture is parametrized (#1953).\n            for fixturedef in reversed(fixture_defs):\n                # Fixture is parametrized, apply it and stop.\n                if fixturedef.params is not None:\n                    metafunc.parametrize(\n                        argname,\n                        fixturedef.params,\n                        indirect=True,\n                        scope=fixturedef.scope,\n                        ids=fixturedef.ids,\n                    )\n                    break\n\n                # Not requesting the overridden super fixture, stop.\n                if argname not in fixturedef.argnames:\n                    break\n\n                # Try next super fixture, if any.\n\n    def pytest_collection_modifyitems(self, items: List[nodes.Item]) -> None:\n        # Separate parametrized setups.\n        items[:] = reorder_items(items)\n\n    def parsefactories(\n        self, node_or_obj, nodeid=NOTSET, unittest: bool = False\n    ) -> None:\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # Magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute.\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # During fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in\n            # order to not emit the warning when pytest itself calls the\n            # fixture function.\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                fixturemanager=self,\n                baseid=nodeid,\n                argname=name,\n                func=obj,\n                scope=marker.scope,\n                params=marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_autousenames.setdefault(nodeid or \"\", []).extend(autousenames)\n\n    def getfixturedefs(\n        self, argname: str, nodeid: str\n    ) -> Optional[Sequence[FixtureDef[Any]]]:\n        \"\"\"Get a list of fixtures which are applicable to the given node id.\n\n        :param str argname: Name of the fixture to search for.\n        :param str nodeid: Full node id of the requesting test.\n        :rtype: Sequence[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(\n        self, fixturedefs: Iterable[FixtureDef[Any]], nodeid: str\n    ) -> Iterator[FixtureDef[Any]]:\n        parentnodeids = set(nodes.iterparentnodeids(nodeid))\n        for fixturedef in fixturedefs:\n            if fixturedef.baseid in parentnodeids:"
      },
      {
        "name": "FixtureManager#__init__().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def __init__(self, session: \"Session\") -> None:\n        self.session = session\n        self.config: Config = session.config\n        self._arg2fixturedefs: Dict[str, List[FixtureDef[Any]]] = {}\n        self._holderobjseen: Set[object] = set()\n        # A mapping from a nodeid to a list of autouse fixtures it defines.\n        self._nodeid_autousenames: Dict[str, List[str]] = {\n            \"\": self.config.getini(\"usefixtures\"),\n        }"
      },
      {
        "name": "FixtureManager#_get_direct_parametrize_args().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _get_direct_parametrize_args(self, node: nodes.Node) -> List[str]:\n        \"\"\"Return all direct parametrization arguments of a node, so we don't\n        mistake them for fixtures.\n\n        Check https://github.com/pytest-dev/pytest/issues/5036.\n\n        These things are done later as well when dealing with parametrization\n        so this could be improved.\n        \"\"\"\n        parametrize_argnames: List[str] = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n"
      },
      {
        "name": "FixtureManager#getfixtureinfo().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def getfixtureinfo(\n        self, node: nodes.Node, func, cls, funcargs: bool = True\n    ) -> FuncFixtureInfo:\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = tuple(\n            arg for mark in node.iter_markers(name=\"usefixtures\") for arg in mark.args\n        )\n        initialnames = usefixtures + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )"
      },
      {
        "name": "FixtureManager#pytest_plugin_registered().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def pytest_plugin_registered(self, plugin: _PluggyPlugin) -> None:\n        nodeid = None\n        try:\n            p = absolutepath(plugin.__file__)  # type: ignore[attr-defined]\n        except AttributeError:\n            pass\n        else:\n            # Construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id).\n            if p.name.startswith(\"conftest.py\"):\n                try:\n                    nodeid = str(p.parent.relative_to(self.config.rootpath))\n                except ValueError:\n                    nodeid = \"\"\n                if nodeid == \".\":\n                    nodeid = \"\"\n                if os.sep != nodes.SEP:\n                    nodeid = nodeid.replace(os.sep, nodes.SEP)\n"
      },
      {
        "name": "FixtureManager#_getautousenames().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _getautousenames(self, nodeid: str) -> Iterator[str]:\n        \"\"\"Return the names of autouse fixtures applicable to nodeid.\"\"\"\n        for parentnodeid in nodes.iterparentnodeids(nodeid):\n            basenames = self._nodeid_autousenames.get(parentnodeid)\n            if basenames:"
      },
      {
        "name": "FixtureManager#getfixtureclosure().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def getfixtureclosure(\n        self,\n        fixturenames: Tuple[str, ...],\n        parentnode: nodes.Node,\n        ignore_args: Sequence[str] = (),\n    ) -> Tuple[Tuple[str, ...], List[str], Dict[str, Sequence[FixtureDef[Any]]]]:\n        # Collect the closure of all fixtures, starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive).\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = list(self._getautousenames(parentid))\n\n        def merge(otherlist: Iterable[str]) -> None:\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # At this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs: Dict[str, Sequence[FixtureDef[Any]]] = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)"
      },
      {
        "name": "FixtureManager#merge().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "        def merge(otherlist: Iterable[str]) -> None:\n            for arg in otherlist:\n                if arg not in fixturenames_closure:"
      },
      {
        "name": "FixtureManager#sort_by_scope().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "        def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:"
      },
      {
        "name": "FixtureManager#pytest_generate_tests().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def pytest_generate_tests(self, metafunc: \"Metafunc\") -> None:\n        \"\"\"Generate new tests based on parametrized fixtures used by the given metafunc\"\"\"\n\n        def get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:\n            args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)\n            return args\n\n        for argname in metafunc.fixturenames:\n            # Get the FixtureDefs for the argname.\n            fixture_defs = metafunc._arg2fixturedefs.get(argname)\n            if not fixture_defs:\n                # Will raise FixtureLookupError at setup time if not parametrized somewhere\n                # else (e.g @pytest.mark.parametrize)\n                continue\n\n            # If the test itself parametrizes using this argname, give it\n            # precedence.\n            if any(\n                argname in get_parametrize_mark_argnames(mark)\n                for mark in metafunc.definition.iter_markers(\"parametrize\")\n            ):\n                continue\n\n            # In the common case we only look at the fixture def with the\n            # closest scope (last in the list). But if the fixture overrides\n            # another fixture, while requesting the super fixture, keep going\n            # in case the super fixture is parametrized (#1953).\n            for fixturedef in reversed(fixture_defs):\n                # Fixture is parametrized, apply it and stop.\n                if fixturedef.params is not None:\n                    metafunc.parametrize(\n                        argname,\n                        fixturedef.params,\n                        indirect=True,\n                        scope=fixturedef.scope,\n                        ids=fixturedef.ids,\n                    )\n                    break\n\n                # Not requesting the overridden super fixture, stop.\n                if argname not in fixturedef.argnames:"
      },
      {
        "name": "FixtureManager#get_parametrize_mark_argnames().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "        def get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:\n            args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)"
      },
      {
        "name": "FixtureManager#pytest_collection_modifyitems().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def pytest_collection_modifyitems(self, items: List[nodes.Item]) -> None:\n        # Separate parametrized setups."
      },
      {
        "name": "FixtureManager#parsefactories().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def parsefactories(\n        self, node_or_obj, nodeid=NOTSET, unittest: bool = False\n    ) -> None:\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # Magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute.\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # During fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in\n            # order to not emit the warning when pytest itself calls the\n            # fixture function.\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                fixturemanager=self,\n                baseid=nodeid,\n                argname=name,\n                func=obj,\n                scope=marker.scope,\n                params=marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:"
      },
      {
        "name": "FixtureManager#getfixturedefs().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def getfixturedefs(\n        self, argname: str, nodeid: str\n    ) -> Optional[Sequence[FixtureDef[Any]]]:\n        \"\"\"Get a list of fixtures which are applicable to the given node id.\n\n        :param str argname: Name of the fixture to search for.\n        :param str nodeid: Full node id of the requesting test.\n        :rtype: Sequence[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None"
      },
      {
        "name": "FixtureManager#_matchfactories().",
        "file_path": "src/_pytest/fixtures.py",
        "file_content": "    def _matchfactories(\n        self, fixturedefs: Iterable[FixtureDef[Any]], nodeid: str\n    ) -> Iterator[FixtureDef[Any]]:\n        parentnodeids = set(nodes.iterparentnodeids(nodeid))\n        for fixturedef in fixturedefs:\n            if fixturedef.baseid in parentnodeids:"
      },
      {
        "name": "pytest_runtest_makereport().",
        "file_path": "src/_pytest/runner.py",
        "file_content": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:"
      },
      {
        "name": "pytest_make_collect_report().",
        "file_path": "src/_pytest/runner.py",
        "file_content": "def pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"unittest\")\n        if unittest is not None:\n            # Type ignored because unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if isinstance(call.excinfo.value, tuple(skip_exceptions)):\n            if unittest is not None and isinstance(\n                call.excinfo.value, unittest.SkipTest  # type: ignore[attr-defined]\n            ):\n                warnings.warn(UNITTEST_SKIP_DURING_COLLECTION, stacklevel=2)\n\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                assert isinstance(errorinfo, str)\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    result = call.result if not call.excinfo else None\n    rep = CollectReport(collector.nodeid, outcome, longrepr, result)\n    rep.call = call  # type: ignore # see collect_one_node"
      },
      {
        "name": "SetupState#setup().",
        "file_path": "src/_pytest/runner.py",
        "file_content": "    def setup(self, item: Item) -> None:\n        \"\"\"Setup objects along the collector chain to the item.\"\"\"\n        needed_collectors = item.listchain()\n\n        # If a collector fails its setup, fail its entire subtree of items.\n        # The setup is not retried for each item - the same exception is used.\n        for col, (finalizers, exc) in self.stack.items():\n            assert col in needed_collectors, \"previous item was not torn down properly\"\n            if exc:\n                raise exc\n\n        for col in needed_collectors[len(self.stack) :]:\n            assert col not in self.stack\n            # Push onto the stack.\n            self.stack[col] = ([col.teardown], None)\n            try:\n                col.setup()\n            except TEST_OUTCOME as exc:\n                self.stack[col] = (self.stack[col][0], exc)"
      },
      {
        "name": "SetupState#teardown_exact().",
        "file_path": "src/_pytest/runner.py",
        "file_content": "    def teardown_exact(self, nextitem: Optional[Item]) -> None:\n        \"\"\"Teardown the current stack up until reaching nodes that nextitem\n        also descends from.\n\n        When nextitem is None (meaning we're at the last item), the entire\n        stack is torn down.\n        \"\"\"\n        needed_collectors = nextitem and nextitem.listchain() or []\n        exc = None\n        while self.stack:\n            if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:\n                break\n            node, (finalizers, _) = self.stack.popitem()\n            while finalizers:\n                fin = finalizers.pop()\n                try:\n                    fin()\n                except TEST_OUTCOME as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n        if exc:\n            raise exc\n        if nextitem is None:"
      }
    ]
  },
  "response": {
    "scratch_pad": "1.1 The issue reported by the user relates to the visibility and handling of `setUpClass` fixtures in unittest when used with the pytest testing framework. Starting from version 6.2.0, these fixtures are no longer marked as private, which means they are visible in the list of fixtures when running pytest commands (like `pytest --fixtures`). This breaks the CI script that checks for undocumented fixtures, as it assumes that certain fixtures starting with an underscore would be hidden unless the verbose output is requested.\n\n1.2 This issue was caused by a change in the behavior of the pytest framework to make `setUpClass` fixtures visible by default during the collection and management of fixtures. Previously, such fixtures were treated as private by convention (starting with an underscore) and would not show up unless asked for in verbose mode.\n\n1.3 The expected behavior that the user desires is for `setUpClass` fixtures to still be hidden (only visible when verbose output is requested) which is in line with how it used to work before version 6.2.0. This would help maintain the integrity of the existing CI practices that rely on these conventions.\n\n1.4 The expectation in this case is that the `setUpClass` fixtures should not be printed in the `pytest --fixtures` output unless the verbose flag is given.\n\n1.5 To fix this issue, it should be ensured that any fixture names that start with an underscore (as in the `setUpClass` fixtures) are not included in the list displayed by `pytest --fixtures` unless the verbose flag is supplied. This can be achieved by adjusting how fixtures are collected and displayed, possibly by adding a conditional check based on naming or via configuration settings.",
    "patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex abcd123..ef01234 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -145,7 +145,7 @@ class UnitTestCase(Collector):\n                     # to declare that our children do not support funcargs.\n                     nofuncargs = True\n \n-    def collect(self) -> Iterable[Union[Item, Collector]]:\n+    def collect(self) -> Iterable[Union[Item, Collector]]:\n         if name.startswith(\"_\") and not self.session._verbosity:\n             return # skip the collection of private fixtures unless verbose\n \n         # rest of the original logic\ndiff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 56789ab..012efab 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -20,7 +20,7 @@ def pytest_fixture_setup(\n         # original fixture setup logic\n         if fixturedef.name.startswith(\"_\") and not request.session._verbosity:\n            continue # Skip private fixtures unless verbosity is high\n \n         # Additional setup logic for fixtures"
  },
  "messages": [
    {
      "role": "system",
      "content": "You are an autonomous AI assistant tasked with finding relevant code in an existing \ncodebase based on a reported issue. \nYour task is base on the symbol code to identify how many symbols need to be change to resolve the issue. \n#Input Structure:\n\n* <issue>: Contains the reported issue.\n* <high_relevant_symbol>: the code more likely to be the root cause of the issue. \n* <relevant_symbol>: the code might to be relevant to the issue.\n\n# Your Task:\n\n1. Analyze User Instructions:\nCarefully read the reported issue within the <issue> tag.\nthink step by step and write out your thoughts in the scratch_pad field.\n1.1 What issue is the user describing?\n1.2 How was this issue caused?\n1.3 If the user described the expected result, what should it be fixed to?\n1.4 If the user did not provide an expected result, what should the expectation be?\n1.5 How should the issue be fixed to meet the expectation?\n1.6 Remember, you should think from the perspective of a core library developer. This means you need to consider how to make the solution simple, safe, and minimize code changes.\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each lines in the <root_cause_symbol> and <relevant_symbol> tags.\n2.2. Match the symbol/code/pattern with the key elements, functions, variables, or patterns identified in the reported issue.\n2.3. Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n2.4. make the decision how many symbols need to be change to resolve the issue.\n2.5. change the symbols in the code to resolve the issue.\n\nThink step by step and write out your thoughts in the scratch_pad field.  \n\n"
    },
    {
      "role": "user",
      "content": "<issue><description>:Starting v6.2.0, unittest setUpClass fixtures are no longer \"private\"\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\nMinimal example:\r\n```\r\nimport unittest\r\n\r\nclass Tests(unittest.TestCase):\r\n    @classmethod\r\n    def setUpClass(cls):\r\n        pass\r\n\r\n    def test_1(self):\r\n        pass\r\n```\r\n```\r\n~$  pytest --fixtures\r\n...\r\nunittest_setUpClass_fixture_Tests [class scope] -- ../Platform/.venv/lib/python3.6/site-packages/_pytest/unittest.py:145\r\n    /home/ubuntu/src/Platform/.venv/lib/python3.6/site-packages/_pytest/unittest.py:145: no docstring available\r\n```\r\nThe expected (and previously implemented behavior) is that this fixture's name would start with an underscore, and would therefore only get printed if the additional `-v` flag was used. As it stands, I don't see a way to hide such generated fixtures which will not have a docstring.\r\n\r\nThis breaks a code-quality CI script that makes sure we don't have undocumented pytest fixtures (and the code-base has many legacy tests that use unittest, and that will not get upgraded).\r\n\n</description></issue>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>UnitTestCase#</name><path>src/_pytest/unittest.py</path><content>class UnitTestCase(Class):\n    # Marker for fixturemanger.getfixtureinfo()\n    # to declare that our children do not support funcargs.\n    nofuncargs = True\n\n    def collect(self) -> Iterable[Union[Item, Collector]]:\n        from unittest import TestLoader\n\n        cls = self.obj\n        if not getattr(cls, \"__test__\", True):\n            return\n\n        skipped = _is_skipped(cls)\n        if not skipped:\n            self._inject_setup_teardown_fixtures(cls)\n            self._inject_setup_class_fixture()\n\n        self.session._fixturemanager.parsefactories(self, unittest=True)\n        loader = TestLoader()\n        foundsomething = False\n        for name in loader.getTestCaseNames(self.obj):\n            x = getattr(self.obj, name)\n            if not getattr(x, \"__test__\", True):\n                continue\n            funcobj = getimfunc(x)\n            yield TestCaseFunction.from_parent(self, name=name, callobj=funcobj)\n            foundsomething = True\n\n        if not foundsomething:\n            runtest = getattr(self.obj, \"runTest\", None)\n            if runtest is not None:\n                ut = sys.modules.get(\"twisted.trial.unittest\", None)\n                # Type ignored because `ut` is an opaque module.\n                if ut is None or runtest != ut.TestCase.runTest:  # type: ignore\n                    yield TestCaseFunction.from_parent(self, name=\"runTest\")\n\n    def _inject_setup_teardown_fixtures(self, cls: type) -> None:\n        \"\"\"Injects a hidden auto-use fixture to invoke setUpClass/setup_method and corresponding\n        teardown functions (#517).\"\"\"\n        class_fixture = _make_xunit_fixture(\n            cls,\n            \"setUpClass\",\n            \"tearDownClass\",\n            \"doClassCleanups\",\n            scope=\"class\",\n            pass_self=False,\n        )\n        if class_fixture:\n            cls.__pytest_class_setup = class_fixture  # type: ignore[attr-defined]\n\n        method_fixture = _make_xunit_fixture(\n            cls,\n            \"setup_method\",\n            \"teardown_method\",\n            None,\n            scope=\"function\",\n            pass_self=True,\n        )\n        if method_fixture:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>UnitTestCase#collect().</name><path>src/_pytest/unittest.py</path><content>    def collect(self) -> Iterable[Union[Item, Collector]]:\n        from unittest import TestLoader\n\n        cls = self.obj\n        if not getattr(cls, \"__test__\", True):\n            return\n\n        skipped = _is_skipped(cls)\n        if not skipped:\n            self._inject_setup_teardown_fixtures(cls)\n            self._inject_setup_class_fixture()\n\n        self.session._fixturemanager.parsefactories(self, unittest=True)\n        loader = TestLoader()\n        foundsomething = False\n        for name in loader.getTestCaseNames(self.obj):\n            x = getattr(self.obj, name)\n            if not getattr(x, \"__test__\", True):\n                continue\n            funcobj = getimfunc(x)\n            yield TestCaseFunction.from_parent(self, name=name, callobj=funcobj)\n            foundsomething = True\n\n        if not foundsomething:\n            runtest = getattr(self.obj, \"runTest\", None)\n            if runtest is not None:\n                ut = sys.modules.get(\"twisted.trial.unittest\", None)\n                # Type ignored because `ut` is an opaque module.\n                if ut is None or runtest != ut.TestCase.runTest:  # type: ignore</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>UnitTestCase#_inject_setup_teardown_fixtures().</name><path>src/_pytest/unittest.py</path><content>    def _inject_setup_teardown_fixtures(self, cls: type) -> None:\n        \"\"\"Injects a hidden auto-use fixture to invoke setUpClass/setup_method and corresponding\n        teardown functions (#517).\"\"\"\n        class_fixture = _make_xunit_fixture(\n            cls,\n            \"setUpClass\",\n            \"tearDownClass\",\n            \"doClassCleanups\",\n            scope=\"class\",\n            pass_self=False,\n        )\n        if class_fixture:\n            cls.__pytest_class_setup = class_fixture  # type: ignore[attr-defined]\n\n        method_fixture = _make_xunit_fixture(\n            cls,\n            \"setup_method\",\n            \"teardown_method\",\n            None,\n            scope=\"function\",\n            pass_self=True,\n        )\n        if method_fixture:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>_make_xunit_fixture().</name><path>src/_pytest/unittest.py</path><content>def _make_xunit_fixture(\n    obj: type,\n    setup_name: str,\n    teardown_name: str,\n    cleanup_name: Optional[str],\n    scope: \"_Scope\",\n    pass_self: bool,\n):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    if cleanup_name:\n        cleanup = getattr(obj, cleanup_name, lambda *args: None)\n    else:\n\n        def cleanup(*args):\n            pass\n\n    @pytest.fixture(\n        scope=scope,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:\n                cleanup()\n</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>_make_xunit_fixture().fixture().</name><path>src/_pytest/unittest.py</path><content>    @pytest.fixture(\n        scope=scope,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>PseudoFixtureDef#</name><path>src/_pytest/fixtures.py</path><content>@attr.s(frozen=True)\nclass PseudoFixtureDef(Generic[_FixtureValue]):\n    cached_result = attr.ib(type=\"_FixtureCachedResult[_FixtureValue]\")</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#</name><path>src/_pytest/fixtures.py</path><content>class FixtureRequest:\n    \"\"\"A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context and has\n    an optional ``param`` attribute in case the fixture is parametrized\n    indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pyfuncitem = pyfuncitem\n        #: Fixture for which this request is being performed.\n        self.fixturename: Optional[str] = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\".\n        self.scope: _Scope = \"function\"\n        self._fixture_defs: Dict[str, FixtureDef[Any]] = {}\n        fixtureinfo: FuncFixtureInfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index: Dict[str, int] = {}\n        self._fixturemanager: FixtureManager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self) -> List[str]:\n        \"\"\"Names of all active fixtures in this request.\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\"Underlying collection node (depends on current request scope).\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname: str) -> \"FixtureDef[Any]\":\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # We arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time.\n            assert self._pyfuncitem.parent is not None\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            # TODO: Fix this type ignore. Either add assert or adjust types.\n            #       Can this be None here?\n            self._arg2fixturedefs[argname] = fixturedefs  # type: ignore[assignment]\n        # fixturedefs list is immutable so we maintain a decreasing index.\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self) -> Config:\n        \"\"\"The pytest config object associated with this request.\"\"\"\n        return self._pyfuncitem.config  # type: ignore[no-any-return]\n\n    @property\n    def function(self):\n        \"\"\"Test function object if the request has a per-function scope.\"\"\"\n        if self.scope != \"function\":\n            raise AttributeError(\n                f\"function not available in {self.scope}-scoped context\"\n            )\n        return self._pyfuncitem.obj\n\n    @property\n    def cls(self):\n        \"\"\"Class (can be None) where the test function was collected.\"\"\"\n        if self.scope not in (\"class\", \"function\"):\n            raise AttributeError(f\"cls not available in {self.scope}-scoped context\")\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\"Instance (can be None) on which test function was collected.\"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction.\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @property\n    def module(self):\n        \"\"\"Python module object where the test function was collected.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @property\n    def fspath(self) -> py.path.local:\n        \"\"\"The file system path of the test module which collected this test.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\", \"package\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore\n\n    @property\n    def keywords(self) -> MutableMapping[str, Any]:\n        \"\"\"Keywords/markers dictionary for the underlying node.\"\"\"\n        node: nodes.Node = self.node\n        return node.keywords\n\n    @property\n    def session(self) -> \"Session\":\n        \"\"\"Pytest session object.\"\"\"\n        return self._pyfuncitem.session  # type: ignore[no-any-return]\n\n    def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n        \"\"\"Add finalizer/teardown function to be called after the last test\n        within the requesting test context finished execution.\"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones.\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer: Callable[[], object], scope) -> None:\n        node = self._getscopeitem(scope)\n        node.addfinalizer(finalizer)\n\n    def applymarker(self, marker: Union[str, MarkDecorator]) -> None:\n        \"\"\"Apply a marker to a single test function invocation.\n\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :param marker:\n            A :class:`pytest.MarkDecorator` object created by a call\n            to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg: Optional[str]) -> \"NoReturn\":\n        \"\"\"Raise a FixtureLookupError with the given message.\"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self) -> None:\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname: str) -> Any:\n        \"\"\"Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raises pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        fixturedef = self._get_active_fixturedef(argname)\n        assert fixturedef.cached_result is not None\n        return fixturedef.cached_result[0]\n\n    def _get_active_fixturedef(\n        self, argname: str\n    ) -> Union[\"FixtureDef[object]\", PseudoFixtureDef[object]]:\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope: _Scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # Remove indent to prevent the python3 exception\n        # from leaking into the call.\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self) -> List[\"FixtureDef[Any]\"]:\n        current = self\n        values: List[FixtureDef[Any]] = []\n        while isinstance(current, SubRequest):\n            values.append(current._fixturedef)  # type: ignore[has-type]\n            current = current._parent_request\n        values.reverse()\n        return values\n\n    def _compute_fixture_value(self, fixturedef: \"FixtureDef[object]\") -> None:\n        \"\"\"Create a SubRequest based on \"self\" and call the execute method\n        of the given FixtureDef object.\n\n        This will force the FixtureDef object to throw away any previous\n        results and compute a new fixture value, which will be stored into\n        the FixtureDef object itself.\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = absolutepath(frameinfo.filename)\n                source_lineno = frameinfo.lineno\n                try:\n                    source_path_str = str(\n                        source_path.relative_to(funcitem.config.rootpath)\n                    )\n                except ValueError:\n                    source_path_str = str(source_path)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path_str,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # If a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function.\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(\n            self, scope, param, param_index, fixturedef, _ispytest=True\n        )\n\n        # Check if a higher-level scoped fixture accesses a lower level one.\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # Call the fixture function.\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(\n        self, fixturedef: \"FixtureDef[object]\", subrequest: \"SubRequest\"\n    ) -> None:\n        # If fixture function failed it might have registered finalizers.\n        subrequest.node.addfinalizer(lambda: fixturedef.finish(request=subrequest))\n\n    def _check_scope(\n        self,\n        argname: str,\n        invoking_scope: \"_Scope\",\n        requested_scope: \"_Scope\",\n    ) -> None:\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # Try to report something helpful.\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self) -> List[str]:\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            if isinstance(fs, Path):\n                session: Session = self._pyfuncitem.session\n                p = bestrelpath(Path(session.fspath), fs)\n            else:\n                p = fs\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope: \"_Scope\") -> Union[nodes.Item, nodes.Collector]:\n        if scope == \"function\":\n            # This might also be a non-function Item despite its attribute name.\n            node: Optional[Union[nodes.Item, nodes.Collector]] = self._pyfuncitem\n        elif scope == \"package\":\n            # FIXME: _fixturedef is not defined on FixtureRequest (this class),\n            # but on FixtureRequest (a subclass).\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)  # type: ignore[attr-defined]\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # Fallback to function item itself.\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self) -> str:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#__init__().</name><path>src/_pytest/fixtures.py</path><content>    def __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None:\n        check_ispytest(_ispytest)\n        self._pyfuncitem = pyfuncitem\n        #: Fixture for which this request is being performed.\n        self.fixturename: Optional[str] = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\".\n        self.scope: _Scope = \"function\"\n        self._fixture_defs: Dict[str, FixtureDef[Any]] = {}\n        fixtureinfo: FuncFixtureInfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index: Dict[str, int] = {}</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#fixturenames().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def fixturenames(self) -> List[str]:\n        \"\"\"Names of all active fixtures in this request.\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#node().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def node(self):\n        \"\"\"Underlying collection node (depends on current request scope).\"\"\"</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_getnextfixturedef().</name><path>src/_pytest/fixtures.py</path><content>    def _getnextfixturedef(self, argname: str) -> \"FixtureDef[Any]\":\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # We arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time.\n            assert self._pyfuncitem.parent is not None\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            # TODO: Fix this type ignore. Either add assert or adjust types.\n            #       Can this be None here?\n            self._arg2fixturedefs[argname] = fixturedefs  # type: ignore[assignment]\n        # fixturedefs list is immutable so we maintain a decreasing index.\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#config().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def config(self) -> Config:\n        \"\"\"The pytest config object associated with this request.\"\"\"</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#function().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def function(self):\n        \"\"\"Test function object if the request has a per-function scope.\"\"\"\n        if self.scope != \"function\":\n            raise AttributeError(\n                f\"function not available in {self.scope}-scoped context\"\n            )</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#cls().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def cls(self):\n        \"\"\"Class (can be None) where the test function was collected.\"\"\"\n        if self.scope not in (\"class\", \"function\"):\n            raise AttributeError(f\"cls not available in {self.scope}-scoped context\")\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#instance().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def instance(self):\n        \"\"\"Instance (can be None) on which test function was collected.\"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction.\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#module().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def module(self):\n        \"\"\"Python module object where the test function was collected.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#fspath().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def fspath(self) -> py.path.local:\n        \"\"\"The file system path of the test module which collected this test.\"\"\"\n        if self.scope not in (\"function\", \"class\", \"module\", \"package\"):\n            raise AttributeError(f\"module not available in {self.scope}-scoped context\")\n        # TODO: Remove ignore once _pyfuncitem is properly typed.</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#keywords().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def keywords(self) -> MutableMapping[str, Any]:\n        \"\"\"Keywords/markers dictionary for the underlying node.\"\"\"\n        node: nodes.Node = self.node</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#session().</name><path>src/_pytest/fixtures.py</path><content>    @property\n    def session(self) -> \"Session\":\n        \"\"\"Pytest session object.\"\"\"</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#addfinalizer().</name><path>src/_pytest/fixtures.py</path><content>    def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n        \"\"\"Add finalizer/teardown function to be called after the last test\n        within the requesting test context finished execution.\"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones.</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_addfinalizer().</name><path>src/_pytest/fixtures.py</path><content>    def _addfinalizer(self, finalizer: Callable[[], object], scope) -> None:\n        node = self._getscopeitem(scope)</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#applymarker().</name><path>src/_pytest/fixtures.py</path><content>    def applymarker(self, marker: Union[str, MarkDecorator]) -> None:\n        \"\"\"Apply a marker to a single test function invocation.\n\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :param marker:\n            A :class:`pytest.MarkDecorator` object created by a call\n            to ``pytest.mark.NAME(...)``.\n        \"\"\"</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#raiseerror().</name><path>src/_pytest/fixtures.py</path><content>    def raiseerror(self, msg: Optional[str]) -> \"NoReturn\":\n        \"\"\"Raise a FixtureLookupError with the given message.\"\"\"</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_fillfixtures().</name><path>src/_pytest/fixtures.py</path><content>    def _fillfixtures(self) -> None:\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#getfixturevalue().</name><path>src/_pytest/fixtures.py</path><content>    def getfixturevalue(self, argname: str) -> Any:\n        \"\"\"Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raises pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        fixturedef = self._get_active_fixturedef(argname)\n        assert fixturedef.cached_result is not None</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_get_active_fixturedef().</name><path>src/_pytest/fixtures.py</path><content>    def _get_active_fixturedef(\n        self, argname: str\n    ) -> Union[\"FixtureDef[object]\", PseudoFixtureDef[object]]:\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope: _Scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # Remove indent to prevent the python3 exception\n        # from leaking into the call.\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_get_fixturestack().</name><path>src/_pytest/fixtures.py</path><content>    def _get_fixturestack(self) -> List[\"FixtureDef[Any]\"]:\n        current = self\n        values: List[FixtureDef[Any]] = []\n        while isinstance(current, SubRequest):\n            values.append(current._fixturedef)  # type: ignore[has-type]\n            current = current._parent_request\n        values.reverse()</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_compute_fixture_value().</name><path>src/_pytest/fixtures.py</path><content>    def _compute_fixture_value(self, fixturedef: \"FixtureDef[object]\") -> None:\n        \"\"\"Create a SubRequest based on \"self\" and call the execute method\n        of the given FixtureDef object.\n\n        This will force the FixtureDef object to throw away any previous\n        results and compute a new fixture value, which will be stored into\n        the FixtureDef object itself.\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = absolutepath(frameinfo.filename)\n                source_lineno = frameinfo.lineno\n                try:\n                    source_path_str = str(\n                        source_path.relative_to(funcitem.config.rootpath)\n                    )\n                except ValueError:\n                    source_path_str = str(source_path)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path_str,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # If a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function.\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(\n            self, scope, param, param_index, fixturedef, _ispytest=True\n        )\n\n        # Check if a higher-level scoped fixture accesses a lower level one.\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # Call the fixture function.\n            fixturedef.execute(request=subrequest)\n        finally:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_schedule_finalizers().</name><path>src/_pytest/fixtures.py</path><content>    def _schedule_finalizers(\n        self, fixturedef: \"FixtureDef[object]\", subrequest: \"SubRequest\"\n    ) -> None:\n        # If fixture function failed it might have registered finalizers.</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_check_scope().</name><path>src/_pytest/fixtures.py</path><content>    def _check_scope(\n        self,\n        argname: str,\n        invoking_scope: \"_Scope\",\n        requested_scope: \"_Scope\",\n    ) -> None:\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # Try to report something helpful.\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_factorytraceback().</name><path>src/_pytest/fixtures.py</path><content>    def _factorytraceback(self) -> List[str]:\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            if isinstance(fs, Path):\n                session: Session = self._pyfuncitem.session\n                p = bestrelpath(Path(session.fspath), fs)\n            else:\n                p = fs\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#_getscopeitem().</name><path>src/_pytest/fixtures.py</path><content>    def _getscopeitem(self, scope: \"_Scope\") -> Union[nodes.Item, nodes.Collector]:\n        if scope == \"function\":\n            # This might also be a non-function Item despite its attribute name.\n            node: Optional[Union[nodes.Item, nodes.Collector]] = self._pyfuncitem\n        elif scope == \"package\":\n            # FIXME: _fixturedef is not defined on FixtureRequest (this class),\n            # but on FixtureRequest (a subclass).\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)  # type: ignore[attr-defined]\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # Fallback to function item itself.\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureRequest#__repr__().</name><path>src/_pytest/fixtures.py</path><content>    def __repr__(self) -> str:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#</name><path>src/_pytest/fixtures.py</path><content>@final\nclass FixtureDef(Generic[_FixtureValue]):\n    \"\"\"A container for a factory definition.\"\"\"\n\n    def __init__(\n        self,\n        fixturemanager: \"FixtureManager\",\n        baseid: Optional[str],\n        argname: str,\n        func: \"_FixtureFunc[_FixtureValue]\",\n        scope: \"Union[_Scope, Callable[[str, Config], _Scope]]\",\n        params: Optional[Sequence[object]],\n        unittest: bool = False,\n        ids: Optional[\n            Union[\n                Tuple[Union[None, str, float, int, bool], ...],\n                Callable[[Any], Optional[object]],\n            ]\n        ] = None,\n    ) -> None:\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        if callable(scope):\n            scope_ = _eval_scope_callable(scope, argname, fixturemanager.config)\n        else:\n            scope_ = scope\n        self.scopenum = scope2index(\n            # TODO: Check if the `or` here is really necessary.\n            scope_ or \"function\",  # type: ignore[unreachable]\n            descr=f\"Fixture '{func.__name__}'\",\n            where=baseid,\n        )\n        self.scope = scope_\n        self.params: Optional[Sequence[object]] = params\n        self.argnames: Tuple[str, ...] = getfuncargnames(\n            func, name=argname, is_method=unittest\n        )\n        self.unittest = unittest\n        self.ids = ids\n        self.cached_result: Optional[_FixtureCachedResult[_FixtureValue]] = None\n        self._finalizers: List[Callable[[], object]] = []\n\n    def addfinalizer(self, finalizer: Callable[[], object]) -> None:\n        self._finalizers.append(finalizer)\n\n    def finish(self, request: SubRequest) -> None:\n        exc = None\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except BaseException as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n            if exc:\n                raise exc\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # Even if finalization fails, we invalidate the cached fixture\n            # value and remove all finalizers because they may be bound methods\n            # which will keep instances alive.\n            self.cached_result = None\n            self._finalizers = []\n\n    def execute(self, request: SubRequest) -> _FixtureValue:\n        # Get required arguments and register our own finish()\n        # with their finalization.\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                # PseudoFixtureDef is only for \"request\".\n                assert isinstance(fixturedef, FixtureDef)\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = self.cache_key(request)\n        if self.cached_result is not None:\n            # note: comparison with `==` can fail (or be expensive) for e.g.\n            # numpy arrays (#6497).\n            cache_key = self.cached_result[1]\n            if my_cache_key is cache_key:\n                if self.cached_result[2] is not None:\n                    _, val, tb = self.cached_result[2]\n                    raise val.with_traceback(tb)\n                else:\n                    result = self.cached_result[0]\n                    return result\n            # We have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one.\n            self.finish(request)\n            assert self.cached_result is None\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        result = hook.pytest_fixture_setup(fixturedef=self, request=request)\n        return result\n\n    def cache_key(self, request: SubRequest) -> object:\n        return request.param_index if not hasattr(request, \"param\") else request.param\n\n    def __repr__(self) -> str:\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#__init__().</name><path>src/_pytest/fixtures.py</path><content>    def __init__(\n        self,\n        fixturemanager: \"FixtureManager\",\n        baseid: Optional[str],\n        argname: str,\n        func: \"_FixtureFunc[_FixtureValue]\",\n        scope: \"Union[_Scope, Callable[[str, Config], _Scope]]\",\n        params: Optional[Sequence[object]],\n        unittest: bool = False,\n        ids: Optional[\n            Union[\n                Tuple[Union[None, str, float, int, bool], ...],\n                Callable[[Any], Optional[object]],\n            ]\n        ] = None,\n    ) -> None:\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        if callable(scope):\n            scope_ = _eval_scope_callable(scope, argname, fixturemanager.config)\n        else:\n            scope_ = scope\n        self.scopenum = scope2index(\n            # TODO: Check if the `or` here is really necessary.\n            scope_ or \"function\",  # type: ignore[unreachable]\n            descr=f\"Fixture '{func.__name__}'\",\n            where=baseid,\n        )\n        self.scope = scope_\n        self.params: Optional[Sequence[object]] = params\n        self.argnames: Tuple[str, ...] = getfuncargnames(\n            func, name=argname, is_method=unittest\n        )\n        self.unittest = unittest\n        self.ids = ids\n        self.cached_result: Optional[_FixtureCachedResult[_FixtureValue]] = None</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#addfinalizer().</name><path>src/_pytest/fixtures.py</path><content>    def addfinalizer(self, finalizer: Callable[[], object]) -> None:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#finish().</name><path>src/_pytest/fixtures.py</path><content>    def finish(self, request: SubRequest) -> None:\n        exc = None\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except BaseException as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n            if exc:\n                raise exc\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # Even if finalization fails, we invalidate the cached fixture\n            # value and remove all finalizers because they may be bound methods\n            # which will keep instances alive.\n            self.cached_result = None</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#execute().</name><path>src/_pytest/fixtures.py</path><content>    def execute(self, request: SubRequest) -> _FixtureValue:\n        # Get required arguments and register our own finish()\n        # with their finalization.\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                # PseudoFixtureDef is only for \"request\".\n                assert isinstance(fixturedef, FixtureDef)\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = self.cache_key(request)\n        if self.cached_result is not None:\n            # note: comparison with `==` can fail (or be expensive) for e.g.\n            # numpy arrays (#6497).\n            cache_key = self.cached_result[1]\n            if my_cache_key is cache_key:\n                if self.cached_result[2] is not None:\n                    _, val, tb = self.cached_result[2]\n                    raise val.with_traceback(tb)\n                else:\n                    result = self.cached_result[0]\n                    return result\n            # We have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one.\n            self.finish(request)\n            assert self.cached_result is None\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        result = hook.pytest_fixture_setup(fixturedef=self, request=request)</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#cache_key().</name><path>src/_pytest/fixtures.py</path><content>    def cache_key(self, request: SubRequest) -> object:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureDef#__repr__().</name><path>src/_pytest/fixtures.py</path><content>    def __repr__(self) -> str:\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#</name><path>src/_pytest/fixtures.py</path><content>class FixtureManager:\n    \"\"\"pytest fixture definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function. An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i.e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session: \"Session\") -> None:\n        self.session = session\n        self.config: Config = session.config\n        self._arg2fixturedefs: Dict[str, List[FixtureDef[Any]]] = {}\n        self._holderobjseen: Set[object] = set()\n        # A mapping from a nodeid to a list of autouse fixtures it defines.\n        self._nodeid_autousenames: Dict[str, List[str]] = {\n            \"\": self.config.getini(\"usefixtures\"),\n        }\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node: nodes.Node) -> List[str]:\n        \"\"\"Return all direct parametrization arguments of a node, so we don't\n        mistake them for fixtures.\n\n        Check https://github.com/pytest-dev/pytest/issues/5036.\n\n        These things are done later as well when dealing with parametrization\n        so this could be improved.\n        \"\"\"\n        parametrize_argnames: List[str] = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(\n        self, node: nodes.Node, func, cls, funcargs: bool = True\n    ) -> FuncFixtureInfo:\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = tuple(\n            arg for mark in node.iter_markers(name=\"usefixtures\") for arg in mark.args\n        )\n        initialnames = usefixtures + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin: _PluggyPlugin) -> None:\n        nodeid = None\n        try:\n            p = absolutepath(plugin.__file__)  # type: ignore[attr-defined]\n        except AttributeError:\n            pass\n        else:\n            # Construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id).\n            if p.name.startswith(\"conftest.py\"):\n                try:\n                    nodeid = str(p.parent.relative_to(self.config.rootpath))\n                except ValueError:\n                    nodeid = \"\"\n                if nodeid == \".\":\n                    nodeid = \"\"\n                if os.sep != nodes.SEP:\n                    nodeid = nodeid.replace(os.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid: str) -> Iterator[str]:\n        \"\"\"Return the names of autouse fixtures applicable to nodeid.\"\"\"\n        for parentnodeid in nodes.iterparentnodeids(nodeid):\n            basenames = self._nodeid_autousenames.get(parentnodeid)\n            if basenames:\n                yield from basenames\n\n    def getfixtureclosure(\n        self,\n        fixturenames: Tuple[str, ...],\n        parentnode: nodes.Node,\n        ignore_args: Sequence[str] = (),\n    ) -> Tuple[Tuple[str, ...], List[str], Dict[str, Sequence[FixtureDef[Any]]]]:\n        # Collect the closure of all fixtures, starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive).\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = list(self._getautousenames(parentid))\n\n        def merge(otherlist: Iterable[str]) -> None:\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # At this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs: Dict[str, Sequence[FixtureDef[Any]]] = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc: \"Metafunc\") -> None:\n        \"\"\"Generate new tests based on parametrized fixtures used by the given metafunc\"\"\"\n\n        def get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:\n            args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)\n            return args\n\n        for argname in metafunc.fixturenames:\n            # Get the FixtureDefs for the argname.\n            fixture_defs = metafunc._arg2fixturedefs.get(argname)\n            if not fixture_defs:\n                # Will raise FixtureLookupError at setup time if not parametrized somewhere\n                # else (e.g @pytest.mark.parametrize)\n                continue\n\n            # If the test itself parametrizes using this argname, give it\n            # precedence.\n            if any(\n                argname in get_parametrize_mark_argnames(mark)\n                for mark in metafunc.definition.iter_markers(\"parametrize\")\n            ):\n                continue\n\n            # In the common case we only look at the fixture def with the\n            # closest scope (last in the list). But if the fixture overrides\n            # another fixture, while requesting the super fixture, keep going\n            # in case the super fixture is parametrized (#1953).\n            for fixturedef in reversed(fixture_defs):\n                # Fixture is parametrized, apply it and stop.\n                if fixturedef.params is not None:\n                    metafunc.parametrize(\n                        argname,\n                        fixturedef.params,\n                        indirect=True,\n                        scope=fixturedef.scope,\n                        ids=fixturedef.ids,\n                    )\n                    break\n\n                # Not requesting the overridden super fixture, stop.\n                if argname not in fixturedef.argnames:\n                    break\n\n                # Try next super fixture, if any.\n\n    def pytest_collection_modifyitems(self, items: List[nodes.Item]) -> None:\n        # Separate parametrized setups.\n        items[:] = reorder_items(items)\n\n    def parsefactories(\n        self, node_or_obj, nodeid=NOTSET, unittest: bool = False\n    ) -> None:\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # Magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute.\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # During fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in\n            # order to not emit the warning when pytest itself calls the\n            # fixture function.\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                fixturemanager=self,\n                baseid=nodeid,\n                argname=name,\n                func=obj,\n                scope=marker.scope,\n                params=marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_autousenames.setdefault(nodeid or \"\", []).extend(autousenames)\n\n    def getfixturedefs(\n        self, argname: str, nodeid: str\n    ) -> Optional[Sequence[FixtureDef[Any]]]:\n        \"\"\"Get a list of fixtures which are applicable to the given node id.\n\n        :param str argname: Name of the fixture to search for.\n        :param str nodeid: Full node id of the requesting test.\n        :rtype: Sequence[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(\n        self, fixturedefs: Iterable[FixtureDef[Any]], nodeid: str\n    ) -> Iterator[FixtureDef[Any]]:\n        parentnodeids = set(nodes.iterparentnodeids(nodeid))\n        for fixturedef in fixturedefs:\n            if fixturedef.baseid in parentnodeids:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#__init__().</name><path>src/_pytest/fixtures.py</path><content>    def __init__(self, session: \"Session\") -> None:\n        self.session = session\n        self.config: Config = session.config\n        self._arg2fixturedefs: Dict[str, List[FixtureDef[Any]]] = {}\n        self._holderobjseen: Set[object] = set()\n        # A mapping from a nodeid to a list of autouse fixtures it defines.\n        self._nodeid_autousenames: Dict[str, List[str]] = {\n            \"\": self.config.getini(\"usefixtures\"),\n        }</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#_get_direct_parametrize_args().</name><path>src/_pytest/fixtures.py</path><content>    def _get_direct_parametrize_args(self, node: nodes.Node) -> List[str]:\n        \"\"\"Return all direct parametrization arguments of a node, so we don't\n        mistake them for fixtures.\n\n        Check https://github.com/pytest-dev/pytest/issues/5036.\n\n        These things are done later as well when dealing with parametrization\n        so this could be improved.\n        \"\"\"\n        parametrize_argnames: List[str] = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#getfixtureinfo().</name><path>src/_pytest/fixtures.py</path><content>    def getfixtureinfo(\n        self, node: nodes.Node, func, cls, funcargs: bool = True\n    ) -> FuncFixtureInfo:\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = tuple(\n            arg for mark in node.iter_markers(name=\"usefixtures\") for arg in mark.args\n        )\n        initialnames = usefixtures + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#pytest_plugin_registered().</name><path>src/_pytest/fixtures.py</path><content>    def pytest_plugin_registered(self, plugin: _PluggyPlugin) -> None:\n        nodeid = None\n        try:\n            p = absolutepath(plugin.__file__)  # type: ignore[attr-defined]\n        except AttributeError:\n            pass\n        else:\n            # Construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id).\n            if p.name.startswith(\"conftest.py\"):\n                try:\n                    nodeid = str(p.parent.relative_to(self.config.rootpath))\n                except ValueError:\n                    nodeid = \"\"\n                if nodeid == \".\":\n                    nodeid = \"\"\n                if os.sep != nodes.SEP:\n                    nodeid = nodeid.replace(os.sep, nodes.SEP)\n</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#_getautousenames().</name><path>src/_pytest/fixtures.py</path><content>    def _getautousenames(self, nodeid: str) -> Iterator[str]:\n        \"\"\"Return the names of autouse fixtures applicable to nodeid.\"\"\"\n        for parentnodeid in nodes.iterparentnodeids(nodeid):\n            basenames = self._nodeid_autousenames.get(parentnodeid)\n            if basenames:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#getfixtureclosure().</name><path>src/_pytest/fixtures.py</path><content>    def getfixtureclosure(\n        self,\n        fixturenames: Tuple[str, ...],\n        parentnode: nodes.Node,\n        ignore_args: Sequence[str] = (),\n    ) -> Tuple[Tuple[str, ...], List[str], Dict[str, Sequence[FixtureDef[Any]]]]:\n        # Collect the closure of all fixtures, starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive).\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = list(self._getautousenames(parentid))\n\n        def merge(otherlist: Iterable[str]) -> None:\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # At this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs: Dict[str, Sequence[FixtureDef[Any]]] = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#merge().</name><path>src/_pytest/fixtures.py</path><content>        def merge(otherlist: Iterable[str]) -> None:\n            for arg in otherlist:\n                if arg not in fixturenames_closure:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#sort_by_scope().</name><path>src/_pytest/fixtures.py</path><content>        def sort_by_scope(arg_name: str) -> int:\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#pytest_generate_tests().</name><path>src/_pytest/fixtures.py</path><content>    def pytest_generate_tests(self, metafunc: \"Metafunc\") -> None:\n        \"\"\"Generate new tests based on parametrized fixtures used by the given metafunc\"\"\"\n\n        def get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:\n            args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)\n            return args\n\n        for argname in metafunc.fixturenames:\n            # Get the FixtureDefs for the argname.\n            fixture_defs = metafunc._arg2fixturedefs.get(argname)\n            if not fixture_defs:\n                # Will raise FixtureLookupError at setup time if not parametrized somewhere\n                # else (e.g @pytest.mark.parametrize)\n                continue\n\n            # If the test itself parametrizes using this argname, give it\n            # precedence.\n            if any(\n                argname in get_parametrize_mark_argnames(mark)\n                for mark in metafunc.definition.iter_markers(\"parametrize\")\n            ):\n                continue\n\n            # In the common case we only look at the fixture def with the\n            # closest scope (last in the list). But if the fixture overrides\n            # another fixture, while requesting the super fixture, keep going\n            # in case the super fixture is parametrized (#1953).\n            for fixturedef in reversed(fixture_defs):\n                # Fixture is parametrized, apply it and stop.\n                if fixturedef.params is not None:\n                    metafunc.parametrize(\n                        argname,\n                        fixturedef.params,\n                        indirect=True,\n                        scope=fixturedef.scope,\n                        ids=fixturedef.ids,\n                    )\n                    break\n\n                # Not requesting the overridden super fixture, stop.\n                if argname not in fixturedef.argnames:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#get_parametrize_mark_argnames().</name><path>src/_pytest/fixtures.py</path><content>        def get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:\n            args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#pytest_collection_modifyitems().</name><path>src/_pytest/fixtures.py</path><content>    def pytest_collection_modifyitems(self, items: List[nodes.Item]) -> None:\n        # Separate parametrized setups.</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#parsefactories().</name><path>src/_pytest/fixtures.py</path><content>    def parsefactories(\n        self, node_or_obj, nodeid=NOTSET, unittest: bool = False\n    ) -> None:\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # Magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute.\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # During fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in\n            # order to not emit the warning when pytest itself calls the\n            # fixture function.\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                fixturemanager=self,\n                baseid=nodeid,\n                argname=name,\n                func=obj,\n                scope=marker.scope,\n                params=marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#getfixturedefs().</name><path>src/_pytest/fixtures.py</path><content>    def getfixturedefs(\n        self, argname: str, nodeid: str\n    ) -> Optional[Sequence[FixtureDef[Any]]]:\n        \"\"\"Get a list of fixtures which are applicable to the given node id.\n\n        :param str argname: Name of the fixture to search for.\n        :param str nodeid: Full node id of the requesting test.\n        :rtype: Sequence[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>FixtureManager#_matchfactories().</name><path>src/_pytest/fixtures.py</path><content>    def _matchfactories(\n        self, fixturedefs: Iterable[FixtureDef[Any]], nodeid: str\n    ) -> Iterator[FixtureDef[Any]]:\n        parentnodeids = set(nodes.iterparentnodeids(nodeid))\n        for fixturedef in fixturedefs:\n            if fixturedef.baseid in parentnodeids:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>pytest_runtest_makereport().</name><path>src/_pytest/runner.py</path><content>def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>pytest_make_collect_report().</name><path>src/_pytest/runner.py</path><content>def pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"unittest\")\n        if unittest is not None:\n            # Type ignored because unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if isinstance(call.excinfo.value, tuple(skip_exceptions)):\n            if unittest is not None and isinstance(\n                call.excinfo.value, unittest.SkipTest  # type: ignore[attr-defined]\n            ):\n                warnings.warn(UNITTEST_SKIP_DURING_COLLECTION, stacklevel=2)\n\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                assert isinstance(errorinfo, str)\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    result = call.result if not call.excinfo else None\n    rep = CollectReport(collector.nodeid, outcome, longrepr, result)\n    rep.call = call  # type: ignore # see collect_one_node</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>SetupState#setup().</name><path>src/_pytest/runner.py</path><content>    def setup(self, item: Item) -> None:\n        \"\"\"Setup objects along the collector chain to the item.\"\"\"\n        needed_collectors = item.listchain()\n\n        # If a collector fails its setup, fail its entire subtree of items.\n        # The setup is not retried for each item - the same exception is used.\n        for col, (finalizers, exc) in self.stack.items():\n            assert col in needed_collectors, \"previous item was not torn down properly\"\n            if exc:\n                raise exc\n\n        for col in needed_collectors[len(self.stack) :]:\n            assert col not in self.stack\n            # Push onto the stack.\n            self.stack[col] = ([col.teardown], None)\n            try:\n                col.setup()\n            except TEST_OUTCOME as exc:\n                self.stack[col] = (self.stack[col][0], exc)</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<high_relevant_symbol><name>SetupState#teardown_exact().</name><path>src/_pytest/runner.py</path><content>    def teardown_exact(self, nextitem: Optional[Item]) -> None:\n        \"\"\"Teardown the current stack up until reaching nodes that nextitem\n        also descends from.\n\n        When nextitem is None (meaning we're at the last item), the entire\n        stack is torn down.\n        \"\"\"\n        needed_collectors = nextitem and nextitem.listchain() or []\n        exc = None\n        while self.stack:\n            if list(self.stack.keys()) == needed_collectors[: len(self.stack)]:\n                break\n            node, (finalizers, _) = self.stack.popitem()\n            while finalizers:\n                fin = finalizers.pop()\n                try:\n                    fin()\n                except TEST_OUTCOME as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n        if exc:\n            raise exc\n        if nextitem is None:</content></high_relevant_symbol>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>add_funcarg_pseudo_fixture_def().</name><path>src/_pytest/fixtures.py</path><content>def add_funcarg_pseudo_fixture_def(\n    collector: nodes.Collector, metafunc: \"Metafunc\", fixturemanager: \"FixtureManager\"\n) -> None:\n    # This function will transform all collected calls to functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        # This function call does not have direct parametrization.\n        return\n    # Collect funcargs of all callspecs into a list of values.\n    arg2params: Dict[str, List[object]] = {}\n    arg2scope: Dict[str, _Scope] = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # Register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # If we have a scope that is higher than function, we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # Use module-level collector for class-scope (for now).\n                node = collector\n        if node is None:\n            name2pseudofixturedef = None\n        else:\n            default: Dict[str, FixtureDef[Any]] = {}\n            name2pseudofixturedef = node._store.setdefault(\n                name2pseudofixturedef_key, default\n            )\n        if name2pseudofixturedef is not None and argname in name2pseudofixturedef:\n            arg2fixturedefs[argname] = [name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager=fixturemanager,\n                baseid=\"\",\n                argname=argname,\n                func=get_direct_param_fixture_func,\n                scope=arg2scope[argname],\n                params=valuelist,\n                unittest=False,\n                ids=None,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if name2pseudofixturedef is not None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>getfixturemarker().</name><path>src/_pytest/fixtures.py</path><content>def getfixturemarker(obj: object) -> Optional[\"FixtureFunctionMarker\"]:\n    \"\"\"Return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        fixturemarker: Optional[FixtureFunctionMarker] = getattr(\n            obj, \"_pytestfixturefunction\", None\n        )\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>pytest_fixture_setup().</name><path>src/_pytest/fixtures.py</path><content>def pytest_fixture_setup(\n    fixturedef: FixtureDef[_FixtureValue], request: SubRequest\n) -> _FixtureValue:\n    \"\"\"Execution of fixture setup.\"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        assert fixdef.cached_result is not None\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = fixturedef.cache_key(request)\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        exc_info = sys.exc_info()\n        assert exc_info[0] is not None\n        fixturedef.cached_result = (None, my_cache_key, exc_info)\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>main().</name><path>src/_pytest/config/__init__.py</path><content>def main(\n    args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n    plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n) -> Union[int, ExitCode]:\n    \"\"\"Perform an in-process test run.\n\n    :param args: List of command line arguments.\n    :param plugins: List of plugin objects to be auto-registered during initialization.\n\n    :returns: An exit code.\n    \"\"\"\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = TerminalWriter(sys.stderr)\n            tw.line(f\"ImportError while loading conftest '{e.path}'.\", red=True)\n            exc_info.traceback = exc_info.traceback.filter(\n                filter_traceback_for_conftest_import_failure\n            )\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\n                    config=config\n                )\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(f\"ERROR: {msg}\\n\", red=True)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>console_main().</name><path>src/_pytest/config/__init__.py</path><content>def console_main() -> int:\n    \"\"\"The CLI entry point of pytest.\n\n    This function is not meant for programmable use; use `main()` instead.\n    \"\"\"\n    # https://docs.python.org/3/library/signal.html#note-on-sigpipe\n    try:\n        code = main()\n        sys.stdout.flush()\n        return code\n    except BrokenPipeError:\n        # Python flushes standard streams on exit; redirect remaining output\n        # to devnull to avoid another BrokenPipeError at shutdown\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>get_config().</name><path>src/_pytest/config/__init__.py</path><content>def get_config(\n    args: Optional[List[str]] = None,\n    plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n) -> \"Config\":\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (),\n            plugins=plugins,\n            dir=Path.cwd(),\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args, exclude_only=True)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#</name><path>src/_pytest/config/__init__.py</path><content>@final\nclass PytestPluginManager(PluginManager):\n    \"\"\"A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\n    additional pytest-specific functionality:\n\n    * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded.\n    * ``conftest.py`` loading during start-up.\n    \"\"\"\n\n    def __init__(self) -> None:\n        import _pytest.assertion\n\n        super().__init__(\"pytest\")\n        # The objects are module objects, only used generically.\n        self._conftest_plugins: Set[types.ModuleType] = set()\n\n        # State related to local conftest plugins.\n        self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n        self._conftestpath2mod: Dict[Path, types.ModuleType] = {}\n        self._confcutdir: Optional[Path] = None\n        self._noconftest = False\n        self._duplicatepaths: Set[Path] = set()\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: List[Tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n        # pytest hooks are always prefixed with \"pytest_\",\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073).\n        if not name.startswith(\"pytest_\"):\n            return\n        # Ignore names which can not be hooks.\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # Consider only actual functions for hooks (#3775).\n        if not inspect.isroutine(method):\n            return\n\n        # Collect unmarked hooks as long as they have the `pytest_' prefix.\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name: str):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(\n        self, plugin: _PluggyPlugin, name: Optional[str] = None\n    ) -> Optional[str]:\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                    \"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return None\n        ret: Optional[str] = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name: str):\n        # Support deprecated naming because plugins (xdist e.g.) use it.\n        plugin: Optional[_PluggyPlugin] = self.get_plugin(name)\n        return plugin\n\n    def hasplugin(self, name: str) -> bool:\n        \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config: \"Config\") -> None:\n        \"\"\":meta private:\"\"\"\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers.\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # Internal API for local conftest plugin handling.\n    #\n    def _set_initial_conftests(self, namespace: argparse.Namespace) -> None:\n        \"\"\"Load initial conftest files given a preparsed \"namespace\".\n\n        As conftest files may add their own command line options which have\n        arguments ('--my-opt somepath') we might get some false positives.\n        All builtin and 3rd party plugins will have been loaded, however, so\n        common options will not confuse our logic here.\n        \"\"\"\n        current = Path.cwd()\n        self._confcutdir = (\n            absolutepath(current / namespace.confcutdir)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for testpath in testpaths:\n            path = str(testpath)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = absolutepath(current / path)\n            if anchor.exists():  # we found some file object\n                self._try_load_conftest(anchor, namespace.importmode)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current, namespace.importmode)\n\n    def _try_load_conftest(\n        self, anchor: Path, importmode: Union[str, ImportMode]\n    ) -> None:\n        self._getconftestmodules(anchor, importmode)\n        # let's also consider test* subdirs\n        if anchor.is_dir():\n            for x in anchor.glob(\"test*\"):\n                if x.is_dir():\n                    self._getconftestmodules(x, importmode)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(\n        self,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> List[types.ModuleType]:\n        if self._noconftest:\n            return []\n\n        if path.is_file():\n            directory = path.parent\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootpath\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir.\n        clist = []\n        for parent in reversed((directory, *directory.parents)):\n            if self._confcutdir and parent in self._confcutdir.parents:\n                continue\n            conftestpath = parent / \"conftest.py\"\n            if conftestpath.is_file():\n                mod = self._importconftest(conftestpath, importmode)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(\n        self,\n        name: str,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> Tuple[types.ModuleType, Any]:\n        modules = self._getconftestmodules(path, importmode)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(\n        self,\n        conftestpath: Path,\n        importmode: Union[str, ImportMode],\n    ) -> types.ModuleType:\n        # Use a resolved Path object as key to avoid loading the same conftest\n        # twice with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = conftestpath.resolve()\n\n        with contextlib.suppress(KeyError):\n            return self._conftestpath2mod[key]\n\n        pkgpath = resolve_package_path(conftestpath)\n        if pkgpath is None:\n            _ensure_removed_sysmodule(conftestpath.stem)\n\n        try:\n            mod = import_path(conftestpath, mode=importmode)\n        except Exception as e:\n            assert e.__traceback__ is not None\n            exc_info = (type(e), e, e.__traceback__)\n            raise ConftestImportFailure(conftestpath, exc_info) from e\n\n        self._check_non_top_pytest_plugins(mod, conftestpath)\n\n        self._conftest_plugins.add(mod)\n        self._conftestpath2mod[key] = mod\n        dirpath = conftestpath.parent\n        if dirpath in self._dirpath2confmods:\n            for path, mods in self._dirpath2confmods.items():\n                if path and dirpath in path.parents or path == dirpath:\n                    assert mod not in mods\n                    mods.append(mod)\n        self.trace(f\"loading conftestmodule {mod!r}\")\n        self.consider_conftest(mod)\n        return mod\n\n    def _check_non_top_pytest_plugins(\n        self,\n        mod: types.ModuleType,\n        conftestpath: Path,\n    ) -> None:\n        if (\n            hasattr(mod, \"pytest_plugins\")\n            and self._configured\n            and not self._using_pyargs\n        ):\n            msg = (\n                \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n                \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n                \"  {}\\n\"\n                \"Please move it to a top level conftest file at the rootdir:\\n\"\n                \"  {}\\n\"\n                \"For more information, visit:\\n\"\n                \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n            )\n            fail(msg.format(conftestpath, self._confcutdir), pytrace=False)\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(\n        self, args: Sequence[str], *, exclude_only: bool = False\n    ) -> None:\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                if exclude_only and not parg.startswith(\"no:\"):\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg: str) -> None:\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304: remove stepwise if cacheprovider is blocked.\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule: types.ModuleType) -> None:\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self) -> None:\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod: types.ModuleType) -> None:\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(\n        self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n    ) -> None:\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n        \"\"\"Import a plugin with ``modname``.\n\n        If ``consider_entry_points`` is True, entry point names are also\n        considered to find a plugin.\n        \"\"\"\n        # Most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            raise ImportError(\n                'Error importing plugin \"{}\": {}'.format(modname, str(e.args[0]))\n            ).with_traceback(e.__traceback__) from e\n\n        except Skipped as e:\n            self.skipped_plugins.append((modname, e.msg or \"\"))\n        else:\n            mod = sys.modules[importspec]</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#__init__().</name><path>src/_pytest/config/__init__.py</path><content>    def __init__(self) -> None:\n        import _pytest.assertion\n\n        super().__init__(\"pytest\")\n        # The objects are module objects, only used generically.\n        self._conftest_plugins: Set[types.ModuleType] = set()\n\n        # State related to local conftest plugins.\n        self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n        self._conftestpath2mod: Dict[Path, types.ModuleType] = {}\n        self._confcutdir: Optional[Path] = None\n        self._noconftest = False\n        self._duplicatepaths: Set[Path] = set()\n\n        # plugins that were explicitly skipped with pytest.skip\n        # list of (module name, skip reason)\n        # previously we would issue a warning when a plugin was skipped, but\n        # since we refactored warnings as first citizens of Config, they are\n        # just stored here to be used later.\n        self.skipped_plugins: List[Tuple[str, str]] = []\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err: IO[str] = sys.stderr\n            encoding: str = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()),\n                    mode=err.mode,\n                    buffering=1,\n                    encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage.</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#parse_hookimpl_opts().</name><path>src/_pytest/config/__init__.py</path><content>    def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n        # pytest hooks are always prefixed with \"pytest_\",\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073).\n        if not name.startswith(\"pytest_\"):\n            return\n        # Ignore names which can not be hooks.\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # Consider only actual functions for hooks (#3775).\n        if not inspect.isroutine(method):\n            return\n\n        # Collect unmarked hooks as long as they have the `pytest_' prefix.\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#parse_hookspec_opts().</name><path>src/_pytest/config/__init__.py</path><content>    def parse_hookspec_opts(self, module_or_class, name: str):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#register().</name><path>src/_pytest/config/__init__.py</path><content>    def register(\n        self, plugin: _PluggyPlugin, name: Optional[str] = None\n    ) -> Optional[str]:\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                    \"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return None\n        ret: Optional[str] = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#getplugin().</name><path>src/_pytest/config/__init__.py</path><content>    def getplugin(self, name: str):\n        # Support deprecated naming because plugins (xdist e.g.) use it.\n        plugin: Optional[_PluggyPlugin] = self.get_plugin(name)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#hasplugin().</name><path>src/_pytest/config/__init__.py</path><content>    def hasplugin(self, name: str) -> bool:\n        \"\"\"Return whether a plugin with the given name is registered.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#pytest_configure().</name><path>src/_pytest/config/__init__.py</path><content>    def pytest_configure(self, config: \"Config\") -> None:\n        \"\"\":meta private:\"\"\"\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers.\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_set_initial_conftests().</name><path>src/_pytest/config/__init__.py</path><content>    def _set_initial_conftests(self, namespace: argparse.Namespace) -> None:\n        \"\"\"Load initial conftest files given a preparsed \"namespace\".\n\n        As conftest files may add their own command line options which have\n        arguments ('--my-opt somepath') we might get some false positives.\n        All builtin and 3rd party plugins will have been loaded, however, so\n        common options will not confuse our logic here.\n        \"\"\"\n        current = Path.cwd()\n        self._confcutdir = (\n            absolutepath(current / namespace.confcutdir)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for testpath in testpaths:\n            path = str(testpath)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = absolutepath(current / path)\n            if anchor.exists():  # we found some file object\n                self._try_load_conftest(anchor, namespace.importmode)\n                foundanchor = True\n        if not foundanchor:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_try_load_conftest().</name><path>src/_pytest/config/__init__.py</path><content>    def _try_load_conftest(\n        self, anchor: Path, importmode: Union[str, ImportMode]\n    ) -> None:\n        self._getconftestmodules(anchor, importmode)\n        # let's also consider test* subdirs\n        if anchor.is_dir():\n            for x in anchor.glob(\"test*\"):\n                if x.is_dir():</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_getconftestmodules().</name><path>src/_pytest/config/__init__.py</path><content>    @lru_cache(maxsize=128)\n    def _getconftestmodules(\n        self,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> List[types.ModuleType]:\n        if self._noconftest:\n            return []\n\n        if path.is_file():\n            directory = path.parent\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootpath\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir.\n        clist = []\n        for parent in reversed((directory, *directory.parents)):\n            if self._confcutdir and parent in self._confcutdir.parents:\n                continue\n            conftestpath = parent / \"conftest.py\"\n            if conftestpath.is_file():\n                mod = self._importconftest(conftestpath, importmode)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_rget_with_confmod().</name><path>src/_pytest/config/__init__.py</path><content>    def _rget_with_confmod(\n        self,\n        name: str,\n        path: Path,\n        importmode: Union[str, ImportMode],\n    ) -> Tuple[types.ModuleType, Any]:\n        modules = self._getconftestmodules(path, importmode)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_importconftest().</name><path>src/_pytest/config/__init__.py</path><content>    def _importconftest(\n        self,\n        conftestpath: Path,\n        importmode: Union[str, ImportMode],\n    ) -> types.ModuleType:\n        # Use a resolved Path object as key to avoid loading the same conftest\n        # twice with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = conftestpath.resolve()\n\n        with contextlib.suppress(KeyError):\n            return self._conftestpath2mod[key]\n\n        pkgpath = resolve_package_path(conftestpath)\n        if pkgpath is None:\n            _ensure_removed_sysmodule(conftestpath.stem)\n\n        try:\n            mod = import_path(conftestpath, mode=importmode)\n        except Exception as e:\n            assert e.__traceback__ is not None\n            exc_info = (type(e), e, e.__traceback__)\n            raise ConftestImportFailure(conftestpath, exc_info) from e\n\n        self._check_non_top_pytest_plugins(mod, conftestpath)\n\n        self._conftest_plugins.add(mod)\n        self._conftestpath2mod[key] = mod\n        dirpath = conftestpath.parent\n        if dirpath in self._dirpath2confmods:\n            for path, mods in self._dirpath2confmods.items():\n                if path and dirpath in path.parents or path == dirpath:\n                    assert mod not in mods\n                    mods.append(mod)\n        self.trace(f\"loading conftestmodule {mod!r}\")\n        self.consider_conftest(mod)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_check_non_top_pytest_plugins().</name><path>src/_pytest/config/__init__.py</path><content>    def _check_non_top_pytest_plugins(\n        self,\n        mod: types.ModuleType,\n        conftestpath: Path,\n    ) -> None:\n        if (\n            hasattr(mod, \"pytest_plugins\")\n            and self._configured\n            and not self._using_pyargs\n        ):\n            msg = (\n                \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n                \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n                \"  {}\\n\"\n                \"Please move it to a top level conftest file at the rootdir:\\n\"\n                \"  {}\\n\"\n                \"For more information, visit:\\n\"\n                \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n            )</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#consider_preparse().</name><path>src/_pytest/config/__init__.py</path><content>    def consider_preparse(\n        self, args: Sequence[str], *, exclude_only: bool = False\n    ) -> None:\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                if exclude_only and not parg.startswith(\"no:\"):\n                    continue</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#consider_pluginarg().</name><path>src/_pytest/config/__init__.py</path><content>    def consider_pluginarg(self, arg: str) -> None:\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304: remove stepwise if cacheprovider is blocked.\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#consider_conftest().</name><path>src/_pytest/config/__init__.py</path><content>    def consider_conftest(self, conftestmodule: types.ModuleType) -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#consider_env().</name><path>src/_pytest/config/__init__.py</path><content>    def consider_env(self) -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#consider_module().</name><path>src/_pytest/config/__init__.py</path><content>    def consider_module(self, mod: types.ModuleType) -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#_import_plugin_specs().</name><path>src/_pytest/config/__init__.py</path><content>    def _import_plugin_specs(\n        self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n    ) -> None:\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>PytestPluginManager#import_plugin().</name><path>src/_pytest/config/__init__.py</path><content>    def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n        \"\"\"Import a plugin with ``modname``.\n\n        If ``consider_entry_points`` is True, entry point names are also\n        considered to find a plugin.\n        \"\"\"\n        # Most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            raise ImportError(\n                'Error importing plugin \"{}\": {}'.format(modname, str(e.args[0]))\n            ).with_traceback(e.__traceback__) from e\n\n        except Skipped as e:\n            self.skipped_plugins.append((modname, e.msg or \"\"))\n        else:\n            mod = sys.modules[importspec]</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#</name><path>src/_pytest/config/__init__.py</path><content>@final\nclass Config:\n    \"\"\"Access to configuration values, pluginmanager and plugin hooks.\n\n    :param PytestPluginManager pluginmanager:\n\n    :param InvocationParams invocation_params:\n        Object containing parameters regarding the :func:`pytest.main`\n        invocation.\n    \"\"\"\n\n    @final\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during :func:`pytest.main`.\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(type=Tuple[str, ...], converter=_args_converter)\n        \"\"\"The command-line arguments as passed to :func:`pytest.main`.\n\n        :type: Tuple[str, ...]\n        \"\"\"\n        plugins = attr.ib(type=Optional[Sequence[Union[str, _PluggyPlugin]]])\n        \"\"\"Extra plugins, might be `None`.\n\n        :type: Optional[Sequence[Union[str, plugin]]]\n        \"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"The directory from which :func:`pytest.main` was invoked.\n\n        :type: pathlib.Path\n        \"\"\"\n\n    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None,\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path.cwd()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"Access to command line option as attributes.\n\n        :type: argparse.Namespace\n        \"\"\"\n\n        self.invocation_params = invocation_params\n        \"\"\"The parameters with which pytest was invoked.\n\n        :type: InvocationParams\n        \"\"\"\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"The plugin manager handles plugin registration and hook invocation.\n\n        :type: PytestPluginManager\n        \"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache: Dict[str, Any] = {}\n        self._override_ini: Sequence[str] = ()\n        self._opt2dest: Dict[str, str] = {}\n        self._cleanup: List[Callable[[], None]] = []\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n\n            self.cache: Optional[Cache] = None\n\n    @property\n    def invocation_dir(self) -> py.path.local:\n        \"\"\"The directory from which pytest was invoked.\n\n        Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,\n        which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    @property\n    def rootpath(self) -> Path:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        :type: pathlib.Path\n\n        .. versionadded:: 6.1\n        \"\"\"\n        return self._rootpath\n\n    @property\n    def rootdir(self) -> py.path.local:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\"\n        return py.path.local(str(self.rootpath))\n\n    @property\n    def inipath(self) -> Optional[Path]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        :type: Optional[pathlib.Path]\n\n        .. versionadded:: 6.1\n        \"\"\"\n        return self._inipath\n\n    @property\n    def inifile(self) -> Optional[py.path.local]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.\n\n        :type: Optional[py.path.local]\n        \"\"\"\n        return py.path.local(str(self.inipath)) if self.inipath else None\n\n    def add_cleanup(self, func: Callable[[], None]) -> None:\n        \"\"\"Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self) -> None:\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self) -> None:\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self) -> TerminalWriter:\n        terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n            \"terminalreporter\"\n        )\n        return terminalreporter._tw\n\n    def pytest_cmdline_parse(\n        self, pluginmanager: PytestPluginManager, args: List[str]\n    ) -> \"Config\":\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n\n        return self\n\n    def notify_exception(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        option: Optional[argparse.Namespace] = None,\n    ) -> None:\n        if option and getattr(option, \"fulltrace\", False):\n            style: _TracebackStyle = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n                sys.stderr.flush()\n\n    def cwd_relative_nodeid(self, nodeid: str) -> str:\n        # nodeid's are relative to the rootpath, compute relative to cwd.\n        if self.invocation_params.dir != self.rootpath:\n            fullpath = self.rootpath / nodeid\n            nodeid = bestrelpath(self.invocation_params.dir, fullpath)\n        return nodeid\n\n    @classmethod\n    def fromdictargs(cls, option_dict, args) -> \"Config\":\n        \"\"\"Constructor usable for subprocesses.\"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)\n        return config\n\n    def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):\n                setattr(self.option, opt.dest, opt.default)\n\n    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:\n        self.pluginmanager._set_initial_conftests(early_config.known_args_namespace)\n\n    def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        rootpath, inipath, inicfg = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self._rootpath = rootpath\n        self._inipath = inipath\n        self.inicfg = inicfg\n        self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n        self._parser.extra_info[\"inifile\"] = str(self.inipath)\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._parser.addini(\n            \"required_plugins\",\n            \"plugins that must be present for pytest to run\",\n            type=\"args\",\n            default=[],\n        )\n        self._override_ini = ns.override_ini or ()\n\n    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)\n        self._warn_about_missing_assertion(mode)\n\n    def _mark_plugins_for_rewrite(self, hook) -> None:\n        \"\"\"Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):\n            hook.mark_rewrite(name)\n\n    def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n\n        return args\n\n    def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.known_args_namespace)\n        )\n\n        self._validate_plugins()\n        self._warn_about_skipped_plugins()\n\n        if self.known_args_namespace.strict:\n            self.issue_config_time_warning(\n                _pytest.deprecated.STRICT_OPTION, stacklevel=2\n            )\n\n        if self.known_args_namespace.confcutdir is None and self.inipath is not None:\n            confcutdir = str(self.inipath.parent)\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if self.known_args_namespace.help or self.known_args_namespace.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                self.issue_config_time_warning(\n                    PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n                    stacklevel=2,\n                )\n            else:\n                raise\n\n    @hookimpl(hookwrapper=True)\n    def pytest_collection(self) -> Generator[None, None, None]:\n        \"\"\"Validate invalid ini keys after collection is done so we take in account\n        options added by late-loading conftest files.\"\"\"\n        yield\n        self._validate_config_options()\n\n    def _checkversion(self) -> None:\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            # Imported lazily to improve start-up time.\n            from packaging.version import Version\n\n            if not isinstance(minver, str):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' must be a single value\" % self.inipath\n                )\n\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inipath,\n                        minver,\n                        pytest.__version__,\n                    )\n                )\n\n    def _validate_config_options(self) -> None:\n        for key in sorted(self._get_unknown_ini_keys()):\n            self._warn_or_fail_if_strict(f\"Unknown config option: {key}\\n\")\n\n    def _validate_plugins(self) -> None:\n        required_plugins = sorted(self.getini(\"required_plugins\"))\n        if not required_plugins:\n            return\n\n        # Imported lazily to improve start-up time.\n        from packaging.version import Version\n        from packaging.requirements import InvalidRequirement, Requirement\n\n        plugin_info = self.pluginmanager.list_plugin_distinfo()\n        plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n\n        missing_plugins = []\n        for required_plugin in required_plugins:\n            try:\n                spec = Requirement(required_plugin)\n            except InvalidRequirement:\n                missing_plugins.append(required_plugin)\n                continue\n\n            if spec.name not in plugin_dist_info:\n                missing_plugins.append(required_plugin)\n            elif Version(plugin_dist_info[spec.name]) not in spec.specifier:\n                missing_plugins.append(required_plugin)\n\n        if missing_plugins:\n            raise UsageError(\n                \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),\n            )\n\n    def _warn_or_fail_if_strict(self, message: str) -> None:\n        if self.known_args_namespace.strict_config:\n            raise UsageError(message)\n\n        self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)\n\n    def _get_unknown_ini_keys(self) -> List[str]:\n        parser_inicfg = self._parser._inidict\n        return [name for name in self.inicfg if name not in parser_inicfg]\n\n    def parse(self, args: List[str], addopts: bool = True) -> None:\n        # Parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_params.dir == self.rootpath:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_params.dir)]\n            self.args = args\n        except PrintHelp:\n            pass\n\n    def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n        \"\"\"Issue and handle a warning during the \"configure\" stage.\n\n        During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n        function because it is not possible to have hookwrappers around ``pytest_configure``.\n\n        This function is mainly intended for plugins that need to issue warnings during\n        ``pytest_configure`` (or similar stages).\n\n        :param warning: The warning instance.\n        :param stacklevel: stacklevel forwarded to warnings.warn.\n        \"\"\"\n        if self.pluginmanager.is_blocked(\"warnings\"):\n            return\n\n        cmdline_filters = self.known_args_namespace.pythonwarnings or []\n        config_filters = self.getini(\"filterwarnings\")\n\n        with warnings.catch_warnings(record=True) as records:\n            warnings.simplefilter(\"always\", type(warning))\n            apply_warning_filters(config_filters, cmdline_filters)\n            warnings.warn(warning, stacklevel=stacklevel)\n\n        if records:\n            frame = sys._getframe(stacklevel - 1)\n            location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n            self.hook.pytest_warning_captured.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    item=None,\n                    location=location,\n                )\n            )\n            self.hook.pytest_warning_recorded.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    nodeid=\"\",\n                    location=location,\n                )\n            )\n\n    def addinivalue_line(self, name: str, line: str) -> None:\n        \"\"\"Add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes\n        the first line in its value.\"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)\n        x.append(line)  # modifies the cached list inline\n\n    def getini(self, name: str):\n        \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n\n        If the specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised.\n        \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)\n            return val\n\n    def _getini(self, name: str):\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError as e:\n            raise ValueError(f\"unknown configuration value: {name!r}\") from e\n        override_value = self._get_override_ini_value(name)\n        if override_value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        else:\n            value = override_value\n        # Coerce the values based on types.\n        #\n        # Note: some coercions are only required if we are reading from .ini files, because\n        # the file format doesn't contain type information, but when reading from toml we will\n        # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n        # For example:\n        #\n        #   ini:\n        #     a_line_list = \"tests acceptance\"\n        #   in this case, we need to split the string to obtain a list of strings.\n        #\n        #   toml:\n        #     a_line_list = [\"tests\", \"acceptance\"]\n        #   in this case, we already have a list ready to use.\n        #\n        if type == \"pathlist\":\n            # TODO: This assert is probably not valid in all cases.\n            assert self.inipath is not None\n            dp = self.inipath.parent\n            input_values = shlex.split(value) if isinstance(value, str) else value\n            return [py.path.local(str(dp / x)) for x in input_values]\n        elif type == \"args\":\n            return shlex.split(value) if isinstance(value, str) else value\n        elif type == \"linelist\":\n            if isinstance(value, str):\n                return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n            else:\n                return value\n        elif type == \"bool\":\n            return _strtobool(str(value).strip())\n        else:\n            assert type in [None, \"string\"]\n            return value\n\n    def _getconftest_pathlist(self, name: str, path: Path) -> Optional[List[Path]]:\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(\n                name, path, self.getoption(\"importmode\")\n            )\n        except KeyError:\n            return None\n        modpath = Path(mod.__file__).parent\n        values: List[Path] = []\n        for relroot in relroots:\n            if isinstance(relroot, Path):\n                pass\n            elif isinstance(relroot, py.path.local):\n                relroot = Path(relroot)\n            else:\n                relroot = relroot.replace(\"/\", os.sep)\n                relroot = absolutepath(modpath / relroot)\n            values.append(relroot)\n        return values\n\n    def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options.\n        # Always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError as e:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                ) from e\n            else:\n                if key == name:\n                    value = user_ini_value\n        return value\n\n    def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\"Return command line option value.\n\n        :param name: Name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :param default: Default value if no option of that name exists.\n        :param skip: If True, raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError as e:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(f\"no {name!r} option found\")\n            raise ValueError(f\"no option named {name!r}\") from e\n\n    def getvalue(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption() instead.\"\"\"\n        return self.getoption(name)\n\n    def getvalueorskip(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\"\n        return self.getoption(name, skip=True)\n\n    def _warn_about_missing_assertion(self, mode: str) -> None:\n        if not _assertion_supported():\n            if mode == \"plain\":\n                warning_text = (\n                    \"ASSERTIONS ARE NOT EXECUTED\"\n                    \" and FAILING TESTS WILL PASS.  Are you\"\n                    \" using python -O?\"\n                )\n            else:\n                warning_text = (\n                    \"assertions not in test modules or\"\n                    \" plugins will be ignored\"\n                    \" because assert statements are not executed \"\n                    \"by the underlying Python interpreter \"\n                    \"(are you using python -O?)\\n\"\n                )\n            self.issue_config_time_warning(\n                PytestConfigWarning(warning_text),\n                stacklevel=3,\n            )\n\n    def _warn_about_skipped_plugins(self) -> None:\n        for module_name, msg in self.pluginmanager.skipped_plugins:\n            self.issue_config_time_warning(\n                PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n                stacklevel=2,</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#InvocationParams#</name><path>src/_pytest/config/__init__.py</path><content>    @final\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during :func:`pytest.main`.\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(type=Tuple[str, ...], converter=_args_converter)\n        \"\"\"The command-line arguments as passed to :func:`pytest.main`.\n\n        :type: Tuple[str, ...]\n        \"\"\"\n        plugins = attr.ib(type=Optional[Sequence[Union[str, _PluggyPlugin]]])\n        \"\"\"Extra plugins, might be `None`.\n\n        :type: Optional[Sequence[Union[str, plugin]]]\n        \"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"The directory from which :func:`pytest.main` was invoked.\n\n        :type: pathlib.Path</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#__init__().</name><path>src/_pytest/config/__init__.py</path><content>    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None,\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path.cwd()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"Access to command line option as attributes.\n\n        :type: argparse.Namespace\n        \"\"\"\n\n        self.invocation_params = invocation_params\n        \"\"\"The parameters with which pytest was invoked.\n\n        :type: InvocationParams\n        \"\"\"\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"The plugin manager handles plugin registration and hook invocation.\n\n        :type: PytestPluginManager\n        \"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache: Dict[str, Any] = {}\n        self._override_ini: Sequence[str] = ()\n        self._opt2dest: Dict[str, str] = {}\n        self._cleanup: List[Callable[[], None]] = []\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#invocation_dir().</name><path>src/_pytest/config/__init__.py</path><content>    @property\n    def invocation_dir(self) -> py.path.local:\n        \"\"\"The directory from which pytest was invoked.\n\n        Prefer to use :attr:`invocation_params.dir <InvocationParams.dir>`,\n        which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#rootpath().</name><path>src/_pytest/config/__init__.py</path><content>    @property\n    def rootpath(self) -> Path:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        :type: pathlib.Path\n\n        .. versionadded:: 6.1\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#rootdir().</name><path>src/_pytest/config/__init__.py</path><content>    @property\n    def rootdir(self) -> py.path.local:\n        \"\"\"The path to the :ref:`rootdir <rootdir>`.\n\n        Prefer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.\n\n        :type: py.path.local\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#inipath().</name><path>src/_pytest/config/__init__.py</path><content>    @property\n    def inipath(self) -> Optional[Path]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        :type: Optional[pathlib.Path]\n\n        .. versionadded:: 6.1\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#inifile().</name><path>src/_pytest/config/__init__.py</path><content>    @property\n    def inifile(self) -> Optional[py.path.local]:\n        \"\"\"The path to the :ref:`configfile <configfiles>`.\n\n        Prefer to use :attr:`inipath`, which is a :class:`pathlib.Path`.\n\n        :type: Optional[py.path.local]\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#add_cleanup().</name><path>src/_pytest/config/__init__.py</path><content>    def add_cleanup(self, func: Callable[[], None]) -> None:\n        \"\"\"Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_do_configure().</name><path>src/_pytest/config/__init__.py</path><content>    def _do_configure(self) -> None:\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_ensure_unconfigure().</name><path>src/_pytest/config/__init__.py</path><content>    def _ensure_unconfigure(self) -> None:\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#get_terminal_writer().</name><path>src/_pytest/config/__init__.py</path><content>    def get_terminal_writer(self) -> TerminalWriter:\n        terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n            \"terminalreporter\"\n        )</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#pytest_cmdline_parse().</name><path>src/_pytest/config/__init__.py</path><content>    def pytest_cmdline_parse(\n        self, pluginmanager: PytestPluginManager, args: List[str]\n    ) -> \"Config\":\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#notify_exception().</name><path>src/_pytest/config/__init__.py</path><content>    def notify_exception(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        option: Optional[argparse.Namespace] = None,\n    ) -> None:\n        if option and getattr(option, \"fulltrace\", False):\n            style: _TracebackStyle = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#cwd_relative_nodeid().</name><path>src/_pytest/config/__init__.py</path><content>    def cwd_relative_nodeid(self, nodeid: str) -> str:\n        # nodeid's are relative to the rootpath, compute relative to cwd.\n        if self.invocation_params.dir != self.rootpath:\n            fullpath = self.rootpath / nodeid\n            nodeid = bestrelpath(self.invocation_params.dir, fullpath)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#fromdictargs().</name><path>src/_pytest/config/__init__.py</path><content>    @classmethod\n    def fromdictargs(cls, option_dict, args) -> \"Config\":\n        \"\"\"Constructor usable for subprocesses.\"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_processopt().</name><path>src/_pytest/config/__init__.py</path><content>    def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#pytest_load_initial_conftests().</name><path>src/_pytest/config/__init__.py</path><content>    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_initini().</name><path>src/_pytest/config/__init__.py</path><content>    def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        rootpath, inipath, inicfg = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self._rootpath = rootpath\n        self._inipath = inipath\n        self.inicfg = inicfg\n        self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n        self._parser.extra_info[\"inifile\"] = str(self.inipath)\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._parser.addini(\n            \"required_plugins\",\n            \"plugins that must be present for pytest to run\",\n            type=\"args\",\n            default=[],\n        )</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_consider_importhook().</name><path>src/_pytest/config/__init__.py</path><content>    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_mark_plugins_for_rewrite().</name><path>src/_pytest/config/__init__.py</path><content>    def _mark_plugins_for_rewrite(self, hook) -> None:\n        \"\"\"Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_validate_args().</name><path>src/_pytest/config/__init__.py</path><content>    def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_preparse().</name><path>src/_pytest/config/__init__.py</path><content>    def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n\n        self.known_args_namespace = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.known_args_namespace)\n        )\n\n        self._validate_plugins()\n        self._warn_about_skipped_plugins()\n\n        if self.known_args_namespace.strict:\n            self.issue_config_time_warning(\n                _pytest.deprecated.STRICT_OPTION, stacklevel=2\n            )\n\n        if self.known_args_namespace.confcutdir is None and self.inipath is not None:\n            confcutdir = str(self.inipath.parent)\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if self.known_args_namespace.help or self.known_args_namespace.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                self.issue_config_time_warning(\n                    PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n                    stacklevel=2,\n                )\n            else:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#pytest_collection().</name><path>src/_pytest/config/__init__.py</path><content>    @hookimpl(hookwrapper=True)\n    def pytest_collection(self) -> Generator[None, None, None]:\n        \"\"\"Validate invalid ini keys after collection is done so we take in account\n        options added by late-loading conftest files.\"\"\"\n        yield</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_checkversion().</name><path>src/_pytest/config/__init__.py</path><content>    def _checkversion(self) -> None:\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            # Imported lazily to improve start-up time.\n            from packaging.version import Version\n\n            if not isinstance(minver, str):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' must be a single value\" % self.inipath\n                )\n\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inipath,\n                        minver,\n                        pytest.__version__,\n                    )</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_validate_config_options().</name><path>src/_pytest/config/__init__.py</path><content>    def _validate_config_options(self) -> None:\n        for key in sorted(self._get_unknown_ini_keys()):</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_validate_plugins().</name><path>src/_pytest/config/__init__.py</path><content>    def _validate_plugins(self) -> None:\n        required_plugins = sorted(self.getini(\"required_plugins\"))\n        if not required_plugins:\n            return\n\n        # Imported lazily to improve start-up time.\n        from packaging.version import Version\n        from packaging.requirements import InvalidRequirement, Requirement\n\n        plugin_info = self.pluginmanager.list_plugin_distinfo()\n        plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n\n        missing_plugins = []\n        for required_plugin in required_plugins:\n            try:\n                spec = Requirement(required_plugin)\n            except InvalidRequirement:\n                missing_plugins.append(required_plugin)\n                continue\n\n            if spec.name not in plugin_dist_info:\n                missing_plugins.append(required_plugin)\n            elif Version(plugin_dist_info[spec.name]) not in spec.specifier:\n                missing_plugins.append(required_plugin)\n\n        if missing_plugins:\n            raise UsageError(\n                \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_warn_or_fail_if_strict().</name><path>src/_pytest/config/__init__.py</path><content>    def _warn_or_fail_if_strict(self, message: str) -> None:\n        if self.known_args_namespace.strict_config:\n            raise UsageError(message)\n</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_get_unknown_ini_keys().</name><path>src/_pytest/config/__init__.py</path><content>    def _get_unknown_ini_keys(self) -> List[str]:\n        parser_inicfg = self._parser._inidict</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#parse().</name><path>src/_pytest/config/__init__.py</path><content>    def parse(self, args: List[str], addopts: bool = True) -> None:\n        # Parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_params.dir == self.rootpath:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_params.dir)]\n            self.args = args\n        except PrintHelp:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#issue_config_time_warning().</name><path>src/_pytest/config/__init__.py</path><content>    def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n        \"\"\"Issue and handle a warning during the \"configure\" stage.\n\n        During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n        function because it is not possible to have hookwrappers around ``pytest_configure``.\n\n        This function is mainly intended for plugins that need to issue warnings during\n        ``pytest_configure`` (or similar stages).\n\n        :param warning: The warning instance.\n        :param stacklevel: stacklevel forwarded to warnings.warn.\n        \"\"\"\n        if self.pluginmanager.is_blocked(\"warnings\"):\n            return\n\n        cmdline_filters = self.known_args_namespace.pythonwarnings or []\n        config_filters = self.getini(\"filterwarnings\")\n\n        with warnings.catch_warnings(record=True) as records:\n            warnings.simplefilter(\"always\", type(warning))\n            apply_warning_filters(config_filters, cmdline_filters)\n            warnings.warn(warning, stacklevel=stacklevel)\n\n        if records:\n            frame = sys._getframe(stacklevel - 1)\n            location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n            self.hook.pytest_warning_captured.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    item=None,\n                    location=location,\n                )\n            )\n            self.hook.pytest_warning_recorded.call_historic(\n                kwargs=dict(\n                    warning_message=records[0],\n                    when=\"config\",\n                    nodeid=\"\",\n                    location=location,\n                )</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#addinivalue_line().</name><path>src/_pytest/config/__init__.py</path><content>    def addinivalue_line(self, name: str, line: str) -> None:\n        \"\"\"Add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes\n        the first line in its value.\"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#getini().</name><path>src/_pytest/config/__init__.py</path><content>    def getini(self, name: str):\n        \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n\n        If the specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised.\n        \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_getini().</name><path>src/_pytest/config/__init__.py</path><content>    def _getini(self, name: str):\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError as e:\n            raise ValueError(f\"unknown configuration value: {name!r}\") from e\n        override_value = self._get_override_ini_value(name)\n        if override_value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        else:\n            value = override_value\n        # Coerce the values based on types.\n        #\n        # Note: some coercions are only required if we are reading from .ini files, because\n        # the file format doesn't contain type information, but when reading from toml we will\n        # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n        # For example:\n        #\n        #   ini:\n        #     a_line_list = \"tests acceptance\"\n        #   in this case, we need to split the string to obtain a list of strings.\n        #\n        #   toml:\n        #     a_line_list = [\"tests\", \"acceptance\"]\n        #   in this case, we already have a list ready to use.\n        #\n        if type == \"pathlist\":\n            # TODO: This assert is probably not valid in all cases.\n            assert self.inipath is not None\n            dp = self.inipath.parent\n            input_values = shlex.split(value) if isinstance(value, str) else value\n            return [py.path.local(str(dp / x)) for x in input_values]\n        elif type == \"args\":\n            return shlex.split(value) if isinstance(value, str) else value\n        elif type == \"linelist\":\n            if isinstance(value, str):\n                return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n            else:\n                return value\n        elif type == \"bool\":\n            return _strtobool(str(value).strip())\n        else:\n            assert type in [None, \"string\"]</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_getconftest_pathlist().</name><path>src/_pytest/config/__init__.py</path><content>    def _getconftest_pathlist(self, name: str, path: Path) -> Optional[List[Path]]:\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(\n                name, path, self.getoption(\"importmode\")\n            )\n        except KeyError:\n            return None\n        modpath = Path(mod.__file__).parent\n        values: List[Path] = []\n        for relroot in relroots:\n            if isinstance(relroot, Path):\n                pass\n            elif isinstance(relroot, py.path.local):\n                relroot = Path(relroot)\n            else:\n                relroot = relroot.replace(\"/\", os.sep)\n                relroot = absolutepath(modpath / relroot)\n            values.append(relroot)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_get_override_ini_value().</name><path>src/_pytest/config/__init__.py</path><content>    def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options.\n        # Always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError as e:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                ) from e\n            else:\n                if key == name:\n                    value = user_ini_value</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#getoption().</name><path>src/_pytest/config/__init__.py</path><content>    def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\"Return command line option value.\n\n        :param name: Name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :param default: Default value if no option of that name exists.\n        :param skip: If True, raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError as e:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(f\"no {name!r} option found\")</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#getvalue().</name><path>src/_pytest/config/__init__.py</path><content>    def getvalue(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption() instead.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#getvalueorskip().</name><path>src/_pytest/config/__init__.py</path><content>    def getvalueorskip(self, name: str, path=None):\n        \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_warn_about_missing_assertion().</name><path>src/_pytest/config/__init__.py</path><content>    def _warn_about_missing_assertion(self, mode: str) -> None:\n        if not _assertion_supported():\n            if mode == \"plain\":\n                warning_text = (\n                    \"ASSERTIONS ARE NOT EXECUTED\"\n                    \" and FAILING TESTS WILL PASS.  Are you\"\n                    \" using python -O?\"\n                )\n            else:\n                warning_text = (\n                    \"assertions not in test modules or\"\n                    \" plugins will be ignored\"\n                    \" because assert statements are not executed \"\n                    \"by the underlying Python interpreter \"\n                    \"(are you using python -O?)\\n\"\n                )\n            self.issue_config_time_warning(\n                PytestConfigWarning(warning_text),\n                stacklevel=3,</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Config#_warn_about_skipped_plugins().</name><path>src/_pytest/config/__init__.py</path><content>    def _warn_about_skipped_plugins(self) -> None:\n        for module_name, msg in self.pluginmanager.skipped_plugins:\n            self.issue_config_time_warning(\n                PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n                stacklevel=2,</content></relevant>"
    }
  ],
  "completion": {
    "id": "chatcmpl-9wgRXfD58thWu8R4zKfBgBp7HVFnq",
    "choices": [
      {
        "finish_reason": "stop",
        "index": 0,
        "logprobs": null,
        "message": {
          "content": "{\"scratch_pad\":\"1.1 The issue reported by the user relates to the visibility and handling of `setUpClass` fixtures in unittest when used with the pytest testing framework. Starting from version 6.2.0, these fixtures are no longer marked as private, which means they are visible in the list of fixtures when running pytest commands (like `pytest --fixtures`). This breaks the CI script that checks for undocumented fixtures, as it assumes that certain fixtures starting with an underscore would be hidden unless the verbose output is requested.\\n\\n1.2 This issue was caused by a change in the behavior of the pytest framework to make `setUpClass` fixtures visible by default during the collection and management of fixtures. Previously, such fixtures were treated as private by convention (starting with an underscore) and would not show up unless asked for in verbose mode.\\n\\n1.3 The expected behavior that the user desires is for `setUpClass` fixtures to still be hidden (only visible when verbose output is requested) which is in line with how it used to work before version 6.2.0. This would help maintain the integrity of the existing CI practices that rely on these conventions.\\n\\n1.4 The expectation in this case is that the `setUpClass` fixtures should not be printed in the `pytest --fixtures` output unless the verbose flag is given.\\n\\n1.5 To fix this issue, it should be ensured that any fixture names that start with an underscore (as in the `setUpClass` fixtures) are not included in the list displayed by `pytest --fixtures` unless the verbose flag is supplied. This can be achieved by adjusting how fixtures are collected and displayed, possibly by adding a conditional check based on naming or via configuration settings.\",\"patch\":\"diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\\nindex abcd123..ef01234 100644\\n--- a/src/_pytest/unittest.py\\n+++ b/src/_pytest/unittest.py\\n@@ -145,7 +145,7 @@ class UnitTestCase(Collector):\\n                     # to declare that our children do not support funcargs.\\n                     nofuncargs = True\\n \\n-    def collect(self) -> Iterable[Union[Item, Collector]]:\\n+    def collect(self) -> Iterable[Union[Item, Collector]]:\\n         if name.startswith(\\\"_\\\") and not self.session._verbosity:\\n             return # skip the collection of private fixtures unless verbose\\n \\n         # rest of the original logic\\ndiff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\\nindex 56789ab..012efab 100644\\n--- a/src/_pytest/fixtures.py\\n+++ b/src/_pytest/fixtures.py\\n@@ -20,7 +20,7 @@ def pytest_fixture_setup(\\n         # original fixture setup logic\\n         if fixturedef.name.startswith(\\\"_\\\") and not request.session._verbosity:\\n            continue # Skip private fixtures unless verbosity is high\\n \\n         # Additional setup logic for fixtures\"}",
          "refusal": null,
          "role": "assistant",
          "function_call": null,
          "tool_calls": [],
          "parsed": {
            "scratch_pad": "1.1 The issue reported by the user relates to the visibility and handling of `setUpClass` fixtures in unittest when used with the pytest testing framework. Starting from version 6.2.0, these fixtures are no longer marked as private, which means they are visible in the list of fixtures when running pytest commands (like `pytest --fixtures`). This breaks the CI script that checks for undocumented fixtures, as it assumes that certain fixtures starting with an underscore would be hidden unless the verbose output is requested.\n\n1.2 This issue was caused by a change in the behavior of the pytest framework to make `setUpClass` fixtures visible by default during the collection and management of fixtures. Previously, such fixtures were treated as private by convention (starting with an underscore) and would not show up unless asked for in verbose mode.\n\n1.3 The expected behavior that the user desires is for `setUpClass` fixtures to still be hidden (only visible when verbose output is requested) which is in line with how it used to work before version 6.2.0. This would help maintain the integrity of the existing CI practices that rely on these conventions.\n\n1.4 The expectation in this case is that the `setUpClass` fixtures should not be printed in the `pytest --fixtures` output unless the verbose flag is given.\n\n1.5 To fix this issue, it should be ensured that any fixture names that start with an underscore (as in the `setUpClass` fixtures) are not included in the list displayed by `pytest --fixtures` unless the verbose flag is supplied. This can be achieved by adjusting how fixtures are collected and displayed, possibly by adding a conditional check based on naming or via configuration settings.",
            "patch": "diff --git a/src/_pytest/unittest.py b/src/_pytest/unittest.py\nindex abcd123..ef01234 100644\n--- a/src/_pytest/unittest.py\n+++ b/src/_pytest/unittest.py\n@@ -145,7 +145,7 @@ class UnitTestCase(Collector):\n                     # to declare that our children do not support funcargs.\n                     nofuncargs = True\n \n-    def collect(self) -> Iterable[Union[Item, Collector]]:\n+    def collect(self) -> Iterable[Union[Item, Collector]]:\n         if name.startswith(\"_\") and not self.session._verbosity:\n             return # skip the collection of private fixtures unless verbose\n \n         # rest of the original logic\ndiff --git a/src/_pytest/fixtures.py b/src/_pytest/fixtures.py\nindex 56789ab..012efab 100644\n--- a/src/_pytest/fixtures.py\n+++ b/src/_pytest/fixtures.py\n@@ -20,7 +20,7 @@ def pytest_fixture_setup(\n         # original fixture setup logic\n         if fixturedef.name.startswith(\"_\") and not request.session._verbosity:\n            continue # Skip private fixtures unless verbosity is high\n \n         # Additional setup logic for fixtures"
          }
        }
      }
    ],
    "created": 1723773203,
    "model": "gpt-4o-mini-2024-07-18",
    "object": "chat.completion",
    "service_tier": null,
    "system_fingerprint": "fp_48196bc67a",
    "usage": {
      "completion_tokens": 635,
      "prompt_tokens": 39080,
      "total_tokens": 39715
    }
  }
}