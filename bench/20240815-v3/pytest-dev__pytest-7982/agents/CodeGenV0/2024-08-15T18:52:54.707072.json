{
  "name": "CodeGenV0",
  "model": "gpt-4o-mini",
  "metadata": {
    "token_count": 0,
    "cost": 0
  },
  "issue": "<description>:Symlinked directories not collected since pytest 6.1.0\nWhen there is a symlink to a directory in a test directory, is is just skipped over, but it should be followed and collected as usual.\r\n\r\nThis regressed in b473e515bc57ff1133fe650f1e7e6d7e22e5d841 (included in 6.1.0). For some reason I added a `follow_symlinks=False` in there, I don't remember why, but it does not match the previous behavior and should be removed.\r\n\r\nPR for this is coming up.\n</description>",
  "request": {
    "related_symbols": [
      {
        "name": "Node#",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "class Node(metaclass=NodeMeta):\n    \"\"\"Base class for Collector and Item, the components of the test\n    collection tree.\n\n    Collector subclasses have children; Items are leaf nodes.\n    \"\"\"\n\n    # Use __slots__ to make attribute access faster.\n    # Note that __dict__ is still available.\n    __slots__ = (\n        \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n        \"__dict__\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: A unique name within the scope of the parent node.\n        self.name = name\n\n        #: The parent collector node.\n        self.parent = parent\n\n        #: The pytest config object.\n        if config:\n            self.config: Config = config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: The pytest session this node is part of.\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: Filesystem path where this node was collected from (can be None).\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: Keywords/markers collected from all scopes.\n        self.keywords = NodeKeywords(self)\n\n        #: The marker objects belonging to this node.\n        self.own_markers: List[Mark] = []\n\n        #: Allow adding of extra keywords to use for matching.\n        self.extra_keyword_matches: Set[str] = set()\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n\n    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"Public constructor for Nodes.\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the\n        construction.\n\n        :param parent: The parent node of this Node.\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)\n\n    @property\n    def ihook(self):\n        \"\"\"fspath-sensitive hook proxy used to call pytest hooks.\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self) -> str:\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this Node.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed.\n\n        :param Warning warning:\n            The warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raises ValueError: If ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # Methods for ordering nodes.\n\n    @property\n    def nodeid(self) -> str:\n        \"\"\"A ::-separated string denoting its collection tree address.\"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        \"\"\"Return list of all parent collectors up to self, starting from\n        the root of collection tree.\"\"\"\n        chain = []\n        item: Optional[Node] = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        ...\n\n    @overload\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:\n        ...\n\n    def get_closest_marker(\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self) -> Set[str]:\n        \"\"\"Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords: Set[str] = set()\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self) -> List[str]:\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\"Register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls: Type[_NodeType]) -> Optional[_NodeType]:\n        \"\"\"Get the next parent node (including self) which is an instance of\n        the given class.\"\"\"\n        current: Optional[Node] = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)\n        return current\n\n    def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:\n        pass\n\n    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        from _pytest.fixtures import FixtureLookupError\n\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.\n        # It is possible for a fixture/test to change the CWD while this code runs, which\n        # would then result in the user seeing confusing paths in the failure message.\n        # To fix this, if the CWD changed, always display the full absolute path.\n        # It will be better to just always display paths relative to invocation_dir, but\n        # this requires a lot of plumbing (#6428).\n        try:\n            abspath = Path(os.getcwd()) != self.config.invocation_params.dir\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> Union[str, TerminalRepr]:\n        \"\"\"Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\""
      },
      {
        "name": "Node#__init__().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: A unique name within the scope of the parent node.\n        self.name = name\n\n        #: The parent collector node.\n        self.parent = parent\n\n        #: The pytest config object.\n        if config:\n            self.config: Config = config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: The pytest session this node is part of.\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: Filesystem path where this node was collected from (can be None).\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: Keywords/markers collected from all scopes.\n        self.keywords = NodeKeywords(self)\n\n        #: The marker objects belonging to this node.\n        self.own_markers: List[Mark] = []\n\n        #: Allow adding of extra keywords to use for matching.\n        self.extra_keyword_matches: Set[str] = set()\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins."
      },
      {
        "name": "Node#from_parent().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"Public constructor for Nodes.\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the\n        construction.\n\n        :param parent: The parent node of this Node.\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")"
      },
      {
        "name": "Node#ihook().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    @property\n    def ihook(self):\n        \"\"\"fspath-sensitive hook proxy used to call pytest hooks.\"\"\""
      },
      {
        "name": "Node#__repr__().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def __repr__(self) -> str:"
      },
      {
        "name": "Node#warn().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this Node.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed.\n\n        :param Warning warning:\n            The warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raises ValueError: If ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,"
      },
      {
        "name": "Node#nodeid().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    @property\n    def nodeid(self) -> str:\n        \"\"\"A ::-separated string denoting its collection tree address.\"\"\""
      },
      {
        "name": "Node#__hash__().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def __hash__(self) -> int:"
      },
      {
        "name": "Node#setup().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def setup(self) -> None:"
      },
      {
        "name": "Node#teardown().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def teardown(self) -> None:"
      },
      {
        "name": "Node#listchain().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def listchain(self) -> List[\"Node\"]:\n        \"\"\"Return list of all parent collectors up to self, starting from\n        the root of collection tree.\"\"\"\n        chain = []\n        item: Optional[Node] = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()"
      },
      {
        "name": "Node#add_marker().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:"
      },
      {
        "name": "Node#iter_markers().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        \"\"\""
      },
      {
        "name": "Node#iter_markers_with_node().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:"
      },
      {
        "name": "Node#get_closest_marker().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:"
      },
      {
        "name": "Node#listextrakeywords().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def listextrakeywords(self) -> Set[str]:\n        \"\"\"Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords: Set[str] = set()\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)"
      },
      {
        "name": "Node#listnames().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def listnames(self) -> List[str]:"
      },
      {
        "name": "Node#addfinalizer().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\"Register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\""
      },
      {
        "name": "Node#getparent().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def getparent(self, cls: Type[_NodeType]) -> Optional[_NodeType]:\n        \"\"\"Get the next parent node (including self) which is an instance of\n        the given class.\"\"\"\n        current: Optional[Node] = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)"
      },
      {
        "name": "Node#_prunetraceback().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:"
      },
      {
        "name": "Node#_repr_failure_py().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        from _pytest.fixtures import FixtureLookupError\n\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.\n        # It is possible for a fixture/test to change the CWD while this code runs, which\n        # would then result in the user seeing confusing paths in the failure message.\n        # To fix this, if the CWD changed, always display the full absolute path.\n        # It will be better to just always display paths relative to invocation_dir, but\n        # this requires a lot of plumbing (#6428).\n        try:\n            abspath = Path(os.getcwd()) != self.config.invocation_params.dir\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,"
      },
      {
        "name": "Node#repr_failure().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def repr_failure(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> Union[str, TerminalRepr]:\n        \"\"\"Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\""
      },
      {
        "name": "Collector#collect().",
        "file_path": "src/_pytest/nodes.py",
        "file_content": "    def collect(self) -> Iterable[Union[\"Item\", \"Collector\"]]:\n        \"\"\"Return a list of children (items and collectors) for this\n        collection node.\"\"\""
      },
      {
        "name": "pytest_collect_file().",
        "file_path": "src/_pytest/python.py",
        "file_content": "def pytest_collect_file(\n    path: py.path.local, parent: nodes.Collector\n) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n        return module"
      },
      {
        "name": "path_matches_patterns().",
        "file_path": "src/_pytest/python.py",
        "file_content": "def path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Return whether path matches any of the patterns in the list of globs given.\"\"\""
      },
      {
        "name": "Package#gethookproxy().",
        "file_path": "src/_pytest/python.py",
        "file_content": "    def gethookproxy(self, fspath: py.path.local):\n        warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)"
      },
      {
        "name": "Package#isinitpath().",
        "file_path": "src/_pytest/python.py",
        "file_content": "    def isinitpath(self, path: py.path.local) -> bool:\n        warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)"
      },
      {
        "name": "symlink_or_skip().",
        "file_path": "src/_pytest/pathlib.py",
        "file_content": "def symlink_or_skip(src, dst, **kwargs):\n    \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n    try:\n        os.symlink(str(src), str(dst), **kwargs)\n    except OSError as e:"
      },
      {
        "name": "visit().",
        "file_path": "src/_pytest/pathlib.py",
        "file_content": "def visit(\n    path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n\n    Entries at each directory level are sorted.\n    \"\"\"\n    entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n    yield from entries\n    for entry in entries:\n        if entry.is_dir(follow_symlinks=False) and recurse(entry):"
      }
    ],
    "root_caused_symbols": []
  },
  "response": {
    "scratch_pad": "1. The user has reported an issue with symlinked directories not being collected since pytest v6.1.0. This is due to a change in behavior where the code added 'follow_symlinks=False'. \n\n2. This issue arises because the original behavior allowed pytest to collect tests from directories even if they were symlinked. By setting 'follow_symlinks' to False, those directories are now skipped altogether, which is not the desired behavior.\n\n3. The expected behavior is that symlinked directories should be included and collected as usual.\n\n4. To resolve this issue, I need to modify the relevant section of code where 'follow_symlinks' is set to ensure that it is either defaulted to True or configurable so that it can follow symlinks as intended.\n\n5. Looking through the provided relevant symbols, I will primarily focus on nodes where file collection happens, specifically within the `pytest_collect_file()` function as it seems to handle directory collection logic that can include symlinked directories. \n\n6. I also need to peruse through the `symlink_or_skip()` function to check if symlink handling logic there also needs adjustment. \n\n7. I will not change everything unless necessary, as we want to keep code changes to a minimum. \n\nIn summary, I am looking at potentially changing how 'follow_symlinks' is handled in the context of directory collection to allow pytest to traverse symlinked directories as intended in versions prior to 6.1.0.",
    "patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex abcdef1..1234567 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -1,5 +1,5 @@\n def pytest_collect_file(\n     path: py.path.local, parent: nodes.Collector\n ) -> Optional[\"Module\"]:\n     ext = path.ext\n     if ext == \".py\":\n-        if not parent.session.isinitpath(path):\n+        if not parent.session.isinitpath(path) and not path.is symlink():\n             if not path_matches_patterns(\n                 path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n             ):\n                 return None\n         ihook = parent.session.gethookproxy(path)\n         module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n         return module"
  },
  "messages": [
    {
      "role": "system",
      "content": "You are an autonomous AI assistant tasked with finding relevant code in an existing \ncodebase based on a reported issue. \nYour task is base on the symbol code to identify how many symbols need to be change to resolve the issue. \n#Input Structure:\n\n* <issue>: Contains the reported issue.\n* <high_relevant_symbol>: the code more likely to be the root cause of the issue. \n* <relevant_symbol>: the code might to be relevant to the issue.\n\n# Your Task:\n\n1. Analyze User Instructions:\nCarefully read the reported issue within the <issue> tag.\nthink step by step and write out your thoughts in the scratch_pad field.\n1.1 What issue is the user describing?\n1.2 How was this issue caused?\n1.3 If the user described the expected result, what should it be fixed to?\n1.4 If the user did not provide an expected result, what should the expectation be?\n1.5 How should the issue be fixed to meet the expectation?\n1.6 Remember, you should think from the perspective of a core library developer. This means you need to consider how to make the solution simple, safe, and minimize code changes.\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each lines in the <root_cause_symbol> and <relevant_symbol> tags.\n2.2. Match the symbol/code/pattern with the key elements, functions, variables, or patterns identified in the reported issue.\n2.3. Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n2.4. make the decision how many symbols need to be change to resolve the issue.\n2.5. change the symbols in the code to resolve the issue.\n\nThink step by step and write out your thoughts in the scratch_pad field.  \n\n"
    },
    {
      "role": "user",
      "content": "<issue><description>:Symlinked directories not collected since pytest 6.1.0\nWhen there is a symlink to a directory in a test directory, is is just skipped over, but it should be followed and collected as usual.\r\n\r\nThis regressed in b473e515bc57ff1133fe650f1e7e6d7e22e5d841 (included in 6.1.0). For some reason I added a `follow_symlinks=False` in there, I don't remember why, but it does not match the previous behavior and should be removed.\r\n\r\nPR for this is coming up.\n</description></issue>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#</name><path>src/_pytest/nodes.py</path><content>class Node(metaclass=NodeMeta):\n    \"\"\"Base class for Collector and Item, the components of the test\n    collection tree.\n\n    Collector subclasses have children; Items are leaf nodes.\n    \"\"\"\n\n    # Use __slots__ to make attribute access faster.\n    # Note that __dict__ is still available.\n    __slots__ = (\n        \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n        \"__dict__\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: A unique name within the scope of the parent node.\n        self.name = name\n\n        #: The parent collector node.\n        self.parent = parent\n\n        #: The pytest config object.\n        if config:\n            self.config: Config = config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: The pytest session this node is part of.\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: Filesystem path where this node was collected from (can be None).\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: Keywords/markers collected from all scopes.\n        self.keywords = NodeKeywords(self)\n\n        #: The marker objects belonging to this node.\n        self.own_markers: List[Mark] = []\n\n        #: Allow adding of extra keywords to use for matching.\n        self.extra_keyword_matches: Set[str] = set()\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n\n    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"Public constructor for Nodes.\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the\n        construction.\n\n        :param parent: The parent node of this Node.\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)\n\n    @property\n    def ihook(self):\n        \"\"\"fspath-sensitive hook proxy used to call pytest hooks.\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self) -> str:\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this Node.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed.\n\n        :param Warning warning:\n            The warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raises ValueError: If ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # Methods for ordering nodes.\n\n    @property\n    def nodeid(self) -> str:\n        \"\"\"A ::-separated string denoting its collection tree address.\"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        \"\"\"Return list of all parent collectors up to self, starting from\n        the root of collection tree.\"\"\"\n        chain = []\n        item: Optional[Node] = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        ...\n\n    @overload\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:\n        ...\n\n    def get_closest_marker(\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self) -> Set[str]:\n        \"\"\"Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords: Set[str] = set()\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self) -> List[str]:\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\"Register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls: Type[_NodeType]) -> Optional[_NodeType]:\n        \"\"\"Get the next parent node (including self) which is an instance of\n        the given class.\"\"\"\n        current: Optional[Node] = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)\n        return current\n\n    def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:\n        pass\n\n    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        from _pytest.fixtures import FixtureLookupError\n\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.\n        # It is possible for a fixture/test to change the CWD while this code runs, which\n        # would then result in the user seeing confusing paths in the failure message.\n        # To fix this, if the CWD changed, always display the full absolute path.\n        # It will be better to just always display paths relative to invocation_dir, but\n        # this requires a lot of plumbing (#6428).\n        try:\n            abspath = Path(os.getcwd()) != self.config.invocation_params.dir\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> Union[str, TerminalRepr]:\n        \"\"\"Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#__init__().</name><path>src/_pytest/nodes.py</path><content>    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: A unique name within the scope of the parent node.\n        self.name = name\n\n        #: The parent collector node.\n        self.parent = parent\n\n        #: The pytest config object.\n        if config:\n            self.config: Config = config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: The pytest session this node is part of.\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: Filesystem path where this node was collected from (can be None).\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: Keywords/markers collected from all scopes.\n        self.keywords = NodeKeywords(self)\n\n        #: The marker objects belonging to this node.\n        self.own_markers: List[Mark] = []\n\n        #: Allow adding of extra keywords to use for matching.\n        self.extra_keyword_matches: Set[str] = set()\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#from_parent().</name><path>src/_pytest/nodes.py</path><content>    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"Public constructor for Nodes.\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the\n        construction.\n\n        :param parent: The parent node of this Node.\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#ihook().</name><path>src/_pytest/nodes.py</path><content>    @property\n    def ihook(self):\n        \"\"\"fspath-sensitive hook proxy used to call pytest hooks.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#__repr__().</name><path>src/_pytest/nodes.py</path><content>    def __repr__(self) -> str:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#warn().</name><path>src/_pytest/nodes.py</path><content>    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this Node.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed.\n\n        :param Warning warning:\n            The warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raises ValueError: If ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#nodeid().</name><path>src/_pytest/nodes.py</path><content>    @property\n    def nodeid(self) -> str:\n        \"\"\"A ::-separated string denoting its collection tree address.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#__hash__().</name><path>src/_pytest/nodes.py</path><content>    def __hash__(self) -> int:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#setup().</name><path>src/_pytest/nodes.py</path><content>    def setup(self) -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#teardown().</name><path>src/_pytest/nodes.py</path><content>    def teardown(self) -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#listchain().</name><path>src/_pytest/nodes.py</path><content>    def listchain(self) -> List[\"Node\"]:\n        \"\"\"Return list of all parent collectors up to self, starting from\n        the root of collection tree.\"\"\"\n        chain = []\n        item: Optional[Node] = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#add_marker().</name><path>src/_pytest/nodes.py</path><content>    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#iter_markers().</name><path>src/_pytest/nodes.py</path><content>    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#iter_markers_with_node().</name><path>src/_pytest/nodes.py</path><content>    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#get_closest_marker().</name><path>src/_pytest/nodes.py</path><content>    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#listextrakeywords().</name><path>src/_pytest/nodes.py</path><content>    def listextrakeywords(self) -> Set[str]:\n        \"\"\"Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords: Set[str] = set()\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#listnames().</name><path>src/_pytest/nodes.py</path><content>    def listnames(self) -> List[str]:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#addfinalizer().</name><path>src/_pytest/nodes.py</path><content>    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\"Register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#getparent().</name><path>src/_pytest/nodes.py</path><content>    def getparent(self, cls: Type[_NodeType]) -> Optional[_NodeType]:\n        \"\"\"Get the next parent node (including self) which is an instance of\n        the given class.\"\"\"\n        current: Optional[Node] = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#_prunetraceback().</name><path>src/_pytest/nodes.py</path><content>    def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#_repr_failure_py().</name><path>src/_pytest/nodes.py</path><content>    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        from _pytest.fixtures import FixtureLookupError\n\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.\n        # It is possible for a fixture/test to change the CWD while this code runs, which\n        # would then result in the user seeing confusing paths in the failure message.\n        # To fix this, if the CWD changed, always display the full absolute path.\n        # It will be better to just always display paths relative to invocation_dir, but\n        # this requires a lot of plumbing (#6428).\n        try:\n            abspath = Path(os.getcwd()) != self.config.invocation_params.dir\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Node#repr_failure().</name><path>src/_pytest/nodes.py</path><content>    def repr_failure(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> Union[str, TerminalRepr]:\n        \"\"\"Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Collector#collect().</name><path>src/_pytest/nodes.py</path><content>    def collect(self) -> Iterable[Union[\"Item\", \"Collector\"]]:\n        \"\"\"Return a list of children (items and collectors) for this\n        collection node.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>pytest_collect_file().</name><path>src/_pytest/python.py</path><content>def pytest_collect_file(\n    path: py.path.local, parent: nodes.Collector\n) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n        return module</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>path_matches_patterns().</name><path>src/_pytest/python.py</path><content>def path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Return whether path matches any of the patterns in the list of globs given.\"\"\"</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Package#gethookproxy().</name><path>src/_pytest/python.py</path><content>    def gethookproxy(self, fspath: py.path.local):\n        warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>Package#isinitpath().</name><path>src/_pytest/python.py</path><content>    def isinitpath(self, path: py.path.local) -> bool:\n        warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>symlink_or_skip().</name><path>src/_pytest/pathlib.py</path><content>def symlink_or_skip(src, dst, **kwargs):\n    \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n    try:\n        os.symlink(str(src), str(dst), **kwargs)\n    except OSError as e:</content></relevant>"
    },
    {
      "role": "user",
      "content": "<relevant_symbol><name>visit().</name><path>src/_pytest/pathlib.py</path><content>def visit(\n    path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n\n    Entries at each directory level are sorted.\n    \"\"\"\n    entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n    yield from entries\n    for entry in entries:\n        if entry.is_dir(follow_symlinks=False) and recurse(entry):</content></relevant>"
    }
  ],
  "completion": {
    "id": "chatcmpl-9wgQyKPZvqFRH3Q15U78RkoZiLKvL",
    "choices": [
      {
        "finish_reason": "stop",
        "index": 0,
        "logprobs": null,
        "message": {
          "content": "{\"scratch_pad\":\"1. The user has reported an issue with symlinked directories not being collected since pytest v6.1.0. This is due to a change in behavior where the code added 'follow_symlinks=False'. \\n\\n2. This issue arises because the original behavior allowed pytest to collect tests from directories even if they were symlinked. By setting 'follow_symlinks' to False, those directories are now skipped altogether, which is not the desired behavior.\\n\\n3. The expected behavior is that symlinked directories should be included and collected as usual.\\n\\n4. To resolve this issue, I need to modify the relevant section of code where 'follow_symlinks' is set to ensure that it is either defaulted to True or configurable so that it can follow symlinks as intended.\\n\\n5. Looking through the provided relevant symbols, I will primarily focus on nodes where file collection happens, specifically within the `pytest_collect_file()` function as it seems to handle directory collection logic that can include symlinked directories. \\n\\n6. I also need to peruse through the `symlink_or_skip()` function to check if symlink handling logic there also needs adjustment. \\n\\n7. I will not change everything unless necessary, as we want to keep code changes to a minimum. \\n\\nIn summary, I am looking at potentially changing how 'follow_symlinks' is handled in the context of directory collection to allow pytest to traverse symlinked directories as intended in versions prior to 6.1.0.\",\"patch\":\"diff --git a/src/_pytest/python.py b/src/_pytest/python.py\\nindex abcdef1..1234567 100644\\n--- a/src/_pytest/python.py\\n+++ b/src/_pytest/python.py\\n@@ -1,5 +1,5 @@\\n def pytest_collect_file(\\n     path: py.path.local, parent: nodes.Collector\\n ) -> Optional[\\\"Module\\\"]:\\n     ext = path.ext\\n     if ext == \\\".py\\\":\\n-        if not parent.session.isinitpath(path):\\n+        if not parent.session.isinitpath(path) and not path.is symlink():\\n             if not path_matches_patterns(\\n                 path, parent.config.getini(\\\"python_files\\\") + [\\\"__init__.py\\\"]\\n             ):\\n                 return None\\n         ihook = parent.session.gethookproxy(path)\\n         module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\\n         return module\"}",
          "refusal": null,
          "role": "assistant",
          "function_call": null,
          "tool_calls": [],
          "parsed": {
            "scratch_pad": "1. The user has reported an issue with symlinked directories not being collected since pytest v6.1.0. This is due to a change in behavior where the code added 'follow_symlinks=False'. \n\n2. This issue arises because the original behavior allowed pytest to collect tests from directories even if they were symlinked. By setting 'follow_symlinks' to False, those directories are now skipped altogether, which is not the desired behavior.\n\n3. The expected behavior is that symlinked directories should be included and collected as usual.\n\n4. To resolve this issue, I need to modify the relevant section of code where 'follow_symlinks' is set to ensure that it is either defaulted to True or configurable so that it can follow symlinks as intended.\n\n5. Looking through the provided relevant symbols, I will primarily focus on nodes where file collection happens, specifically within the `pytest_collect_file()` function as it seems to handle directory collection logic that can include symlinked directories. \n\n6. I also need to peruse through the `symlink_or_skip()` function to check if symlink handling logic there also needs adjustment. \n\n7. I will not change everything unless necessary, as we want to keep code changes to a minimum. \n\nIn summary, I am looking at potentially changing how 'follow_symlinks' is handled in the context of directory collection to allow pytest to traverse symlinked directories as intended in versions prior to 6.1.0.",
            "patch": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex abcdef1..1234567 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -1,5 +1,5 @@\n def pytest_collect_file(\n     path: py.path.local, parent: nodes.Collector\n ) -> Optional[\"Module\"]:\n     ext = path.ext\n     if ext == \".py\":\n-        if not parent.session.isinitpath(path):\n+        if not parent.session.isinitpath(path) and not path.is symlink():\n             if not path_matches_patterns(\n                 path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n             ):\n                 return None\n         ihook = parent.session.gethookproxy(path)\n         module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n         return module"
          }
        }
      }
    ],
    "created": 1723773168,
    "model": "gpt-4o-mini-2024-07-18",
    "object": "chat.completion",
    "service_tier": null,
    "system_fingerprint": "fp_48196bc67a",
    "usage": {
      "completion_tokens": 535,
      "prompt_tokens": 6419,
      "total_tokens": 6954
    }
  }
}