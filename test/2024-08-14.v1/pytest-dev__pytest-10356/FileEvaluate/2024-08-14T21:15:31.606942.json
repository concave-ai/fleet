{
  "name": "FileEvaluate",
  "model": "gpt-4o-2024-08-06",
  "issue": "<description>:Consider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nConsider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nFix missing marks when inheritance from multiple classes\n\r\n<!--\r\nThanks for submitting a PR, your contribution is really appreciated!\r\n\r\nHere is a quick checklist that should be present in PRs.\r\n\r\n- [] Include documentation when adding new features.\r\n- [ ] Include new tests or update existing tests when applicable.\r\n- [X] Allow maintainers to push and squash when merging my commits. Please uncheck this if you prefer to squash the commits yourself.\r\n\r\nIf this change fixes an issue, please:\r\n\r\n- [x] Add text like ``closes #XYZW`` to the PR description and/or commits (where ``XYZW`` is the issue number). See the [github docs](https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) for more information.\r\n\r\nUnless your change is trivial or a small documentation fix (e.g., a typo or reword of a small section) please:\r\n\r\n- [x] Create a new changelog file in the `changelog` folder, with a name like `<ISSUE NUMBER>.<TYPE>.rst`. See [changelog/README.rst](https://github.com/pytest-dev/pytest/blob/main/changelog/README.rst) for details.\r\n\r\n  Write sentences in the **past or present tense**, examples:\r\n\r\n  * *Improved verbose diff output with sequences.*\r\n  * *Terminal summary statistics now use multiple colors.*\r\n\r\n  Also make sure to end the sentence with a `.`.\r\n\r\n- [x] Add yourself to `AUTHORS` in alphabetical order.\r\n-->\r\n\n\n<hints>:ronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \nronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \n@bluetech \r\n\r\nit deals with\r\n```text\r\nIn [1]: import pytest\r\n\r\nIn [2]: @pytest.mark.a\r\n   ...: class A:\r\n   ...:     pass\r\n   ...: \r\n\r\nIn [3]: @pytest.mark.b\r\n   ...: class B: pass\r\n\r\nIn [6]: @pytest.mark.c\r\n   ...: class C(A,B): pass\r\n\r\nIn [7]: C.pytestmark\r\nOut[7]: [Mark(name='a', args=(), kwargs={}), Mark(name='c', args=(), kwargs={})]\r\n\r\n```\r\n(b is missing)\nRight, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\n> Right, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\r\n\r\n@bluetech \r\nThe solution I want to implement is: \r\n* Go through the items list. \r\n* For each item, I go through the list of classes from which he inherits. The same logic I do for each class until I found the object class.\r\n* I am updating the list of marks only if the mark does not exist in the current list.\r\n \r\nThe existing code is incorrect, and I will now update it to work according to the logic I wrote here\n@RonnyPfannschmidt \r\nThe PR is not ready for review.\r\nI trying to fix all the tests and after that, I'll improve the logic.\n@RonnyPfannschmidt \r\nOnce the PR is approved I'll create one commit with description \n@RonnyPfannschmidt \r\nYou can review the PR.</hints></description>",
  "request": {
    "file_path": "src/_pytest/mark/__init__.py"
  },
  "response": {
    "scratch_pad": "In the given issue, the problem is related to how pytest handles markers in a multiple inheritance scenario, specifically how markers might be lost when multiple classes are involved due to the Method Resolution Order (MRO). The goal is to ensure that markers are correctly inherited according to MRO and not overridden. The issue proposes using metaclasses to handle this more intuitively.\n\nAnalyzing the `src/_pytest/mark/__init__.py` file content, we see functions and classes related to handling pytest markers. \n\n- The `param()` function allows specification of parameters and their markers, which could relate to how markers are attributed and interact with tests.\n- The `KeywordMatcher` and `MarkMatcher` classes both seem to concern themselves with finding the matching tests or markers respectively based on properties or conditions.\n\nHowever, the key portions pertaining to the issue specifically must involve the interaction with class inheritance and the MRO, which do not appear to be directly handled in this file. The content is more about processing and filtering tests based on markers rather than setting or inheriting them in class definitions.\n\nGiven that this file mainly handles options related to markers or keywords and how to filter tests in pytest according to them, it is not directly related to altering marker inheritance across MRO or dealing with multiple inheritance scenarios. The solution proposed by the issue involves amending how markers are merged or aggregated across class hierarchies, potentially involving changes in marker storage or retrieval logic during test discovery or collection phases which aren't dealt here.\n\nThus, this file is likely relevant in understanding how markers are passed to tests but it isn't the root cause where markers inheritance via MRO is handled.",
    "relevant": false,
    "root_cause": false,
    "relevant_files": [
      "src/_pytest/nodes.py",
      "src/_pytest/mark/structures.py"
    ],
    "relevant_symbols": [],
    "root_cause_symbol": []
  },
  "messages": [
    {
      "role": "system",
      "content": "You are an autonomous AI assistant tasked with finding relevant code in an existing \ncodebase based on a reported issue. Your task is to identify the relevant symbols in the provided source code\nand decide whether this code relates to the reported issue. \nsymbols: functions, classes, variables that are relevant to the issue.\n \n# Input Structure:\n\n* <issue>: Contains the reported issue.\n* <file_path>: Contains the path of the file to evaluate.\n* <file_content>: Contains the content of the file to evaluate.\n\n# Your Task:\n\n1. Analyze User Instructions:\nCarefully read the reported issue within the <issue> tag.\n\n\n2. Make file evaluation:\n2.1. Thoroughly analyze each lines in the <file_content> tag.\n2.2. Match the symbol with the key elements, functions, variables, or patterns identified in the reported issue.\n2.3. Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n2.4. Review entire sections of code, not just isolated symbol, to ensure you have a complete understanding before making a decision. It's crucial to see all code in a section to accurately determine relevance and completeness.\n2.5. Verify if there are references to other parts of the codebase that might be relevant but not found in the search results. \n2.6. Determine if the file is the root cause of the issue or if it's related to the root cause.\n\nThink step by step and write out your thoughts in the scratch_pad field. \n"
    },
    {
      "role": "user",
      "content": "<issue><description>:Consider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nConsider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nFix missing marks when inheritance from multiple classes\n\r\n<!--\r\nThanks for submitting a PR, your contribution is really appreciated!\r\n\r\nHere is a quick checklist that should be present in PRs.\r\n\r\n- [] Include documentation when adding new features.\r\n- [ ] Include new tests or update existing tests when applicable.\r\n- [X] Allow maintainers to push and squash when merging my commits. Please uncheck this if you prefer to squash the commits yourself.\r\n\r\nIf this change fixes an issue, please:\r\n\r\n- [x] Add text like ``closes #XYZW`` to the PR description and/or commits (where ``XYZW`` is the issue number). See the [github docs](https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) for more information.\r\n\r\nUnless your change is trivial or a small documentation fix (e.g., a typo or reword of a small section) please:\r\n\r\n- [x] Create a new changelog file in the `changelog` folder, with a name like `<ISSUE NUMBER>.<TYPE>.rst`. See [changelog/README.rst](https://github.com/pytest-dev/pytest/blob/main/changelog/README.rst) for details.\r\n\r\n  Write sentences in the **past or present tense**, examples:\r\n\r\n  * *Improved verbose diff output with sequences.*\r\n  * *Terminal summary statistics now use multiple colors.*\r\n\r\n  Also make sure to end the sentence with a `.`.\r\n\r\n- [x] Add yourself to `AUTHORS` in alphabetical order.\r\n-->\r\n\n\n<hints>:ronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \nronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \n@bluetech \r\n\r\nit deals with\r\n```text\r\nIn [1]: import pytest\r\n\r\nIn [2]: @pytest.mark.a\r\n   ...: class A:\r\n   ...:     pass\r\n   ...: \r\n\r\nIn [3]: @pytest.mark.b\r\n   ...: class B: pass\r\n\r\nIn [6]: @pytest.mark.c\r\n   ...: class C(A,B): pass\r\n\r\nIn [7]: C.pytestmark\r\nOut[7]: [Mark(name='a', args=(), kwargs={}), Mark(name='c', args=(), kwargs={})]\r\n\r\n```\r\n(b is missing)\nRight, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\n> Right, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\r\n\r\n@bluetech \r\nThe solution I want to implement is: \r\n* Go through the items list. \r\n* For each item, I go through the list of classes from which he inherits. The same logic I do for each class until I found the object class.\r\n* I am updating the list of marks only if the mark does not exist in the current list.\r\n \r\nThe existing code is incorrect, and I will now update it to work according to the logic I wrote here\n@RonnyPfannschmidt \r\nThe PR is not ready for review.\r\nI trying to fix all the tests and after that, I'll improve the logic.\n@RonnyPfannschmidt \r\nOnce the PR is approved I'll create one commit with description \n@RonnyPfannschmidt \r\nYou can review the PR.</hints></description></issue>\n<file_path>src/_pytest/mark/__init__.py</file_path>\n<file_content>\"\"\"Generic mechanism for marking and selecting python functions.\"\"\"\nfrom typing import AbstractSet\nfrom typing import Collection\nfrom typing import List\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom typing import Union\n\nimport attr\n\nfrom .expression import Expression\nfrom .expression import ParseError\nfrom .structures import EMPTY_PARAMETERSET_OPTION\nfrom .structures import get_empty_parameterset_mark\nfrom .structures import Mark\nfrom .structures import MARK_GEN\nfrom .structures import MarkDecorator\nfrom .structures import MarkGenerator\nfrom .structures import ParameterSet\nfrom _pytest.config import Config\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.stash import StashKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\n    \"MARK_GEN\",\n    \"Mark\",\n    \"MarkDecorator\",\n    \"MarkGenerator\",\n    \"ParameterSet\",\n    \"get_empty_parameterset_mark\",\n]\n\n\nold_mark_config_key = StashKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: Union[MarkDecorator, Collection[Union[MarkDecorator, Mark]]] = (),\n    id: Optional[str] = None,\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [\n                (\"3+5\", 8),\n                pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),\n            ],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: Variable args of the values of the parameter set, in order.\n    :param marks: A single mark or a list of marks to be applied to this parameter set.\n    :param id: The id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"Only run tests which match the given substring expression. \"\n        \"An expression is a Python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywords are matched to classes and functions \"\n        \"containing extra names in their 'extra_keyword_matches' set, \"\n        \"as well as functions which have names assigned directly to them. \"\n        \"The matching is case-insensitive.\",\n    )\n\n    group._addoption(\n        \"-m\",\n        action=\"store\",\n        dest=\"markexpr\",\n        default=\"\",\n        metavar=\"MARKEXPR\",\n        help=\"Only run tests matching given mark expression. \"\n        \"For example: -m 'mark1 and not mark2'.\",\n    )\n\n    group.addoption(\n        \"--markers\",\n        action=\"store_true\",\n        help=\"show markers (builtin, plugin and per-project ones).\",\n    )\n\n    parser.addini(\"markers\", \"Markers for test functions\", \"linelist\")\n    parser.addini(EMPTY_PARAMETERSET_OPTION, \"Default marker for empty parametersets\")\n\n\n@hookimpl(tryfirst=True)\ndef pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:\n    import _pytest.config\n\n    if config.option.markers:\n        config._do_configure()\n        tw = _pytest.config.create_terminal_writer(config)\n        for line in config.getini(\"markers\"):\n            parts = line.split(\":\", 1)\n            name = parts[0]\n            rest = parts[1] if len(parts) == 2 else \"\"\n            tw.write(\"@pytest.mark.%s:\" % name, bold=True)\n            tw.line(rest)\n            tw.line()\n        config._ensure_unconfigure()\n        return 0\n\n    return None\n\n\n@attr.s(slots=True, auto_attribs=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names: AbstractSet[str]\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False\n\n\ndef deselect_by_keyword(items: \"List[Item]\", config: Config) -> None:\n    keywordexpr = config.option.keyword.lstrip()\n    if not keywordexpr:\n        return\n\n    expr = _parse_expression(keywordexpr, \"Wrong expression passed to '-k'\")\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if not expr.evaluate(KeywordMatcher.from_item(colitem)):\n            deselected.append(colitem)\n        else:\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\n@attr.s(slots=True, auto_attribs=True)\nclass MarkMatcher:\n    \"\"\"A matcher for markers which are present.\n\n    Tries to match on any marker names, attached to the given colitem.\n    \"\"\"\n\n    own_mark_names: AbstractSet[str]\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"MarkMatcher\":\n        mark_names = {mark.name for mark in item.iter_markers()}\n        return cls(mark_names)\n\n    def __call__(self, name: str) -> bool:\n        return name in self.own_mark_names\n\n\ndef deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    expr = _parse_expression(matchexpr, \"Wrong expression passed to '-m'\")\n    remaining: List[Item] = []\n    deselected: List[Item] = []\n    for item in items:\n        if expr.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\ndef _parse_expression(expr: str, exc_message: str) -> Expression:\n    try:\n        return Expression.compile(expr)\n    except ParseError as e:\n        raise UsageError(f\"{exc_message}: {expr}: {e}\") from None\n\n\ndef pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)\n\n\ndef pytest_configure(config: Config) -> None:\n    config.stash[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            \"{!s} must be one of skip, xfail or fail_at_collect\"\n            \" but it is {!r}\".format(EMPTY_PARAMETERSET_OPTION, empty_parameterset)\n        )\n\n\ndef pytest_unconfigure(config: Config) -> None:\n    MARK_GEN._config = config.stash.get(old_mark_config_key, None)\n</file_content>"
    }
  ],
  "completion": {
    "id": "chatcmpl-9wMBTygsLt99XMHqnYZHcSWCBkYyN",
    "choices": [
      {
        "finish_reason": "stop",
        "index": 0,
        "logprobs": null,
        "message": {
          "content": "{\"scratch_pad\":\"In the given issue, the problem is related to how pytest handles markers in a multiple inheritance scenario, specifically how markers might be lost when multiple classes are involved due to the Method Resolution Order (MRO). The goal is to ensure that markers are correctly inherited according to MRO and not overridden. The issue proposes using metaclasses to handle this more intuitively.\\n\\nAnalyzing the `src/_pytest/mark/__init__.py` file content, we see functions and classes related to handling pytest markers. \\n\\n- The `param()` function allows specification of parameters and their markers, which could relate to how markers are attributed and interact with tests.\\n- The `KeywordMatcher` and `MarkMatcher` classes both seem to concern themselves with finding the matching tests or markers respectively based on properties or conditions.\\n\\nHowever, the key portions pertaining to the issue specifically must involve the interaction with class inheritance and the MRO, which do not appear to be directly handled in this file. The content is more about processing and filtering tests based on markers rather than setting or inheriting them in class definitions.\\n\\nGiven that this file mainly handles options related to markers or keywords and how to filter tests in pytest according to them, it is not directly related to altering marker inheritance across MRO or dealing with multiple inheritance scenarios. The solution proposed by the issue involves amending how markers are merged or aggregated across class hierarchies, potentially involving changes in marker storage or retrieval logic during test discovery or collection phases which aren't dealt here.\\n\\nThus, this file is likely relevant in understanding how markers are passed to tests but it isn't the root cause where markers inheritance via MRO is handled.\",\"relevant\":false,\"root_cause\":false,\"relevant_files\":[\"src/_pytest/nodes.py\",\"src/_pytest/mark/structures.py\"],\"relevant_symbols\":[],\"root_cause_symbol\":[]}",
          "refusal": null,
          "role": "assistant",
          "function_call": null,
          "tool_calls": [],
          "parsed": {
            "scratch_pad": "In the given issue, the problem is related to how pytest handles markers in a multiple inheritance scenario, specifically how markers might be lost when multiple classes are involved due to the Method Resolution Order (MRO). The goal is to ensure that markers are correctly inherited according to MRO and not overridden. The issue proposes using metaclasses to handle this more intuitively.\n\nAnalyzing the `src/_pytest/mark/__init__.py` file content, we see functions and classes related to handling pytest markers. \n\n- The `param()` function allows specification of parameters and their markers, which could relate to how markers are attributed and interact with tests.\n- The `KeywordMatcher` and `MarkMatcher` classes both seem to concern themselves with finding the matching tests or markers respectively based on properties or conditions.\n\nHowever, the key portions pertaining to the issue specifically must involve the interaction with class inheritance and the MRO, which do not appear to be directly handled in this file. The content is more about processing and filtering tests based on markers rather than setting or inheriting them in class definitions.\n\nGiven that this file mainly handles options related to markers or keywords and how to filter tests in pytest according to them, it is not directly related to altering marker inheritance across MRO or dealing with multiple inheritance scenarios. The solution proposed by the issue involves amending how markers are merged or aggregated across class hierarchies, potentially involving changes in marker storage or retrieval logic during test discovery or collection phases which aren't dealt here.\n\nThus, this file is likely relevant in understanding how markers are passed to tests but it isn't the root cause where markers inheritance via MRO is handled.",
            "relevant": false,
            "root_cause": false,
            "relevant_files": [
              "src/_pytest/nodes.py",
              "src/_pytest/mark/structures.py"
            ],
            "relevant_symbols": [],
            "root_cause_symbol": []
          }
        }
      }
    ],
    "created": 1723695327,
    "model": "gpt-4o-2024-08-06",
    "object": "chat.completion",
    "service_tier": null,
    "system_fingerprint": "fp_2a322c9ffc",
    "usage": {
      "completion_tokens": 388,
      "prompt_tokens": 5854,
      "total_tokens": 6242
    }
  }
}