{
  "total_cost": 0,
  "task_id": "tidb_vector_python_58",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-21T18:09:10.709516",
        "usage": "1067.9240226745605 ms"
      },
      "request": {
        "repo_tokens": [
          "_create_engine",
          "format_docs",
          "SECRET_KEY",
          "embedding",
          "DistanceStrategy",
          "tidb_vector",
          "STATIC_URL",
          "knowledge_base",
          "insert_documents",
          "execute",
          "logger",
          "sentence_transformer_embedding_function",
          "reason",
          "migrations",
          "content",
          "VectorType",
          "views",
          "Migration",
          "decode_vector",
          "ROOT_URLCONF",
          "DEFAULT_AUTO_FIELD",
          "models",
          "initial",
          "query",
          "others",
          "integrations",
          "ALLOWED_HOSTS",
          "resp",
          "example",
          "parser",
          "get_nearest_neighbors_documents",
          "cache_ok",
          "handler_file",
          "__del__",
          "python_value",
          "ClassEnum",
          "operations",
          "retriever",
          "_create_vector_table_model",
          "AUTH_PASSWORD_VALIDATORS",
          "handler_strout",
          "k",
          "distance_strategy",
          "wsgi",
          "delete",
          "chain",
          "_check_table_compatibility",
          "cosine_distance",
          "VectorField",
          "album",
          "dependencies",
          "USE_TZ",
          "category",
          "MAX_DIMENSION_LENGTH",
          "_",
          "EmbeddingColumnMismatchError",
          "get_embedding_column_definition",
          "INSTALLED_APPS",
          "urls",
          "extract_info_from_column_definition",
          "actor",
          "negative_inner_product",
          "USE_I18N",
          "book",
          "get_documents_within_distance",
          "asgi",
          "songwriter",
          "l2_distance",
          "LANGUAGE_CODE",
          "id",
          "_create_table_if_not_exists",
          "settings",
          "WSGI_APPLICATION",
          "__deepcopy__",
          "get_modifiers",
          "musician",
          "DATABASES",
          "get_col_spec",
          "prompt",
          "urlpatterns",
          "peewee",
          "embedding_function",
          "rm",
          "_get_relevant_documents",
          "TEMPLATES",
          "TiRetriever",
          "constants",
          "COSINE",
          "langchain-agent-demo",
          "field_type",
          "tidb_vector_client",
          "db_value",
          "_make_session",
          "logfile",
          "distance",
          "Document",
          "_vector_search",
          "embed_model",
          "TIME_ZONE",
          "Vector",
          "Vectors",
          "tools",
          "DEBUG",
          "DocumentWithIndex",
          "director",
          "QueryResult",
          "embed_model_dim",
          "l1_distance",
          "metadata",
          "model_with_tools",
          "TiDBVectorClient",
          "_create_filter_clause",
          "bind_processor",
          "__version__",
          "MIN_DIMENSION_LENGTH",
          "check_table_existence",
          "application",
          "encode_vector",
          "BASE_DIR",
          "Classification",
          "utils",
          "_build_filter_clause",
          "MIDDLEWARE",
          "sqlalchemy",
          "document",
          "insert",
          "EUCLIDEAN",
          "TIDB_CA_PATH",
          "list_routes",
          "drop_table",
          "__init__",
          "sample_project",
          "model",
          "comparator_factory",
          "result_processor",
          "__all__",
          "documents"
        ]
      },
      "response": {
        "keywords": [
          "TiDBVectorClient",
          "__del__",
          "integrations",
          "vector_client",
          "sqlalchemy",
          "__init__",
          "Connection",
          "execute"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-21T18:09:11.777468",
        "usage": "215.9590721130371 ms"
      },
      "request": {
        "tokens": [
          "TiDBVectorClient",
          "__del__",
          "integrations",
          "vector_client",
          "sqlalchemy",
          "__init__",
          "Connection",
          "execute"
        ]
      },
      "response": {
        "results": {
          "execute": [
            "./examples/graphrag-demo/graphrag-demo.py",
            "./tests/integrations/test_vector_client.py",
            "./examples/gemini-ai-embeddings-demo/example.py",
            "./examples/dspy-demo/example.py",
            "./tidb_vector/integrations/utils.py",
            "./examples/openai_embedding/example.py",
            "./examples/langchain-agent-demo/knowledge_base.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "integrations": [
            "./tests/integrations/test_vector_client.py",
            "./tidb_vector/integrations/__init__.py",
            "./tests/integrations/test_utils.py",
            "./examples/dspy-demo/example.py",
            "./examples/python-client-quickstart/example.py",
            "./examples/langchain-agent-demo/knowledge_base.py",
            "./examples/dspy-demo/utils.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "sqlalchemy": [
            "./examples/graphrag-demo/graphrag-demo.py",
            "./tests/integrations/test_vector_client.py",
            "./tidb_vector/sqlalchemy/__init__.py",
            "./examples/jina-ai-embeddings-demo/jina-ai-embeddings-demo.py",
            "./examples/semantic-cache/cache.py",
            "./examples/llamaindex-tidb-vector-with-ui/app.py",
            "./examples/llamaindex-tidb-vector/chat_with_url.py",
            "./tidb_vector/integrations/utils.py",
            "./tests/sqlalchemy/test_sqlalchemy.py",
            "./examples/orm-sqlalchemy-quickstart/sqlalchemy-quickstart.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "TiDBVectorClient": [
            "./tests/integrations/test_vector_client.py",
            "./tidb_vector/integrations/__init__.py",
            "./examples/dspy-demo/example.py",
            "./examples/python-client-quickstart/example.py",
            "./examples/langchain-agent-demo/knowledge_base.py",
            "./examples/dspy-demo/utils.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "Connection": [
            "./examples/graphrag-demo/graphrag-demo.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "__init__": [
            "./tidb_vector/sqlalchemy/__init__.py",
            "./tidb_vector/peewee/__init__.py",
            "./tidb_vector/integrations/utils.py",
            "./examples/dspy-demo/utils.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "vector_client": [
            "./tidb_vector/integrations/__init__.py"
          ],
          "__del__": [
            "./tidb_vector/integrations/vector_client.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-21T18:09:11.993440",
        "usage": "5504.41312789917 ms"
      },
      "request": {
        "keyword_search_results": {
          "execute": [
            "./examples/graphrag-demo/graphrag-demo.py",
            "./tests/integrations/test_vector_client.py",
            "./examples/gemini-ai-embeddings-demo/example.py",
            "./examples/dspy-demo/example.py",
            "./tidb_vector/integrations/utils.py",
            "./examples/openai_embedding/example.py",
            "./examples/langchain-agent-demo/knowledge_base.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "integrations": [
            "./tests/integrations/test_vector_client.py",
            "./tidb_vector/integrations/__init__.py",
            "./tests/integrations/test_utils.py",
            "./examples/dspy-demo/example.py",
            "./examples/python-client-quickstart/example.py",
            "./examples/langchain-agent-demo/knowledge_base.py",
            "./examples/dspy-demo/utils.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "sqlalchemy": [
            "./examples/graphrag-demo/graphrag-demo.py",
            "./tests/integrations/test_vector_client.py",
            "./tidb_vector/sqlalchemy/__init__.py",
            "./examples/jina-ai-embeddings-demo/jina-ai-embeddings-demo.py",
            "./examples/semantic-cache/cache.py",
            "./examples/llamaindex-tidb-vector-with-ui/app.py",
            "./examples/llamaindex-tidb-vector/chat_with_url.py",
            "./tidb_vector/integrations/utils.py",
            "./tests/sqlalchemy/test_sqlalchemy.py",
            "./examples/orm-sqlalchemy-quickstart/sqlalchemy-quickstart.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "TiDBVectorClient": [
            "./tests/integrations/test_vector_client.py",
            "./tidb_vector/integrations/__init__.py",
            "./examples/dspy-demo/example.py",
            "./examples/python-client-quickstart/example.py",
            "./examples/langchain-agent-demo/knowledge_base.py",
            "./examples/dspy-demo/utils.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "Connection": [
            "./examples/graphrag-demo/graphrag-demo.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "__init__": [
            "./tidb_vector/sqlalchemy/__init__.py",
            "./tidb_vector/peewee/__init__.py",
            "./tidb_vector/integrations/utils.py",
            "./examples/dspy-demo/utils.py",
            "./tidb_vector/integrations/vector_client.py"
          ],
          "vector_client": [
            "./tidb_vector/integrations/__init__.py"
          ],
          "__del__": [
            "./tidb_vector/integrations/vector_client.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The reported issue is an AttributeError that occurs in the `__del__` method of the `TiDBVectorClient` class. It suggests that there is a problem with `sqlalchemy.engine` being `None`, which should not happen if it's supposed to represent a `sqlalchemy.engine.base.Connection` object.\n\nLet's consider relevant files based on keywords related to this problem:\n\n1. **`__del__`**: This is a core part of the issue, as the traceback explicitly references the `__del__` method and reports an AttributeError. The file `./tidb_vector/integrations/vector_client.py` is very likely relevant because it contains the `__del__` method implementation.\n\n2. **`TiDBVectorClient`**: The problem references the `TiDBVectorClient.__del__` method, implying that `vector_client.py` file, where the class is defined, might contain relevant code.\n\n3. **`sqlalchemy`**: Since the issue involves an unexpected NoneType where a `sqlalchemy` connection object is expected, files managing SQLAlchemy connections might help diagnose the problem. The file `./tidb_vector/integrations/vector_client.py` also appears under this keyword, confirming its relevance.\n\nConsidering these observations, the most pertinent file to check for this issue is `./tidb_vector/integrations/vector_client.py`. This file appears multiple times across keywords that directly relate to the problem context (e.g., `__del__`, `TiDBVectorClient`, `sqlalchemy`). Other files while containing references to related keywords such as `execute` and `integrations` are less directly related to the problem of an AttributeError originating from the `__del__` method.\n\nThus, the relevant file based on the problem description is:\n1. `./tidb_vector/integrations/vector_client.py`.",
        "file_paths": [
          "./tidb_vector/integrations/vector_client.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-21T18:09:17.497883",
        "usage": "10407.292127609253 ms"
      },
      "request": {
        "file_path": "./tidb_vector/integrations/vector_client.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the Issue:\n\n1.1 The issue describes an exception occurring in the `__del__` method of the `TiDBVectorClient` class where there is an `AttributeError` because a 'NoneType' object has no attribute 'Connection'. \n\n1.2 The issue occurs when the `__del__` method accesses `self._bind`, which should be a connection object but is apparently `None` or not of the expected type at the time of deletion.\n\n1.3 The file references `sqlalchemy.engine.base.Connection` which should hold a valid connection, thus leading to the conclusion this reference becomes `None` somewhere in the lifecycle of the `TiDBVectorClient` object.\n\n1.4 The user's expectation is that the `__del__` method should close an existing connection, but it seems that under certain conditions within the desctructor, `self._bind` is unexpectedly `None`. \n\n1.5 The problem might be due to the timing of when the `__del__` method is being called, often when the interpreter is tearing down, and certain resources might already be cleaned up or in a state of being destructed, especially in higher versions of Python.\n\n1.6 Potential solutions include adding a check before attempting to close `self._bind`, possibly with `if hasattr(self._bind, 'close'):` or similar to ensure the method exists before calling it. Alternatively, it's useful to manage resource cleanup outside of `__del__` for more predictable behavior.\n\n2. Checking the Relevance of the File:\n\n2.1/2.2 The file provided includes the `TiDBVectorClient` class and the `__del__` method associated with it directly, as well as the creation and expected maintenance of database connections.\n\n2.3 The `__del__` method is explicitly referenced and is the location of the attribute error as noted in the issue.\n\n2.4 Several private methods `self._create_engine()` are present, which pertain to the setup and use of the `self._bind` connection that `__del__` attempts to access.\n\n2.5 Functions like `_create_engine` are crucial because they show how `self._bind` is initialized.\n\n3. Conclusion: The file is relevant. The issue is rooted in the management lifecycle of the `self._bind` connection within the `TiDBVectorClient` class.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "TiDBVectorClient",
          "TiDBVectorClient.__del__",
          "TiDBVectorClient._create_engine"
        ],
        "root_cause_symbols": [
          "TiDBVectorClient",
          "TiDBVectorClient.__del__"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-21T18:09:27.905201",
        "usage": "59.58104133605957 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "relevant_symbol_keys": [
              "TiDBVectorClient",
              "TiDBVectorClient.__del__",
              "TiDBVectorClient._create_engine"
            ],
            "root_cause_symbol_keys": [
              "TiDBVectorClient",
              "TiDBVectorClient.__del__"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "tidb_vector.integrations.TiDBVectorClient",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "class TiDBVectorClient:\n    def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()\n\n    def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )\n\n    def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index\n\n    def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())\n\n    def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)\n\n    def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()\n\n    def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result\n\n    @contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)\n\n    @property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )\n\n    def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids\n\n    def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()\n\n    def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]\n\n    def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results\n\n    def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by\n\n    def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata\n\n    def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
            "start_line": 77,
            "start_column": 2329,
            "end_line": 0,
            "end_column": 21447,
            "start_byte": 2329,
            "end_byte": 0
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__init__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()",
            "start_line": 78,
            "start_column": 2357,
            "end_line": 4,
            "end_column": 4192,
            "start_byte": 2357,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._check_table_compatibility",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )",
            "start_line": 121,
            "start_column": 4198,
            "end_line": 4,
            "end_column": 5685,
            "start_byte": 4198,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_table_if_not_exists",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index",
            "start_line": 153,
            "start_column": 5691,
            "end_line": 4,
            "end_column": 6130,
            "start_byte": 5691,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.drop_table",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())",
            "start_line": 164,
            "start_column": 6136,
            "end_line": 4,
            "end_column": 6336,
            "start_byte": 6136,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_engine",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)",
            "start_line": 169,
            "start_column": 6342,
            "end_line": 4,
            "end_column": 6526,
            "start_byte": 6342,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__del__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()",
            "start_line": 173,
            "start_column": 6532,
            "end_line": 4,
            "end_column": 6765,
            "start_byte": 6532,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__deepcopy__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result",
            "start_line": 180,
            "start_column": 6771,
            "end_line": 4,
            "end_column": 7345,
            "start_byte": 6771,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._make_session",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "@contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)",
            "start_line": 196,
            "start_column": 7351,
            "end_line": 4,
            "end_column": 7530,
            "start_byte": 7351,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.distance_strategy",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "@property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )",
            "start_line": 201,
            "start_column": 7536,
            "end_line": 4,
            "end_column": 8449,
            "start_byte": 7536,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.insert",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids",
            "start_line": 220,
            "start_column": 8455,
            "end_line": 4,
            "end_column": 9736,
            "start_byte": 8455,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.delete",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()",
            "start_line": 259,
            "start_column": 9742,
            "end_line": 4,
            "end_column": 10450,
            "start_byte": 9742,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.query",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]",
            "start_line": 280,
            "start_column": 10456,
            "end_line": 4,
            "end_column": 11796,
            "start_byte": 10456,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._vector_search",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results",
            "start_line": 316,
            "start_column": 11802,
            "end_line": 4,
            "end_column": 14125,
            "start_byte": 11802,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._build_filter_clause",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by",
            "start_line": 372,
            "start_column": 14131,
            "end_line": 4,
            "end_column": 16793,
            "start_byte": 14131,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_filter_clause",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata",
            "start_line": 442,
            "start_column": 16799,
            "end_line": 4,
            "end_column": 18755,
            "start_byte": 16799,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.execute",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
            "start_line": 497,
            "start_column": 18761,
            "end_line": 4,
            "end_column": 21447,
            "start_byte": 18761,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-21T18:09:27.964789",
        "usage": "8692.327976226807 ms"
      },
      "request": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "tidb_vector.integrations.TiDBVectorClient",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "class TiDBVectorClient:\n    def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()\n\n    def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )\n\n    def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index\n\n    def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())\n\n    def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)\n\n    def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()\n\n    def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result\n\n    @contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)\n\n    @property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )\n\n    def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids\n\n    def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()\n\n    def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]\n\n    def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results\n\n    def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by\n\n    def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata\n\n    def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
            "start_line": 77,
            "start_column": 2329,
            "end_line": 0,
            "end_column": 21447,
            "start_byte": 2329,
            "end_byte": 0
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__init__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()",
            "start_line": 78,
            "start_column": 2357,
            "end_line": 4,
            "end_column": 4192,
            "start_byte": 2357,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._check_table_compatibility",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )",
            "start_line": 121,
            "start_column": 4198,
            "end_line": 4,
            "end_column": 5685,
            "start_byte": 4198,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_table_if_not_exists",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index",
            "start_line": 153,
            "start_column": 5691,
            "end_line": 4,
            "end_column": 6130,
            "start_byte": 5691,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.drop_table",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())",
            "start_line": 164,
            "start_column": 6136,
            "end_line": 4,
            "end_column": 6336,
            "start_byte": 6136,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_engine",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)",
            "start_line": 169,
            "start_column": 6342,
            "end_line": 4,
            "end_column": 6526,
            "start_byte": 6342,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__del__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()",
            "start_line": 173,
            "start_column": 6532,
            "end_line": 4,
            "end_column": 6765,
            "start_byte": 6532,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__deepcopy__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result",
            "start_line": 180,
            "start_column": 6771,
            "end_line": 4,
            "end_column": 7345,
            "start_byte": 6771,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._make_session",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "@contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)",
            "start_line": 196,
            "start_column": 7351,
            "end_line": 4,
            "end_column": 7530,
            "start_byte": 7351,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.distance_strategy",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "@property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )",
            "start_line": 201,
            "start_column": 7536,
            "end_line": 4,
            "end_column": 8449,
            "start_byte": 7536,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.insert",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids",
            "start_line": 220,
            "start_column": 8455,
            "end_line": 4,
            "end_column": 9736,
            "start_byte": 8455,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.delete",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()",
            "start_line": 259,
            "start_column": 9742,
            "end_line": 4,
            "end_column": 10450,
            "start_byte": 9742,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.query",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]",
            "start_line": 280,
            "start_column": 10456,
            "end_line": 4,
            "end_column": 11796,
            "start_byte": 10456,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._vector_search",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results",
            "start_line": 316,
            "start_column": 11802,
            "end_line": 4,
            "end_column": 14125,
            "start_byte": 11802,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._build_filter_clause",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by",
            "start_line": 372,
            "start_column": 14131,
            "end_line": 4,
            "end_column": 16793,
            "start_byte": 14131,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_filter_clause",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata",
            "start_line": 442,
            "start_column": 16799,
            "end_line": 4,
            "end_column": 18755,
            "start_byte": 16799,
            "end_byte": 4
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.execute",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
            "start_line": 497,
            "start_column": 18761,
            "end_line": 4,
            "end_column": 21447,
            "start_byte": 18761,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "Analysis of the Issue:\n1.1 The user is experiencing an `AttributeError` during the execution of the `__del__()` method in the `TiDBVectorClient` class, where `self._bind` is found to be `None`.\n1.2 This issue might be caused if the `self._bind` attribute is not correctly initialized as a `Connection` object or if it is reset.\n1.3 The expected result is that the object should correctly close its connection by accessing `self._bind.close()` without raising an exception.\n1.4 If the user did not provide an expected result, the expectation should be that `self._bind` is always initialized properly and not set to `None` unexpectedly.\n1.5 To fix this, ensure that `self._bind` is always initialized and handled properly throughout the object's lifecycle.\n\nEvaluate Symbols:\n2.1 Analyze each symbol provided, specifically checking initialization and handling of `self._bind`.\n2.2 Cross-reference the initialization of `self._bind = self._create_engine()` in `__init__` and the closing logic in `__del__`.\n2.3 Evaluate the relevance of the `__del__`, `_create_engine`, and `__init__` methods primarily, as they deal with `self._bind` directly.\n2.4 Assume that the change needed might be related to ensuring `self._bind` remains a valid connection object during the lifecycle of the class instance.",
        "symbols": [
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__del__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "reason": "The del method is directly related to the issue as it tries to access self._bind, which raises AttributeError when self._bind is None."
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient.__init__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "reason": "The __init__ method is responsible for initializing self._bind using the _create_engine method. It's crucial to ensure this initialization is correct."
          },
          {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_engine",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "reason": "The _create_engine method creates the engine that's assigned to self._bind, ensuring this always returns the correct Engine instance is vital to solving the issue."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The __del__ method is where the exception occurs, as it tries to access self._bind and close it. The key here is to ensure that self._bind is valid before this method is executed.",
          "The __init__ method initializes the self._bind attribute via a call to _create_engine. It's crucial to ensure this initialization doesn't fail and that self._bind is set correctly from the outset.",
          "The _create_engine method is supposed to return a sqlalchemy Engine based on the connection string. Ensuring it is always correct is crucial to prevent self._bind from being None."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-21T18:09:36.657150",
        "usage": "2.696990966796875 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [],
          "root_caused_symbols": [
            {
              "name": "tidb_vector.integrations.TiDBVectorClient",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "class TiDBVectorClient:\n    def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()\n\n    def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )\n\n    def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index\n\n    def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())\n\n    def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)\n\n    def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()\n\n    def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result\n\n    @contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)\n\n    @property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )\n\n    def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids\n\n    def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()\n\n    def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]\n\n    def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results\n\n    def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by\n\n    def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata\n\n    def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
              "start_line": 77,
              "start_column": 2329,
              "end_line": 0,
              "end_column": 21447,
              "start_byte": 2329,
              "end_byte": 0
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.__init__",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()",
              "start_line": 78,
              "start_column": 2357,
              "end_line": 4,
              "end_column": 4192,
              "start_byte": 2357,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._check_table_compatibility",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )",
              "start_line": 121,
              "start_column": 4198,
              "end_line": 4,
              "end_column": 5685,
              "start_byte": 4198,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._create_table_if_not_exists",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index",
              "start_line": 153,
              "start_column": 5691,
              "end_line": 4,
              "end_column": 6130,
              "start_byte": 5691,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.drop_table",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())",
              "start_line": 164,
              "start_column": 6136,
              "end_line": 4,
              "end_column": 6336,
              "start_byte": 6136,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._create_engine",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)",
              "start_line": 169,
              "start_column": 6342,
              "end_line": 4,
              "end_column": 6526,
              "start_byte": 6342,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.__del__",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()",
              "start_line": 173,
              "start_column": 6532,
              "end_line": 4,
              "end_column": 6765,
              "start_byte": 6532,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.__deepcopy__",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result",
              "start_line": 180,
              "start_column": 6771,
              "end_line": 4,
              "end_column": 7345,
              "start_byte": 6771,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._make_session",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "@contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)",
              "start_line": 196,
              "start_column": 7351,
              "end_line": 4,
              "end_column": 7530,
              "start_byte": 7351,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.distance_strategy",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "@property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )",
              "start_line": 201,
              "start_column": 7536,
              "end_line": 4,
              "end_column": 8449,
              "start_byte": 7536,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.insert",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids",
              "start_line": 220,
              "start_column": 8455,
              "end_line": 4,
              "end_column": 9736,
              "start_byte": 8455,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.delete",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()",
              "start_line": 259,
              "start_column": 9742,
              "end_line": 4,
              "end_column": 10450,
              "start_byte": 9742,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.query",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]",
              "start_line": 280,
              "start_column": 10456,
              "end_line": 4,
              "end_column": 11796,
              "start_byte": 10456,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._vector_search",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results",
              "start_line": 316,
              "start_column": 11802,
              "end_line": 4,
              "end_column": 14125,
              "start_byte": 11802,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._build_filter_clause",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by",
              "start_line": 372,
              "start_column": 14131,
              "end_line": 4,
              "end_column": 16793,
              "start_byte": 14131,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._create_filter_clause",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata",
              "start_line": 442,
              "start_column": 16799,
              "end_line": 4,
              "end_column": 18755,
              "start_byte": 16799,
              "end_byte": 4
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.execute",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "file_content": "def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
              "start_line": 497,
              "start_column": 18761,
              "end_line": 4,
              "end_column": 21447,
              "start_byte": 18761,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Analysis of the Issue:\n1.1 The user is experiencing an `AttributeError` during the execution of the `__del__()` method in the `TiDBVectorClient` class, where `self._bind` is found to be `None`.\n1.2 This issue might be caused if the `self._bind` attribute is not correctly initialized as a `Connection` object or if it is reset.\n1.3 The expected result is that the object should correctly close its connection by accessing `self._bind.close()` without raising an exception.\n1.4 If the user did not provide an expected result, the expectation should be that `self._bind` is always initialized properly and not set to `None` unexpectedly.\n1.5 To fix this, ensure that `self._bind` is always initialized and handled properly throughout the object's lifecycle.\n\nEvaluate Symbols:\n2.1 Analyze each symbol provided, specifically checking initialization and handling of `self._bind`.\n2.2 Cross-reference the initialization of `self._bind = self._create_engine()` in `__init__` and the closing logic in `__del__`.\n2.3 Evaluate the relevance of the `__del__`, `_create_engine`, and `__init__` methods primarily, as they deal with `self._bind` directly.\n2.4 Assume that the change needed might be related to ensuring `self._bind` remains a valid connection object during the lifecycle of the class instance.",
          "symbols": [
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.__del__",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "reason": "The del method is directly related to the issue as it tries to access self._bind, which raises AttributeError when self._bind is None."
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient.__init__",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "reason": "The __init__ method is responsible for initializing self._bind using the _create_engine method. It's crucial to ensure this initialization is correct."
            },
            {
              "name": "tidb_vector.integrations.TiDBVectorClient._create_engine",
              "file_path": "./tidb_vector/integrations/vector_client.py",
              "reason": "The _create_engine method creates the engine that's assigned to self._bind, ensuring this always returns the correct Engine instance is vital to solving the issue."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The __del__ method is where the exception occurs, as it tries to access self._bind and close it. The key here is to ensure that self._bind is valid before this method is executed.",
            "The __init__ method initializes the self._bind attribute via a call to _create_engine. It's crucial to ensure this initialization doesn't fail and that self._bind is set correctly from the outset.",
            "The _create_engine method is supposed to return a sqlalchemy Engine based on the connection string. Ensuring it is always correct is crucial to prevent self._bind from being None."
          ]
        }
      },
      "response": {
        "file_paths": [
          "./tidb_vector/integrations/vector_client.py"
        ],
        "symbols": [
          "tidb_vector.integrations.TiDBVectorClient.__del__",
          "tidb_vector.integrations.TiDBVectorClient.__init__",
          "tidb_vector.integrations.TiDBVectorClient._create_engine"
        ],
        "code_spans": {
          "tidb_vector.integrations.TiDBVectorClient": {
            "name": "tidb_vector.integrations.TiDBVectorClient",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "class TiDBVectorClient:\n    def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()\n\n    def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )\n\n    def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index\n\n    def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())\n\n    def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)\n\n    def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()\n\n    def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result\n\n    @contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)\n\n    @property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )\n\n    def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids\n\n    def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()\n\n    def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]\n\n    def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results\n\n    def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by\n\n    def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata\n\n    def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
            "start_line": 77,
            "start_column": 2329,
            "end_line": 0,
            "end_column": 21447,
            "start_byte": 2329,
            "end_byte": 0
          },
          "tidb_vector.integrations.TiDBVectorClient.__init__": {
            "name": "tidb_vector.integrations.TiDBVectorClient.__init__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __init__(\n        self,\n        connection_string: str,\n        table_name: str,\n        distance_strategy: Optional[DistanceStrategy] = None,\n        vector_dimension: Optional[int] = None,\n        *,\n        engine_args: Optional[Dict[str, Any]] = None,\n        drop_existing_table: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Initializes a vector client in a specified table within a TiDB database.\n\n        Args:\n            connection_string (str): The connection string for the TiDB database,\n                format: \"mysql+pymysql://root@127.0.0.1:4000/test\".\n            table_name (str): The name of the table used to store the vectors.\n            distance_strategy: The strategy used for similarity search,\n                defaults to \"cosine\", valid values: \"l2\", \"cosine\".\n            engine_args (Optional[Dict]): Additional arguments for the database engine,\n                defaults to None.\n            drop_existing_table: Delete the table before creating a new one,\n                defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self.connection_string = connection_string\n        self._distance_strategy = distance_strategy\n        self._vector_dimension = vector_dimension\n        self._table_name = table_name\n        self._engine_args = engine_args or {}\n        self._drop_existing_table = drop_existing_table\n        self._bind = self._create_engine()\n        self._check_table_compatibility()  # check if the embedding is compatible\n        self._orm_base, self._table_model = _create_vector_table_model(\n            table_name, vector_dimension, distance_strategy\n        )\n        _ = self.distance_strategy  # check if distance strategy is valid\n        self._create_table_if_not_exists()",
            "start_line": 78,
            "start_column": 2357,
            "end_line": 4,
            "end_column": 4192,
            "start_byte": 2357,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._check_table_compatibility": {
            "name": "tidb_vector.integrations.TiDBVectorClient._check_table_compatibility",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _check_table_compatibility(self) -> None:\n        \"\"\"\n        Check if the table is compatible with the current configuration.\n        \"\"\"\n        if self._drop_existing_table:\n            return\n\n        actual_dim, actual_distance_strategy = get_embedding_column_definition(\n            connection_string=self.connection_string,\n            table_name=self._table_name,\n            column_name=\"embedding\",\n            engine_args=self._engine_args,\n        )\n        if actual_dim is not None:\n            # If the vector dimension is not set, set it to the actual dimension\n            if self._vector_dimension is None:\n                self._vector_dimension = actual_dim\n            elif actual_dim != self._vector_dimension:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim})\",\n                    expected_col=f\"vector({self._vector_dimension})\",\n                )\n\n        if actual_distance_strategy is not None:\n            if self._distance_strategy is None:\n                self._distance_strategy = DistanceStrategy(actual_distance_strategy)\n            elif actual_distance_strategy != self._distance_strategy:\n                raise EmbeddingColumnMismatchError(\n                    existing_col=f\"vector({actual_dim}) COMMENT 'hnsw(distance={actual_distance_strategy})'\",\n                    expected_col=f\"vector({self._vector_dimension}) COMMENT 'hnsw(distance={self._distance_strategy})'\",\n                )",
            "start_line": 121,
            "start_column": 4198,
            "end_line": 4,
            "end_column": 5685,
            "start_byte": 4198,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._create_table_if_not_exists": {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_table_if_not_exists",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_table_if_not_exists(self) -> None:\n        \"\"\"\n        If the `self._pre_delete_table` flag is set,\n        the existing table will be dropped before creating a new one.\n        \"\"\"\n        if self._drop_existing_table:\n            self.drop_table()\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.create_all(session.get_bind())\n            # wait for tidb support vector index",
            "start_line": 153,
            "start_column": 5691,
            "end_line": 4,
            "end_column": 6130,
            "start_byte": 5691,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.drop_table": {
            "name": "tidb_vector.integrations.TiDBVectorClient.drop_table",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def drop_table(self) -> None:\n        \"\"\"Drops the table if it exists.\"\"\"\n        with Session(self._bind) as session, session.begin():\n            self._orm_base.metadata.drop_all(session.get_bind())",
            "start_line": 164,
            "start_column": 6136,
            "end_line": 4,
            "end_column": 6336,
            "start_byte": 6136,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._create_engine": {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_engine",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_engine(self) -> sqlalchemy.engine.Engine:\n        \"\"\"Create a sqlalchemy engine.\"\"\"\n        return sqlalchemy.create_engine(url=self.connection_string, **self._engine_args)",
            "start_line": 169,
            "start_column": 6342,
            "end_line": 4,
            "end_column": 6526,
            "start_byte": 6342,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.__del__": {
            "name": "tidb_vector.integrations.TiDBVectorClient.__del__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None and isinstance(\n            self._bind, sqlalchemy.engine.Connection\n        ):\n            self._bind.close()",
            "start_line": 173,
            "start_column": 6532,
            "end_line": 4,
            "end_column": 6765,
            "start_byte": 6532,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.__deepcopy__": {
            "name": "tidb_vector.integrations.TiDBVectorClient.__deepcopy__",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def __deepcopy__(self, memo):\n        # Create a shallow copy of the object to start with, to copy non-engine attributes\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n\n        # Copy all attributes except the engine connection (_bind)\n        for k, v in self.__dict__.items():\n            if k != \"_bind\":  # Skip copying the engine connection\n                setattr(result, k, copy.deepcopy(v, memo))\n\n        # Directly assign the engine connection without copying\n        result._bind = self._bind\n\n        return result",
            "start_line": 180,
            "start_column": 6771,
            "end_line": 4,
            "end_column": 7345,
            "start_byte": 6771,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._make_session": {
            "name": "tidb_vector.integrations.TiDBVectorClient._make_session",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "@contextlib.contextmanager\n    def _make_session(self) -> Generator[Session, None, None]:\n        \"\"\"Create a context manager for the session.\"\"\"\n        yield Session(self._bind)",
            "start_line": 196,
            "start_column": 7351,
            "end_line": 4,
            "end_column": 7530,
            "start_byte": 7351,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.distance_strategy": {
            "name": "tidb_vector.integrations.TiDBVectorClient.distance_strategy",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "@property\n    def distance_strategy(self) -> Any:\n        \"\"\"\n        Returns the distance function based on the current distance strategy value.\n        \"\"\"\n        if self._distance_strategy == DistanceStrategy.EUCLIDEAN:\n            return self._table_model.embedding.l2_distance\n        elif self._distance_strategy == DistanceStrategy.COSINE:\n            return self._table_model.embedding.cosine_distance\n        # elif self._distance_strategy == DistanceStrategy.INNER_PRODUCT:\n        #    return self._table_model.embedding.negative_inner_product\n        elif self._distance_strategy is None:  # default to cosine\n            return self._table_model.embedding.cosine_distance\n        else:\n            raise ValueError(\n                f\"Got unexpected value for distance: {self._distance_strategy}. \"\n                f\"Should be one of {', '.join([ds.value for ds in DistanceStrategy])}.\"\n            )",
            "start_line": 201,
            "start_column": 7536,
            "end_line": 4,
            "end_column": 8449,
            "start_byte": 7536,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.insert": {
            "name": "tidb_vector.integrations.TiDBVectorClient.insert",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def insert(\n        self,\n        texts: Iterable[str],\n        embeddings: Iterable[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"\n        Add texts to TiDB Vector.\n\n        Args:\n            texts (Iterable[str]): The texts to be added.\n            metadatas (Optional[List[dict]]): The metadata associated with each text,\n                Defaults to None.\n            ids (Optional[List[str]]): The IDs to be assigned to each text,\n                Defaults to None, will be generated if not provided.\n\n        Returns:\n            List[str]: The IDs assigned to the added texts.\n        \"\"\"\n        if ids is None:\n            ids = [str(uuid.uuid4()) for _ in texts]\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        with Session(self._bind) as session:\n            for text, metadata, embedding, id in zip(texts, metadatas, embeddings, ids):\n                embeded_doc = self._table_model(\n                    id=id,\n                    embedding=embedding,\n                    document=text,\n                    meta=metadata,\n                )\n                session.add(embeded_doc)\n            session.commit()\n\n        return ids",
            "start_line": 220,
            "start_column": 8455,
            "end_line": 4,
            "end_column": 9736,
            "start_byte": 8455,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.delete": {
            "name": "tidb_vector.integrations.TiDBVectorClient.delete",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def delete(\n        self,\n        ids: Optional[List[str]] = None,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"\n        Delete vector data from the TiDB vector.\n\n        Args:\n            ids (Optional[List[str]]): A list of vector IDs to delete.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        filter_by = self._build_filter_clause(filter)\n        with Session(self._bind) as session:\n            if ids is not None:\n                filter_by = sqlalchemy.and_(self._table_model.id.in_(ids), filter_by)\n            stmt = sqlalchemy.delete(self._table_model).filter(filter_by)\n            session.execute(stmt)\n            session.commit()",
            "start_line": 259,
            "start_column": 9742,
            "end_line": 4,
            "end_column": 10450,
            "start_byte": 9742,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.query": {
            "name": "tidb_vector.integrations.TiDBVectorClient.query",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def query(\n        self,\n        query_vector: List[float],\n        k: int = 5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[QueryResult]:\n        \"\"\"\n        Perform a similarity search with score based on the given query.\n\n        Args:\n            query (str): The query string.\n            k (int, optional): The number of results to return. Defaults to 5.\n            filter (dict, optional): A filter to apply to the search results.\n                Defaults to None.\n            post_filter_enabled (bool, optional): Whether to apply the post-filtering.\n                TiDB cannot utilize Vector Index when query contains a pre-filter.\n            post_filter_multiplier (int, optional): A multiplier to increase the initial\n                number of results fetched before applying the filter. Defaults to 1.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            A list of tuples containing relevant documents and their similarity scores.\n        \"\"\"\n        relevant_docs = self._vector_search(query_vector, k, filter, **kwargs)\n\n        return [\n            QueryResult(\n                document=doc.document,\n                metadata=doc.meta,\n                id=doc.id,\n                distance=doc.distance,\n            )\n            for doc in relevant_docs\n        ]",
            "start_line": 280,
            "start_column": 10456,
            "end_line": 4,
            "end_column": 11796,
            "start_byte": 10456,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._vector_search": {
            "name": "tidb_vector.integrations.TiDBVectorClient._vector_search",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _vector_search(\n        self,\n        query_embedding: List[float],\n        k: int = 5,\n        filter: Optional[Dict[str, str]] = None,\n        **kwargs: Any,\n    ) -> List[Any]:\n        \"\"\"vector search from table.\"\"\"\n\n        post_filter_enabled = kwargs.get(\"post_filter_enabled\", False)\n        post_filter_multiplier = kwargs.get(\"post_filter_multiplier\", 1)\n        with Session(self._bind) as session:\n            if post_filter_enabled is False or not filter:\n                filter_by = self._build_filter_clause(filter)\n                results: List[Any] = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(k)\n                    .all()\n                )\n            else:\n                # Caused by the tidb vector search plan limited, this post_filter_multiplier is used to\n                # improved the search performance temporarily.\n                # Notice the return count may be less than k in this situation.\n                subquery = (\n                    session.query(\n                        self._table_model.id,\n                        self._table_model.meta,\n                        self._table_model.document,\n                        self.distance_strategy(query_embedding).label(\"distance\"),\n                    )\n                    .order_by(sqlalchemy.asc(\"distance\"))\n                    .limit(post_filter_multiplier * k * 10)\n                    .subquery()\n                )\n                filter_by = self._build_filter_clause(filter, subquery.c)\n                results: List[Any] = (\n                    session.query(\n                        subquery.c.id,\n                        subquery.c.meta,\n                        subquery.c.document,\n                        subquery.c.distance,\n                    )\n                    .filter(filter_by)\n                    .order_by(sqlalchemy.asc(subquery.c.distance))\n                    .limit(k)\n                    .all()\n                )\n        return results",
            "start_line": 316,
            "start_column": 11802,
            "end_line": 4,
            "end_column": 14125,
            "start_byte": 11802,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._build_filter_clause": {
            "name": "tidb_vector.integrations.TiDBVectorClient._build_filter_clause",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _build_filter_clause(\n        self,\n        filters: Optional[Dict[str, Any]] = None,\n        table_model: Optional[Any] = None,\n    ) -> Any:\n        \"\"\"\n        Builds the filter clause for querying based on the provided filters.\n\n        Args:\n            filter (Dict[str, str]): The filter conditions to apply.\n\n        Returns:\n            Any: The filter clause to be used in the query on TiDB.\n        \"\"\"\n\n        if table_model is None:\n            table_model = self._table_model\n\n        filter_by = sqlalchemy.true()\n        if filters is not None:\n            filter_clauses = []\n\n            for key, value in filters.items():\n                if key.lower() == \"$and\":\n                    and_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.and_(*and_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() == \"$or\":\n                    or_clauses = [\n                        self._build_filter_clause(condition, table_model)\n                        for condition in value\n                        if isinstance(condition, dict) and condition is not None\n                    ]\n                    filter_by_metadata = sqlalchemy.or_(*or_clauses)\n                    filter_clauses.append(filter_by_metadata)\n                elif key.lower() in [\n                    \"$in\",\n                    \"$nin\",\n                    \"$gt\",\n                    \"$gte\",\n                    \"$lt\",\n                    \"$lte\",\n                    \"$eq\",\n                    \"$ne\",\n                ]:\n                    raise ValueError(\n                        f\"Got unexpected filter expression: {filter}. \"\n                        f\"Operator {key} must be followed by a meta key. \"\n                    )\n                elif isinstance(value, dict):\n                    filter_by_metadata = self._create_filter_clause(\n                        table_model, key, value\n                    )\n\n                    if filter_by_metadata is not None:\n                        filter_clauses.append(filter_by_metadata)\n                else:\n                    filter_by_metadata = (\n                        sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n                        == value\n                    )\n                    filter_clauses.append(filter_by_metadata)\n\n            filter_by = sqlalchemy.and_(filter_by, *filter_clauses)\n        return filter_by",
            "start_line": 372,
            "start_column": 14131,
            "end_line": 4,
            "end_column": 16793,
            "start_byte": 14131,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient._create_filter_clause": {
            "name": "tidb_vector.integrations.TiDBVectorClient._create_filter_clause",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def _create_filter_clause(self, table_model, key, value):\n        \"\"\"\n        Create a filter clause based on the provided key-value pair.\n\n        Args:\n            key (str): How to filter the value\n            value (dict): The value to filter with.\n\n        Returns:\n            sqlalchemy.sql.elements.BinaryExpression: The filter clause.\n\n        Raises:\n            None\n\n        \"\"\"\n\n        IN, NIN, GT, GTE, LT, LTE, EQ, NE = (\n            \"$in\",\n            \"$nin\",\n            \"$gt\",\n            \"$gte\",\n            \"$lt\",\n            \"$lte\",\n            \"$eq\",\n            \"$ne\",\n        )\n\n        json_key = sqlalchemy.func.json_extract(table_model.meta, f\"$.{key}\")\n        value_case_insensitive = {k.lower(): v for k, v in value.items()}\n\n        if IN in map(str.lower, value):\n            filter_by_metadata = json_key.in_(value_case_insensitive[IN])\n        elif NIN in map(str.lower, value):\n            filter_by_metadata = ~json_key.in_(value_case_insensitive[NIN])\n        elif GT in map(str.lower, value):\n            filter_by_metadata = json_key > value_case_insensitive[GT]\n        elif GTE in map(str.lower, value):\n            filter_by_metadata = json_key >= value_case_insensitive[GTE]\n        elif LT in map(str.lower, value):\n            filter_by_metadata = json_key < value_case_insensitive[LT]\n        elif LTE in map(str.lower, value):\n            filter_by_metadata = json_key <= value_case_insensitive[LTE]\n        elif NE in map(str.lower, value):\n            filter_by_metadata = json_key != value_case_insensitive[NE]\n        elif EQ in map(str.lower, value):\n            filter_by_metadata = json_key == value_case_insensitive[EQ]\n        else:\n            logger.warning(\n                f\"Unsupported filter operator: {value}. Consider using \"\n                \"one of $in, $nin, $gt, $gte, $lt, $lte, $eq, $ne, $or, $and.\"\n            )\n            filter_by_metadata = None\n\n        return filter_by_metadata",
            "start_line": 442,
            "start_column": 16799,
            "end_line": 4,
            "end_column": 18755,
            "start_byte": 16799,
            "end_byte": 4
          },
          "tidb_vector.integrations.TiDBVectorClient.execute": {
            "name": "tidb_vector.integrations.TiDBVectorClient.execute",
            "file_path": "./tidb_vector/integrations/vector_client.py",
            "file_content": "def execute(self, sql: str, params: Optional[dict] = None) -> dict:\n        \"\"\"\n        Execute an arbitrary SQL command and return execution status and result.\n\n        This method can handle both DML (Data Manipulation Language) commands such as INSERT, UPDATE, DELETE,\n        and DQL (Data Query Language) commands like SELECT. It returns a structured dictionary indicating\n        the execution success status, result (for SELECT queries or affected rows count for DML), and any\n        error message if the execution failed.\n\n        Args:\n            sql (str): The SQL command to execute.\n            params (Optional[dict]): Parameters to bind to the SQL command, if any.\n\n        Returns:\n            dict: A dictionary containing 'success': boolean indicating if the execution was successful,\n                'result': fetched results for SELECT or affected rows count for other statements,\n                and 'error': error message if execution failed.\n\n        Examples:\n            - Creating a table:\n            execute(\"CREATE TABLE users (id INT, username VARCHAR(50), email VARCHAR(50))\")\n            This would return: {'success': True, 'result': 0, 'error': None}\n\n            - Executing a SELECT query:\n            execute(\"SELECT * FROM users WHERE username = :username\", {\"username\": \"john_doe\"})\n            This would return: {'success': True, 'result': [(user data)], 'error': None}\n\n            - Inserting data into a table:\n            execute(\n                \"INSERT INTO users (username, email) VALUES (:username, :email)\",\n                {\"username\": \"new_user\", \"email\": \"new_user@example.com\"}\n            )\n            This would return: {'success': True, 'result': 1, 'error': None} if one row was affected.\n\n            - Handling an error (e.g., table does not exist):\n            execute(\"SELECT * FROM non_existing_table\")\n            This might return: {'success': False, 'result': None, 'error': '(Error message)'}\n        \"\"\"\n        try:\n            with Session(self._bind) as session, session.begin():\n                result = session.execute(sqlalchemy.text(sql), params)\n                session.commit()  # Ensure changes are committed for non-SELECT statements.\n                if sql.strip().lower().startswith(\"select\"):\n                    return {\"success\": True, \"result\": result.fetchall(), \"error\": None}\n                else:\n                    return {\"success\": True, \"result\": result.rowcount, \"error\": None}\n        except Exception as e:\n            # Log the error or handle it as needed\n            logger.error(f\"SQL execution error: {str(e)}\")\n            return {\"success\": False, \"result\": None, \"error\": str(e)}",
            "start_line": 497,
            "start_column": 18761,
            "end_line": 4,
            "end_column": 21447,
            "start_byte": 18761,
            "end_byte": 4
          }
        }
      }
    },
    {
      "name": "IssueAnalysis",
      "metadata": {
        "start": "2024-08-21T18:09:36.659865",
        "usage": "5214.270830154419 ms"
      },
      "request": {
        "file_path": "./tidb_vector/integrations/vector_client.py"
      },
      "response": {
        "scratch_pad": "1. The issue suggests that an `AttributeError` occurs in the `__del__` method of `TiDBVectorClient`. The error message indicates that a 'NoneType' object lacks a `Connection` attribute.\n\n2. The exception stack trace specifies that the issue arises in the `vector_client.py` file, in the `__del__` method.\n\n3. The user logs suggest they're checking whether `self._bind` is not `None` and `isinstance(self._bind, sqlalchemy.engine.base.Connection)`. Their expectation is for `self._bind` to be an active SQLAlchemy Connection object.\n\n4. Upon reviewing the code, the `__del__` method attempts to close `self._bind`. However, `self._create_engine` sets `self._bind` as a SQLAlchemy Engine, not Connection. This seems to have led to confusion or a misunderstanding.",
        "explain": "The error arises because the `__del__` method attempts to handle `self._bind` as if it were a `sqlalchemy.engine.Connection` object. However, this is inconsistent with the implementation in `__init__`, where `self._bind` is initialized to a `sqlalchemy.engine.Engine` object. To resolve this, adjust the `__del__` method to handle `Engine` after ensuring active connections, or remove/deprecate the method if automatic resource management is sufficient."
      }
    },
    {
      "name": "CodePlanV3",
      "metadata": {
        "start": "2024-08-21T18:09:41.874163",
        "usage": "3587.9411697387695 ms"
      },
      "request": {
        "issue_analysis": "The error arises because the `__del__` method attempts to handle `self._bind` as if it were a `sqlalchemy.engine.Connection` object. However, this is inconsistent with the implementation in `__init__`, where `self._bind` is initialized to a `sqlalchemy.engine.Engine` object. To resolve this, adjust the `__del__` method to handle `Engine` after ensuring active connections, or remove/deprecate the method if automatic resource management is sufficient.",
        "file_path": "./tidb_vector/integrations/vector_client.py"
      },
      "response": {
        "scratch_pad": "- The reported issue states that there's an `AttributeError` occurring in the `__del__` method of `TiDBVectorClient`, specifically trying to access an attribute 'Connection' on a 'NoneType' object.\n- The analysis explains that `self._bind` is being used as if it were a `Connection` in `__del__`, which is inconsistent with its initialization as an `Engine` object in `__init__`.\n- It implies `self._bind` should be an `Engine`, not a `Connection`, and that handling in `__del__` is incorrect as currently written.\n- The code supports this; `_create_engine()` clearly returns an `Engine`, so `self._bind` should be treated as such across the class.\n- `__del__` method should instead safely terminate any resources but not close `self._bind`, or entirely rely on Python's garbage collection to deal with resources from the SQLAlchemy `Engine`.\n- The proposal suggests either correctly wrapping up any connections using a proper method or dismissing the `__del__` method entirely if redundant.",
        "call_flowchart": "TiDBVectorClient#__del__() $access_self._bind\n",
        "is_fault": true,
        "plans": [
          {
            "file_path": "tidb_vector/integrations/vector_client.py",
            "type": "replace",
            "plan_detail": "Remove the __del__ method entirely from TiDBVectorClient class. SQLAlchemy handles connection resources efficiently with proper garbage collection and context management in Python."
          }
        ]
      }
    },
    {
      "name": "CodeGen",
      "metadata": {
        "start": "2024-08-21T18:09:45.462122",
        "usage": "6143.254041671753 ms"
      },
      "request": {
        "scratch_pad": "- The reported issue states that there's an `AttributeError` occurring in the `__del__` method of `TiDBVectorClient`, specifically trying to access an attribute 'Connection' on a 'NoneType' object.\n- The analysis explains that `self._bind` is being used as if it were a `Connection` in `__del__`, which is inconsistent with its initialization as an `Engine` object in `__init__`.\n- It implies `self._bind` should be an `Engine`, not a `Connection`, and that handling in `__del__` is incorrect as currently written.\n- The code supports this; `_create_engine()` clearly returns an `Engine`, so `self._bind` should be treated as such across the class.\n- `__del__` method should instead safely terminate any resources but not close `self._bind`, or entirely rely on Python's garbage collection to deal with resources from the SQLAlchemy `Engine`.\n- The proposal suggests either correctly wrapping up any connections using a proper method or dismissing the `__del__` method entirely if redundant.",
        "call_flowchart": "TiDBVectorClient#__del__() $access_self._bind\n",
        "is_fault": true,
        "plans": [
          {
            "file_path": "tidb_vector/integrations/vector_client.py",
            "type": "replace",
            "plan_detail": "Remove the __del__ method entirely from TiDBVectorClient class. SQLAlchemy handles connection resources efficiently with proper garbage collection and context management in Python."
          }
        ]
      },
      "response": {
        "scratch_pad": "1.1 The issue is describing an `AttributeError` during the deletion of an object of class `TiDBVectorClient`, where `NoneType` object is attempted to be used as if it has `Connection` attributes.\n\n1.2 The issue is caused because the `self._bind` attribute, which is expected to be a `sqlalchemy.engine.Connection`, is somehow `None` during the `__del__` method.\n\n1.3 The user expects the `__del__` method to properly close a valid `sqlalchemy.engine.Connection` object if it exists, without throwing an error.\n\n1.4 If `self._bind` is `None`, it is safe to say that there should be no operation to perform during destruction of the object related to `Connection`, hence `__del__` should be tolerant to `None` case.\n\n1.5 To fix the issue, the `__del__` method should check that `self._bind` is not `None` and check if `self._bind` can call `close()` before attempting to use it.\n\n1.6 The solution should minimally alter the existing code logic, primarily focusing on making the `__del__` method tolerant of `None` in `_bind` attribute.",
        "changed_code": "    def __del__(self) -> None:\n        \"\"\"Close the connection when the program is closed\"\"\"\n        if self._bind is not None:\n            if hasattr(self._bind, 'close') and callable(getattr(self._bind, 'close', None)):\n                self._bind.close()",
        "explain_code": "The code modification is in the `__del__` method of `TiDBVectorClient` class. \n\n1. I added a more defensive programming approach by checking if `self._bind` is not `None` first.\n2. Before calling `close()`, it verifies that `self._bind` has a `close` attribute and that it is callable using `hasattr()` and `getattr()`. \n\nThese additional checks ensure that if for some reason `self._bind` is `None` or is not a `Connection` object and does not support `close`, execution will not attempt to call `close()` causing an `AttributeError`. This allows for safer memory cleanup.",
        "is_fault": false
      }
    }
  ]
}